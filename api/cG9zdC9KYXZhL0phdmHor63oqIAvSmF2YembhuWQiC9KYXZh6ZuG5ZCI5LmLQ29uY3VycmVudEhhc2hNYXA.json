{"title":"Java集合之ConcurrentHashMap","date":"2020-03-04T04:00:37.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"thumbnail":"post/Java/Java语言/Java集合/Java集合之ConcurrentHashMap/cover.jpg","link":"post/Java/Java语言/Java集合/Java集合之ConcurrentHashMap","categories":["Java","Java语言","Java集合"],"updated":"2020-03-16T15:30:48.411Z","content":"<h1 id=\"线程安全集合\">线程安全集合<a href=\"#线程安全集合\" title=\"线程安全集合\"></a></h1><h2 id=\"遗留类\">遗留类<a href=\"#遗留类\" title=\"遗留类\"></a></h2><h3 id=\"hashtable\">Hashtable<a href=\"#hashtable\" title=\"Hashtable\"></a></h3><p>操作方法都加上了synchronized方法</p>\n<ul><li>线程安全</li>\n<li>效率低</li>\n</ul><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304143543204.png\" class=\"\">\n\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304143555314.png\" class=\"\">\n\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304143610470.png\" class=\"\">\n\n<h3 id=\"vector\">Vector<a href=\"#vector\" title=\"Vector\"></a></h3><p>操作方法都加上了synchronized方法</p>\n<ul><li>线程安全</li>\n<li>效率低</li>\n</ul><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304143646124.png\" class=\"\">\n\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304143702877.png\" class=\"\">\n\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304143714473.png\" class=\"\">\n\n<h2 id=\"collectionssynchronizedxxx\">Collections.synchronizedXXX<a href=\"#collectionssynchronizedxxx\" title=\"Collections.synchronizedXXX\"></a></h2><p>装饰器模式，给所有的方法都加上了synchronized锁</p>\n<ul><li>线程安全</li>\n<li>效率低</li>\n</ul><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304143827188.png\" class=\"\">\n\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304143906844.png\" class=\"\">\n\n<h2 id=\"concurrentxxx\">ConcurrentXXX<a href=\"#concurrentxxx\" title=\"ConcurrentXXX\"></a></h2><p>位于JUC包下的线程安全集合，更加高效的线程安全集合。</p>\n<h1 id=\"concurrenthashmap继承体系\">ConcurrentHashMap继承体系<a href=\"#concurrenthashmap继承体系\" title=\"ConcurrentHashMap继承体系\"></a></h1><p>实现了ConcurrentMap接口，该接口继承自Map接口。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304144057009.png\" class=\"\">\n\n<h1 id=\"concurrenthashmap之jdk18\">ConcurrentHashMap之JDK1.8<a href=\"#concurrenthashmap之jdk18\" title=\"ConcurrentHashMap之JDK1.8\"></a></h1><h2 id=\"底层实现\">底层实现<a href=\"#底层实现\" title=\"底层实现\"></a></h2><p>哈希表</p>\n<ul><li>拉链法解决哈希冲突<ul><li>链表</li>\n<li>红黑树</li>\n</ul></li>\n</ul><p><strong>大部分逻辑和HashMap相同</strong>，如扩容策略，链表和红黑树互转时机等，只是多了并发控制。</p>\n<h2 id=\"并发初始化\">并发初始化<a href=\"#并发初始化\" title=\"并发初始化\"></a></h2><p>在第一次put时会进行哈希桶的延时初始化，使用CAS和sizeCtl的状态来做并发控制。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304152521384.png\" class=\"\">\n\n<h2 id=\"并发读\">并发读<a href=\"#并发读\" title=\"并发读\"></a></h2><p>不加锁，可直接读。</p>\n<h3 id=\"读转发\">读转发<a href=\"#读转发\" title=\"读转发\"></a></h3><p>当发现哈希桶的某个头节点的hash小于0时，这时候可能是</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304155937578.png\" class=\"\">\n\n<ul><li>该节点为红黑树节点</li>\n<li>正在进行扩容Rehash操作，该节点被转移到了新的哈希桶中</li>\n</ul><p>此时会调用该节点的find方法进行读操作的转发。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304155735382.png\" class=\"\">\n\n<h2 id=\"并发写\">并发写<a href=\"#并发写\" title=\"并发写\"></a></h2><h3 id=\"第一次put\">第一次Put<a href=\"#第一次put\" title=\"第一次Put\"></a></h3><p>进行哈希桶初始化。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304152726723.png\" class=\"\">\n\n<h3 id=\"当前key对应的哈希桶为空\">当前Key对应的哈希桶为空<a href=\"#当前key对应的哈希桶为空\" title=\"当前Key对应的哈希桶为空\"></a></h3><p>CAS将其替换成新节点。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304152749946.png\" class=\"\">\n\n<h3 id=\"当前key对应的哈希桶不为空\">当前Key对应的哈希桶不为空<a href=\"#当前key对应的哈希桶不为空\" title=\"当前Key对应的哈希桶不为空\"></a></h3><p><strong>插入</strong></p>\n<ol><li>对该哈希桶的头节点使用synchronized加锁<ul><li>细粒度锁，只锁住需要操作的链表，提高并发度</li>\n</ul></li>\n<li>若为链表，则尾插法插入链表末尾（无相同节点的情况下，有相同的根据onlyIfAbsent判断是否替换）</li>\n<li>若为红黑树，则插入红黑树（无相同节点的情况下，有相同的根据onlyIfAbsent判断是否替换）</li>\n</ol><p><strong>树化</strong></p>\n<p>若链表长度大于TREEIFY_THRESHOLD，则转化为红黑树。</p>\n<p><strong>计数</strong></p>\n<p>把size加1，这里使用了和LongAdder相同的机制，并发写的情况下会设置Cell来转移冲突，提高并发。</p>\n<p><strong>扩容</strong></p>\n<p>若元素数量达到阈值，进行并发扩容。</p>\n<h2 id=\"并发扩容\">并发扩容<a href=\"#并发扩容\" title=\"并发扩容\"></a></h2><p>ConcurrentHashMap中的并发扩容不是让一个线程扩容，其他线程阻塞，而是当线程发现哈希表正在扩容时，会一起加入帮助进行Rehash步骤。</p>\n<h3 id=\"任务分配\">任务分配<a href=\"#任务分配\" title=\"任务分配\"></a></h3><p>根据CPU核心的数量计算出每个线程应该负责的链表的数量，最小为MIN_TRANSFER_STRIDE（16）</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/4574759-f28446ce245991a4.webp\" class=\"\">\n\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304154326068.png\" class=\"\">\n\n<h3 id=\"转发标记\">转发标记<a href=\"#转发标记\" title=\"转发标记\"></a></h3><p>一个链表只能被一个线程进行Rehash，所以当一个链表开始被某个线程进行处理时，它会首先将该链表头替换成一个ForwardingNode作为标记，这样其他线程发现该链表头为ForwardingNode时就知道该链表已经有线程在进行处理了。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/4574759-55cddf434c67c24f.webp\" class=\"\">\n\n<h2 id=\"size计算\">Size计算<a href=\"#size计算\" title=\"Size计算\"></a></h2><p>由于存储size时使用了Cell来转移冲突，所以统计元素数量时就需要将所有的Cell中计数和baseCount加起来。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304154819534.png\" class=\"\">\n\n<p><strong>Size弱一致性</strong></p>\n<p>由于在统计元素数量时可能还会有并发进行的写操作，所以统计出来的size不一定是准确的。</p>\n<h1 id=\"concurrenthashmap之jdk17\">ConcurrentHashMap之JDK1.7<a href=\"#concurrenthashmap之jdk17\" title=\"ConcurrentHashMap之JDK1.7\"></a></h1><h2 id=\"底层实现-1\">底层实现<a href=\"#底层实现-1\" title=\"底层实现\"></a></h2><p>两层哈希表</p>\n<ul><li><p>外层Segment</p>\n</li>\n<li><p>内层HashEntry</p>\n</li>\n<li><p>冲突解决方法为拉链法</p>\n<ul><li>链表</li>\n</ul></li>\n</ul><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap/image-20200304161157615.png\" class=\"\">\n\n<h2 id=\"segment数组初始化\">Segment数组初始化<a href=\"#segment数组初始化\" title=\"Segment数组初始化\"></a></h2><p>构造器调用时直接进行初始化，分配Segment数组空间。</p>\n<ul><li><strong>Segment</strong>数组大小固定，不可变</li>\n<li>Segment继承自ReentrantLock</li>\n</ul><h2 id=\"并发读-1\">并发读<a href=\"#并发读-1\" title=\"并发读\"></a></h2><p>读操作不加锁，可并发进行。</p>\n<h2 id=\"并发写-1\">并发写<a href=\"#并发写-1\" title=\"并发写\"></a></h2><ol><li>自旋获取对应Segment的锁<ul><li>在多处理器环境下，重复次数为64</li>\n<li>单处理器重复次数为1</li>\n<li>当执行<code>tryLock()</code>方法的次数超过上限时，则执行<code>lock()</code>方法挂起线程</li>\n</ul></li>\n<li>写入<ul><li>已经获取了分段锁，所以可以直接写</li>\n</ul></li>\n</ol><h2 id=\"size计算-1\">Size计算<a href=\"#size计算-1\" title=\"Size计算\"></a></h2><ol><li>求和所有Segment的元素数量，并记录下当前所有Segment的总modCount</li>\n<li>计算完后记录下当前的modCount求和结果为last</li>\n<li>再次回到步骤1，计算完后判断modCount和是否等于last<ul><li>相等：统计期间未发生并发修改，结果有效</li>\n<li>不相等：统计期间发生了并发修改，结果无效，回到步骤1进行重试，最多重试RETRIES_BEFORE_LOCK（2）次</li>\n</ul></li>\n<li>若重试两次后依旧结果无效，则对当前Segment进行加锁，再次统计</li>\n</ol>","prev":{"title":"Java集合之Set","link":"post/Java/Java语言/Java集合/Java集合之Set"},"next":{"title":"Java集合之TreeMap","link":"post/Java/Java语言/Java集合/Java集合之TreeMap"},"plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之ConcurrentHashMap/","toc":[{"id":"线程安全集合","title":"线程安全集合","index":"1","children":[{"id":"遗留类","title":"遗留类","index":"1.1","children":[{"id":"hashtable","title":"Hashtable","index":"1.1.1"},{"id":"vector","title":"Vector","index":"1.1.2"}]},{"id":"collectionssynchronizedxxx","title":"Collections.synchronizedXXX","index":"1.2"},{"id":"concurrentxxx","title":"ConcurrentXXX","index":"1.3"}]},{"id":"concurrenthashmap继承体系","title":"ConcurrentHashMap继承体系","index":"2"},{"id":"concurrenthashmap之jdk18","title":"ConcurrentHashMap之JDK1.8","index":"3","children":[{"id":"底层实现","title":"底层实现","index":"3.1"},{"id":"并发初始化","title":"并发初始化","index":"3.2"},{"id":"并发读","title":"并发读","index":"3.3","children":[{"id":"读转发","title":"读转发","index":"3.3.1"}]},{"id":"并发写","title":"并发写","index":"3.4","children":[{"id":"第一次put","title":"第一次Put","index":"3.4.1"},{"id":"当前key对应的哈希桶为空","title":"当前Key对应的哈希桶为空","index":"3.4.2"},{"id":"当前key对应的哈希桶不为空","title":"当前Key对应的哈希桶不为空","index":"3.4.3"}]},{"id":"并发扩容","title":"并发扩容","index":"3.5","children":[{"id":"任务分配","title":"任务分配","index":"3.5.1"},{"id":"转发标记","title":"转发标记","index":"3.5.2"}]},{"id":"size计算","title":"Size计算","index":"3.6"}]},{"id":"concurrenthashmap之jdk17","title":"ConcurrentHashMap之JDK1.7","index":"4","children":[{"id":"底层实现-1","title":"底层实现","index":"4.1"},{"id":"segment数组初始化","title":"Segment数组初始化","index":"4.2"},{"id":"并发读-1","title":"并发读","index":"4.3"},{"id":"并发写-1","title":"并发写","index":"4.4"},{"id":"size计算-1","title":"Size计算","index":"4.5"}]}]}