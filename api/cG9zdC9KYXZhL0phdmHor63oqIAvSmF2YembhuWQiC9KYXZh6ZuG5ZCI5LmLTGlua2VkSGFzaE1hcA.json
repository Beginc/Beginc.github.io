{"title":"Java集合之LinkedHashMap","date":"2020-03-04T04:00:25.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"thumbnail":"post/Java/Java语言/Java集合/Java集合之LinkedHashMap/cover.jpg","link":"post/Java/Java语言/Java集合/Java集合之LinkedHashMap","categories":["Java","Java语言","Java集合"],"updated":"2020-03-16T15:30:48.408Z","content":"<h1 id=\"继承体系\">继承体系<a href=\"#继承体系\" title=\"继承体系\"></a></h1><p>继承自HashMap。</p>\n<p><strong>和TreeMap的不同</strong></p>\n<p>TreeMap保证的顺序是Key的排序顺序，而不是插入顺序。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BLinkedHashMap/image-20200304172524027.png\" class=\"\">\n\n<h1 id=\"迭代顺序\">迭代顺序<a href=\"#迭代顺序\" title=\"迭代顺序\"></a></h1><h2 id=\"插入顺序\">插入顺序<a href=\"#插入顺序\" title=\"插入顺序\"></a></h2><p>保证了迭代顺序为Key插入的顺序。</p>\n<h2 id=\"lru顺序\">LRU顺序<a href=\"#lru顺序\" title=\"LRU顺序\"></a></h2><p>保住了迭代顺序为最近最少使用的Key到最近使用最多的Key。可用来实现LRU缓存。</p>\n<ul><li>accessOrder为true</li>\n</ul><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                         <span class=\"keyword\">float</span> loadFactor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                         <span class=\"keyword\">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(initialCapacity, loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.accessOrder = accessOrder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>影响顺序的方法</strong></p>\n<ul><li>put</li>\n<li>putAll</li>\n<li>putIfAbsent</li>\n<li>get</li>\n<li>getOrDefault</li>\n<li>replace</li>\n<li>compute</li>\n<li>computeIfAbsent</li>\n<li>computeIfPresent</li>\n<li>merge</li>\n</ul><p><strong>不影响顺序</strong></p>\n<p>使用下列方法时，不影响顺序。</p>\n<ul><li>keySet</li>\n<li>values</li>\n<li>entrySet</li>\n</ul><h1 id=\"底层实现\">底层实现<a href=\"#底层实现\" title=\"底层实现\"></a></h1><p>底层使用了双向链表来串联所有的Entry，其顺序就是Key插入的顺序。</p>\n<h2 id=\"实现原理\">实现原理<a href=\"#实现原理\" title=\"实现原理\"></a></h2><p>在HashMap中为LinkedHashMap预留了三个回调函数，在执行了对应的方法后，就会调用对应的回调函数。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeAccess</span><span class=\"params\">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeInsertion</span><span class=\"params\">(<span class=\"keyword\">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeRemoval</span><span class=\"params\">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"afternodeaccess\">afterNodeAccess<a href=\"#afternodeaccess\" title=\"afterNodeAccess\"></a></h3><p>当开启了accessOrder时，将其放到链表的尾部。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BLinkedHashMap/image-20200304174639405.png\" class=\"\">\n\n<h3 id=\"afternodeinsertion\">afterNodeInsertion<a href=\"#afternodeinsertion\" title=\"afterNodeInsertion\"></a></h3><p><strong>扩展点</strong></p>\n<p>要实现LRU缓存的自动淘汰功能，可重写removeEldestEntry来决定是否要进行节点删除。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BLinkedHashMap/image-20200304175103905.png\" class=\"\">\n\n<h3 id=\"afternoderemoval\">afterNodeRemoval<a href=\"#afternoderemoval\" title=\"afterNodeRemoval\"></a></h3><p>从链表移除节点。</p>\n<h3 id=\"newnode\">newNode<a href=\"#newnode\" title=\"newNode\"></a></h3><ul><li>HashMap中使用newNode来创建链表节点</li>\n</ul><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BLinkedHashMap/image-20200315171200310.png\" class=\"\">\n\n<ul><li>LinkedHashMap重写了newNode方法，<strong>同时还将新的节点插入了链表的末尾</strong></li>\n</ul><img class=\"-20200315171340965.png\">\n\n<h3 id=\"newtreenode\">newTreeNode<a href=\"#newtreenode\" title=\"newTreeNode\"></a></h3><ul><li>原理同newNode</li>\n</ul><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BLinkedHashMap/image-20200315171420740.png\" class=\"\">\n\n<h1 id=\"实现lru缓存\">实现LRU缓存<a href=\"#实现lru缓存\" title=\"实现LRU缓存\"></a></h1><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>&lt;<span class=\"title\">String</span>, <span class=\"title\">Integer</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CACHE_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LRUCache</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"number\">16</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.capacity = DEFAULT_CACHE_CAPACITY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LRUCache</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(capacity, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;String, Integer&gt; eldest)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() &gt; capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LRUCache cache = <span class=\"keyword\">new</span> LRUCache(<span class=\"number\">4</span>);</span><br><span class=\"line\">        cache.put(<span class=\"string\">\"A\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        cache.put(<span class=\"string\">\"B\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        cache.put(<span class=\"string\">\"C\"</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        cache.put(<span class=\"string\">\"D\"</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        <span class=\"comment\">// &#123;A=1, B=2, C=3, D=4&#125;</span></span><br><span class=\"line\">        System.out.println(cache);</span><br><span class=\"line\">        cache.put(<span class=\"string\">\"E\"</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">// &#123;B=2, C=3, D=4, E=5&#125;</span></span><br><span class=\"line\">        System.out.println(cache);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","prev":{"title":"Java集合之TreeMap","link":"post/Java/Java语言/Java集合/Java集合之TreeMap"},"next":{"title":"Java集合之NavigableMap","link":"post/Java/Java语言/Java集合/Java集合之NavigableMap"},"plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之LinkedHashMap/","toc":[{"id":"继承体系","title":"继承体系","index":"1"},{"id":"迭代顺序","title":"迭代顺序","index":"2","children":[{"id":"插入顺序","title":"插入顺序","index":"2.1"},{"id":"lru顺序","title":"LRU顺序","index":"2.2"}]},{"id":"底层实现","title":"底层实现","index":"3","children":[{"id":"实现原理","title":"实现原理","index":"3.1","children":[{"id":"afternodeaccess","title":"afterNodeAccess","index":"3.1.1"},{"id":"afternodeinsertion","title":"afterNodeInsertion","index":"3.1.2"},{"id":"afternoderemoval","title":"afterNodeRemoval","index":"3.1.3"},{"id":"newnode","title":"newNode","index":"3.1.4"},{"id":"newtreenode","title":"newTreeNode","index":"3.1.5"}]}]},{"id":"实现lru缓存","title":"实现LRU缓存","index":"4"}]}