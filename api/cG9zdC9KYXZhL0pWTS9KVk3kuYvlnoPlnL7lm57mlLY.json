{"title":"JVM之垃圾回收","date":"2020-03-01T01:41:03.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"thumbnail":"post/Java/JVM/JVM之垃圾回收/cover.jpg","link":"post/Java/JVM/JVM之垃圾回收","categories":["JVM","Java"],"updated":"2020-03-02T01:41:26.225Z","content":"<h1 id=\"判断可回收对象\">判断可回收对象<a href=\"#判断可回收对象\" title=\"判断可回收对象\"></a></h1><h2 id=\"引用计数法\">引用计数法<a href=\"#引用计数法\" title=\"引用计数法\"></a></h2><ul><li>记录一个对象被引用的次数</li>\n<li>当被引用次数为0时该对象可被回收</li>\n</ul><p><strong>循环引用</strong></p>\n<p>发生循环引用时两个对象都不可被回收。</p>\n<img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20200301110416304.png\" class=\"\">\n\n<h2 id=\"可达性分析法\">可达性分析法<a href=\"#可达性分析法\" title=\"可达性分析法\"></a></h2><p>从GC Root对象出发，寻找引用对象链，被GC Root直接或间接引用的对象为不可回收对象。</p>\n<h3 id=\"gc-root\">GC Root<a href=\"#gc-root\" title=\"GC Root\"></a></h3><p>GC Root对象是不可回收的对象。</p>\n<ul><li><p>System Class由启动类加载器加载的类</p>\n</li>\n<li><p>Thread活跃的线程</p>\n</li>\n<li><p>Stack Local局部变量和参数</p>\n</li>\n<li><p>JNI Local本地方法调用的局部变量和参数</p>\n</li>\n<li><p>JNI Global全局JNI引用</p>\n</li>\n<li><p>Monitor Used用于synchronized的对象</p>\n</li>\n<li><p>Held By JVM</p>\n<ul><li>系统类加载器</li>\n<li>一些重要的异常类</li>\n</ul></li>\n</ul><h2 id=\"五种引用\">五种引用<a href=\"#五种引用\" title=\"五种引用\"></a></h2><img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20200301114908487.png\" class=\"\">\n\n<h3 id=\"强引用\">强引用<a href=\"#强引用\" title=\"强引用\"></a></h3><ul><li>沿着GC Root的引用链能够找到，则不会被回收。</li>\n</ul><h3 id=\"软引用\">软引用<a href=\"#软引用\" title=\"软引用\"></a></h3><ul><li>仅有软引用引用该对象时，在垃圾回收后，<strong>若内存仍然不足时会触发垃圾回收</strong>，回收软引用引用的对象。</li>\n<li>软引用本身的回收<strong>可以</strong>配合引用队列。</li>\n</ul><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        String s = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">        ReferenceQueue&lt;String&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">        SoftReference&lt;String&gt; reference = <span class=\"keyword\">new</span> SoftReference&lt;&gt;(s, queue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"弱引用\">弱引用<a href=\"#弱引用\" title=\"弱引用\"></a></h3><ul><li>仅有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用引用的对象。</li>\n<li>弱引用本身的回收<strong>可以</strong>配合引用队列。</li>\n</ul><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        String s = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">        ReferenceQueue&lt;String&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">        WeakReference&lt;String&gt; reference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(s, queue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"虚引用\">虚引用<a href=\"#虚引用\" title=\"虚引用\"></a></h3><ul><li>不影响关联对象的垃圾回收</li>\n<li>虚引用<strong>必须</strong>配合引用队列使用</li>\n<li>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</li>\n</ul><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        String s = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">        ReferenceQueue&lt;String&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">        PhantomReference&lt;String&gt; reference = <span class=\"keyword\">new</span> PhantomReference&lt;&gt;(s, queue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"终结器引用\">终结器引用<a href=\"#终结器引用\" title=\"终结器引用\"></a></h3><ul><li><p>当一个对象重写了finalize方法，在类加载的时候JVM会调用Finalizer的register方法将其封装成一个Finalizer对象，并且最终封装到FinalReference对象里面</p>\n</li>\n<li><p>终结器引用<strong>必须</strong>配合引用队列使用</p>\n</li>\n<li><p>在垃圾回收时会将终结器引用入队（此时还没回收对象）</p>\n</li>\n<li><p>Finalizer线程会通过终结器引用找到引用对象调用其finalize方法</p>\n</li>\n<li><p>第二次垃圾回收时该对象才会被回收</p>\n</li>\n</ul><h1 id=\"垃圾回收算法\">垃圾回收算法<a href=\"#垃圾回收算法\" title=\"垃圾回收算法\"></a></h1><h2 id=\"标记清除mark-sweep\">标记清除Mark Sweep<a href=\"#标记清除mark-sweep\" title=\"标记清除Mark Sweep\"></a></h2><p><strong>步骤</strong></p>\n<ol><li>对可回收对象进行标记</li>\n<li>回收内存</li>\n</ol><p><strong>优点</strong></p>\n<ul><li>速度快</li>\n</ul><p><strong>缺点</strong></p>\n<ul><li>内存碎片</li>\n</ul><img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20200301125955761.png\" class=\"\">\n\n<h2 id=\"标记整理mark-compact\">标记整理Mark Compact<a href=\"#标记整理mark-compact\" title=\"标记整理Mark Compact\"></a></h2><p><strong>步骤</strong></p>\n<ol><li>标记可回收对象</li>\n<li>回收内存</li>\n<li>紧凑</li>\n</ol><p><strong>优点</strong></p>\n<ul><li>无内存碎片</li>\n</ul><p><strong>缺点</strong></p>\n<ul><li>速度慢</li>\n</ul><img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20200301131406573.png\" class=\"\">\n\n<h2 id=\"复制copying\">复制Copying<a href=\"#复制copying\" title=\"复制Copying\"></a></h2><p><strong>步骤</strong></p>\n<ol><li>标记FROM中可回收对象</li>\n<li>将存活对象复制到TO</li>\n<li>回收FROM的内存</li>\n<li>交换FROM和TO</li>\n</ol><p><strong>优点</strong></p>\n<ul><li><p>速度快</p>\n</li>\n<li><p>无内存碎片</p>\n</li>\n</ul><p><strong>缺点</strong></p>\n<ul><li>需要双倍内存空间</li>\n</ul><img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20200301131548173.png\" class=\"\">\n\n<h2 id=\"分代垃圾回收\">分代垃圾回收<a href=\"#分代垃圾回收\" title=\"分代垃圾回收\"></a></h2><p><strong>分代</strong></p>\n<ul><li>新生代<ul><li>伊甸园</li>\n<li>幸存区<ul><li>FROM</li>\n<li>TO</li>\n</ul></li>\n</ul></li>\n<li>老年代</li>\n</ul><p><strong>步骤</strong></p>\n<ol><li>对象首先分配在伊甸园区</li>\n<li>当新生代空间不足时触发Minor GC<ul><li>伊甸园和FROM存活的对象复制到TO中</li>\n<li>存活的对象年龄加1</li>\n<li>交换FROM和TO</li>\n<li><strong>Minor GC会Stop The World</strong></li>\n</ul></li>\n<li>当Minor GC时对象寿命超过阈值<ul><li>晋升至老年代</li>\n<li>最大寿命为15</li>\n</ul></li>\n<li>当老年代空间不足时<ul><li>先尝试触发Minor GC</li>\n<li>若空间仍然不足，则触发Full GC进行全盘垃圾回收，<strong>会Stop The World</strong></li>\n</ul></li>\n</ol><img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20200301131800853.png\" class=\"\">\n\n<p><strong>VM参数</strong></p>\n<div class=\"cz\"><div class=\"db\"><table><thead><tr>\n<th>参数</th><th>功能</th></tr>\n</thead><tbody><tr>\n<td>-Xms</td><td>堆初始大小</td></tr>\n<tr>\n<td>-Xmx或-XX:MaxHeapSize=size</td><td>堆最大大小</td></tr>\n<tr>\n<td>-Xmn或-XX:MaxNewSize=size</td><td>新生代大小</td></tr>\n<tr>\n<td>-XX:+UseAdaptiveSizePolicy</td><td>每次 GC 后会重新计算 Eden、From 和 To 区的大小，计算依据是 GC 过程中统计的 <strong>GC 时间、吞吐量、内存占用量</strong>。</td></tr>\n<tr>\n<td>-XX:InitialSurvivorRatio=ratio + -XX:+UseAdaptiveSizePolicy</td><td>幸存区占新生代比例（动态大小）</td></tr>\n<tr>\n<td>-XX:SurvivorRatio=8(Eden为8/10，FROM和TO各为1/10)</td><td>幸存区占新生代比例（静态大小）</td></tr>\n<tr>\n<td>-XX:MaxTenuringThreshold=threshold</td><td>晋升阈值</td></tr>\n<tr>\n<td>-XX:+PrintTenuringDistribution</td><td>打印晋升详情</td></tr>\n<tr>\n<td>-XX:+PrintGCDetails -verbose:gc</td><td>打印GC详情</td></tr>\n<tr>\n<td>-XX:+ScavengeBeforeFullGC</td><td>Full GC前进行Minor GC</td></tr>\n</tbody></table></div></div><h1 id=\"垃圾回收器\">垃圾回收器<a href=\"#垃圾回收器\" title=\"垃圾回收器\"></a></h1><img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/v2-e3e51fd92c3d7bdbc59d01f4420386ea_720w.jpg\" class=\"\">\n\n<h2 id=\"serial-gc--serial-old-gc\">Serial GC + Serial Old GC<a href=\"#serial-gc--serial-old-gc\" title=\"Serial GC + Serial Old GC\"></a></h2><p><strong>特点</strong></p>\n<ul><li>单线程进行垃圾回收</li>\n<li>回收时Stop The World</li>\n<li>Serial GC负责新生代<ul><li>使用复制算法</li>\n</ul></li>\n<li>Serial Old GC负责老年代<ul><li>使用标记整理算法</li>\n</ul></li>\n</ul><img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20200301133440122.png\" class=\"\">\n\n<p><strong>VM参数</strong></p>\n<ul><li>-XX:+UseSerialGC<ul><li>新生代Serial GC</li>\n<li>老年代Serial Old GC</li>\n</ul></li>\n</ul><h2 id=\"parnew-gc\">ParNew GC<a href=\"#parnew-gc\" title=\"ParNew GC\"></a></h2><p><strong>特点</strong></p>\n<ul><li>简单的将Serial GC多线程化</li>\n<li>其他都和Serial GC相同</li>\n<li>工作在新生代</li>\n</ul><p><strong>VM参数</strong></p>\n<ul><li>-XX:+UseParNewGC<ul><li>新生代ParNew GC</li>\n<li>老年代Serial Old GC</li>\n</ul></li>\n</ul><h2 id=\"parallel-gc--parallel-old-gc\">Parallel GC + Parallel Old GC<a href=\"#parallel-gc--parallel-old-gc\" title=\"Parallel GC + Parallel Old GC\"></a></h2><p><strong>特点</strong></p>\n<ul><li><p>和ParNew差不多相同</p>\n</li>\n<li><p>关注的是垃圾回收的吞吐量</p>\n</li>\n<li><p>Parallel GC负责新生代</p>\n<ul><li>使用复制算法</li>\n</ul></li>\n<li><p>Parallel Old GC负责老年代</p>\n<ul><li>使用标记整理算法</li>\n</ul></li>\n<li><p>1.8默认采用</p>\n</li>\n</ul><img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20200301135246502.png\" class=\"\">\n\n<p><strong>VM参数</strong></p>\n<ul><li>-XX:+UseParallelGC<ul><li>新生代Parallel GC</li>\n<li>老年代Serial Old GC</li>\n</ul></li>\n<li>-XX:+UseParallelOldGC<ul><li>新生代Parallel GC</li>\n<li>老年代Parallel Old GC</li>\n</ul></li>\n<li>-XX:GCTimeRatio=ratio大于0小于100，最大GC时间占比允许为1 / (1 + ratio)<ul><li>与-XX:UseAdaptiveSizePolicy配合使用</li>\n</ul></li>\n<li>-XX:MaxGCPauseMillis=ms最大GC允许停顿时间<ul><li>与-XX:UseAdaptiveSizePolicy配合使用</li>\n</ul></li>\n<li>-XX:ParallelGCThreads=n并行的线程数</li>\n</ul><h2 id=\"cms-gc\">CMS GC<a href=\"#cms-gc\" title=\"CMS GC\"></a></h2><p><strong>特点</strong></p>\n<ul><li>工作在老年代</li>\n<li>关注响应时间</li>\n</ul><p><strong>步骤</strong></p>\n<ol><li>初始标记<ul><li>标记从GC Roots可直达的老年代对象</li>\n<li>遍历被新生代存活对象所引用的老年代对象(<strong>需要扫描新生代</strong>)</li>\n</ul></li>\n</ol><img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/cb22385099c2d5861cc6824aeb503770\" class=\"\">\n\n<ol><li>并发标记<ul><li>遍历第一个阶段标记的对象，递归遍历老年代，对存活的老年代对象进行标记</li>\n<li><strong>并发标记是和用户线程同时运行的，可能出现以下情况，这些对象对应的Card会被标记为Dirty</strong><ul><li>新生代的对象晋升到了老年代</li>\n<li>直接在老年代分配的对象（大对象）</li>\n<li>老年代对象的引用关系发生变更</li>\n<li>...</li>\n<li><strong>总而言之就是</strong><ul><li>老年代多出了对象</li>\n<li>老年代里引用和被引用关系发生了变化</li>\n</ul></li>\n</ul></li>\n</ul></li>\n</ol><img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/v2-eeffdf6f0d15276b8d87b67b585ade3a_720w.jpg\" class=\"\">\n\n<ol><li><p>并发预清理</p>\n<ul><li>扫描Dirty对象，进行相应的标记，清除Card标识</li>\n</ul></li>\n<li><p>可中止的并发预清理</p>\n<p> 发送该阶段的前提</p>\n<ul><li><p>Eden内存使用量超过了CMSScheduleRemarkEdenSizeThreshold</p>\n<p>该阶段循环执行两项任务</p>\n</li>\n<li><p>扫描FROM和TO区的对象，标记可达的老年代对象</p>\n</li>\n<li><p>扫描处理Dirty Card中的对象</p>\n<p>中止条件</p>\n</li>\n<li><p>循环次数达到阈值CMSMaxAbortablePrecleanLoops</p>\n</li>\n<li><p>执行时间达到阈值CMSMaxAbortablePrecleanTime</p>\n</li>\n<li><p>新生代Eden区的内存使用量达到了阈值CMSScheduleRemarkEdenPenetration</p>\n</li>\n</ul></li>\n<li><p>重新标记</p>\n<p> <strong>Stop The World</strong>进行最后的重新标记</p>\n<ul><li>遍历新生代对象，重新可达的老年代对象</li>\n<li>根据GC Root，标记可达的老年代对象</li>\n<li>遍历老年代的Dirty Card，重新标记</li>\n</ul></li>\n<li><p>并发清理</p>\n<ul><li>使用<strong>标记清除</strong>算法回收内存</li>\n</ul></li>\n<li><p>并发重置</p>\n<ul><li>重新初始化</li>\n</ul></li>\n</ol><h3 id=\"触发时机\">触发时机<a href=\"#触发时机\" title=\"触发时机\"></a></h3><p><strong>周期性GC（Background Collector）</strong></p>\n<p>每隔2秒检查是否满足GC条件</p>\n<p>*<em>未开启-XX:+UseCMSInitiatingOccupancyOnly *</em></p>\n<ul><li>老年代使用率达到阈值CMSInitiatingOccupancyFraction</li>\n<li>永久代的使用率达到阈值CMSInitiatingPermOccupancyFraction且开启了CMSClassUnloadingEnabled</li>\n<li>新生代的晋升担保失败<ul><li>老年代没有足够的空间来容纳全部的新生代对象或历史平均晋升到老年代的对象</li>\n</ul></li>\n</ul><p><strong>主动GC（Foreground Collector）</strong></p>\n<ul><li>新生代晋升失败</li>\n<li>执行System.gc()</li>\n</ul><h3 id=\"cms降级\">CMS降级<a href=\"#cms降级\" title=\"CMS降级\"></a></h3><p>当内存碎片过多，在老年区分配空间也失败后，CMS会退化 为Serial Old。</p>\n<h3 id=\"full-gc时机\">Full GC时机<a href=\"#full-gc时机\" title=\"Full GC时机\"></a></h3><p>当回收垃圾的速度赶不上产生垃圾的速度，并发失败时触发Full GC。</p>\n<h3 id=\"vm参数\">VM参数<a href=\"#vm参数\" title=\"VM参数\"></a></h3><div class=\"cz\"><div class=\"db\"><table><thead><tr>\n<th>参数</th><th>功能</th></tr>\n</thead><tbody><tr>\n<td>-XX:+UseConcMarkSweepGC</td><td>新生代为ParNew；老年代为CMS；并发失败时为Serial Old</td></tr>\n<tr>\n<td>-XX:ParallelGCThreads</td><td>并行GC进行内存回收时的线程数量</td></tr>\n<tr>\n<td>-XX:ConcGCThreads</td><td>并发GC时的线程数量</td></tr>\n<tr>\n<td>-XX::CMSInitiatingOccupancyFraction</td><td>老年代内存达到百分之多少时触发GC</td></tr>\n<tr>\n<td>-XX:+CMSScavengeBeforeRemark</td><td>重新标记前是否执行Minor GC</td></tr>\n<tr>\n<td>-XX:+CMSInitiatingPermOccupancyFraction</td><td>永久代达到百分之多少时触发GC</td></tr>\n<tr>\n<td>-XX:+CMSPrecleaningEnabled</td><td>开启并发预清理</td></tr>\n<tr>\n<td>-XX:CMSScheduleRemarkEdenSizeThreshold</td><td>Eden内存超过该阈值时执行可中止的并发预清理</td></tr>\n<tr>\n<td>-XX:CMSMaxAbortablePrecleanLoops</td><td>可中止并发预清理阶段循环次数阈值</td></tr>\n<tr>\n<td>-XX:CMSMaxAbortablePrecleanTime</td><td>可中止并发预清理阶段循环时间阈值</td></tr>\n</tbody></table></div></div><h2 id=\"g1-gc\">G1 GC<a href=\"#g1-gc\" title=\"G1 GC\"></a></h2><p><strong>特点</strong></p>\n<ul><li>同时注重吞吐量和响应时间</li>\n<li>适合超大堆内存</li>\n<li>将堆划分为多个大小相等的Region</li>\n<li>整体上为标记整理算法，两个区域之间复制使用复制算法</li>\n<li>工作在新生代和老年代</li>\n</ul><p><strong>步骤</strong></p>\n<ol><li><p>新生代回收(会Stop The World)</p>\n<p> Eden区内存达到一定数量时会触发新生代回收</p>\n</li>\n</ol><img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20200301155923286.png\" class=\"\">\n\n<p>​    幸存的复制到幸存区</p>\n<img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20200301155958520.png\" class=\"\">\n\n<p>​    当幸存区满后Eden区和幸存区幸存的对象拷贝到另一个幸存区，达到年龄阈值的晋升到老年代</p>\n<img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20200301160018739.png\" class=\"\">\n\n<ol><li><p>新生代垃圾回收 + 并发标记</p>\n<ul><li><p>在YGC的时候回对GC Root可直达的对象进行初始标记</p>\n</li>\n<li><p>老年代占用对空间达到阈值InitiatingHeapOccupancyPercent时会进行并发标记(不会STW)</p>\n<img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20200301160456847.png\" class=\"\">\n</li>\n</ul></li>\n<li><p>混合垃圾回收</p>\n<ul><li><p>会对E,S,O三个区进行全面垃圾回收</p>\n<ul><li>最终标记(Remark)会STW</li>\n<li>拷贝存活(Evacuation)会STW<ul><li>-XX:MaxGCPauseMillis=ms拷贝老年代时根据该参数只挑一部分老年代对象进行回收</li>\n</ul></li>\n</ul><img src=\"/post/Java/JVM/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20200301160607025.png\" class=\"\">\n\n</li>\n</ul></li>\n</ol><p><strong>Full GC时机</strong></p>\n<p>并发标记和混合收集时若回收速度低于产生速度时发生Full GC。</p>\n<p><strong>VM参数</strong></p>\n<ul><li>-XX:+UseG1GC</li>\n<li>-XX:G1HeapRegionSize=size调整堆Region的大小</li>\n</ul><h1 id=\"参考\">参考<a href=\"#参考\" title=\"参考\"></a></h1><ol><li><a href=\"https://zhuanlan.zhihu.com/p/52182397\" target=\"_blank\">图解 CMS 垃圾回收机制，你值得拥有</a></li>\n<li><a href=\"https://www.codercto.com/a/45937.html\" target=\"_blank\">Java之CMS GC的7个阶段</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28258571\" target=\"_blank\">垃圾回收算法与 JVM 垃圾回收器综述</a></li>\n</ol>","prev":{"title":"JVM之内存结构","link":"post/Java/JVM/JVM之内存结构"},"next":{"title":"Docker之DockerCompose","link":"post/Docker/Docker之DockerCompose"},"plink":"https://beginc.github.io/post/Java/JVM/JVM之垃圾回收/","toc":[{"id":"判断可回收对象","title":"判断可回收对象","index":"1","children":[{"id":"引用计数法","title":"引用计数法","index":"1.1"},{"id":"可达性分析法","title":"可达性分析法","index":"1.2","children":[{"id":"gc-root","title":"GC Root","index":"1.2.1"}]},{"id":"五种引用","title":"五种引用","index":"1.3","children":[{"id":"强引用","title":"强引用","index":"1.3.1"},{"id":"软引用","title":"软引用","index":"1.3.2"},{"id":"弱引用","title":"弱引用","index":"1.3.3"},{"id":"虚引用","title":"虚引用","index":"1.3.4"},{"id":"终结器引用","title":"终结器引用","index":"1.3.5"}]}]},{"id":"垃圾回收算法","title":"垃圾回收算法","index":"2","children":[{"id":"标记清除mark-sweep","title":"标记清除Mark Sweep","index":"2.1"},{"id":"标记整理mark-compact","title":"标记整理Mark Compact","index":"2.2"},{"id":"复制copying","title":"复制Copying","index":"2.3"},{"id":"分代垃圾回收","title":"分代垃圾回收","index":"2.4"}]},{"id":"垃圾回收器","title":"垃圾回收器","index":"3","children":[{"id":"serial-gc--serial-old-gc","title":"Serial GC + Serial Old GC","index":"3.1"},{"id":"parnew-gc","title":"ParNew GC","index":"3.2"},{"id":"parallel-gc--parallel-old-gc","title":"Parallel GC + Parallel Old GC","index":"3.3"},{"id":"cms-gc","title":"CMS GC","index":"3.4","children":[{"id":"触发时机","title":"触发时机","index":"3.4.1"},{"id":"cms降级","title":"CMS降级","index":"3.4.2"},{"id":"full-gc时机","title":"Full GC时机","index":"3.4.3"},{"id":"vm参数","title":"VM参数","index":"3.4.4"}]},{"id":"g1-gc","title":"G1 GC","index":"3.5"}]},{"id":"参考","title":"参考","index":"4"}]}