{"title":"11-Spring之循环引用","date":"2020-03-02T15:22:42.000Z","date_formatted":{"ll":"Mar 2, 2020","L":"03/02/2020","MM-DD":"03-02"},"thumbnail":"post/Java/Spring/11-Spring之循环引用/cover.png","link":"post/Java/Spring/11-Spring之循环引用","categories":["Java","Spring"],"updated":"2020-03-03T05:44:01.048Z","content":"<h1 id=\"循环引用\">循环引用<a href=\"#循环引用\" title=\"循环引用\"></a></h1><p>循环引用即对象之前直接或间接的互为创建对象的前提条件，导致没有一个Bean能够创建成功，形象化比喻就是要由鸡得先有蛋，但是要由蛋得先有鸡。</p>\n<h1 id=\"spring检测循环引用\">Spring检测循环引用<a href=\"#spring检测循环引用\" title=\"Spring检测循环引用\"></a></h1><h2 id=\"基础数据结构\">基础数据结构<a href=\"#基础数据结构\" title=\"基础数据结构\"></a></h2><h3 id=\"dependentbeanmap\">DependentBeanMap<a href=\"#dependentbeanmap\" title=\"DependentBeanMap\"></a></h3><p>就是一个HashMap，存储了一个Bean都被哪些Bean给依赖。</p>\n<img src=\"/post/Java/Spring/11-Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/image-20200302234616389.png\" class=\"\">\n\n<h3 id=\"dependenciesforbeanmap\">DependenciesForBeanMap<a href=\"#dependenciesforbeanmap\" title=\"DependenciesForBeanMap\"></a></h3><p>就是一个HashMap，存储了一个Bean都依赖了哪些Bean。</p>\n<img src=\"/post/Java/Spring/11-Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/image-20200302234629311.png\" class=\"\">\n\n<h2 id=\"检测机制\">检测机制<a href=\"#检测机制\" title=\"检测机制\"></a></h2><p>核心解决思路就是</p>\n<ul><li>创建A时先创建A的依赖B</li>\n<li>创建A的依赖B时先检查A是否又被B直接或间接依赖<ul><li>若A又被B依赖则发生了循环引用</li>\n<li>若A未被B依赖则无循环引用</li>\n</ul></li>\n</ul><h3 id=\"直接循环引用\">直接循环引用<a href=\"#直接循环引用\" title=\"直接循环引用\"></a></h3><p>假设A和B直接循环引用。</p>\n<img src=\"/post/Java/Spring/11-Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/image-20200302234655149.png\" class=\"\">\n\n<ol><li><p>准备创建A</p>\n</li>\n<li><p>发现A依赖B</p>\n</li>\n<li><p>检查A是否被B依赖</p>\n<ul><li>检查A的DependentBeanMap</li>\n<li>发现A的DependentBeanMap为null，则说明当前没有发现被B依赖</li>\n</ul><img src=\"/post/Java/Spring/11-Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/image-20200302233739411.png\" class=\"\">\n</li>\n<li><p>记录当前发现的依赖关系</p>\n<ul><li>A依赖B</li>\n<li>B被A依赖</li>\n</ul></li>\n</ol><img src=\"/post/Java/Spring/11-Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/image-20200302234721066.png\" class=\"\">\n\n<ol><li><p>准备创建B</p>\n</li>\n<li><p>发现B依赖A</p>\n</li>\n<li><p>检查B是否被A依赖</p>\n<ul><li>查看B的DependentBeanMap</li>\n<li>发现B被A依赖</li>\n</ul></li>\n<li><p>创建失败，发现循环引用</p>\n</li>\n</ol><h3 id=\"间接循环引用\">间接循环引用<a href=\"#间接循环引用\" title=\"间接循环引用\"></a></h3><p>假设A依赖B，B依赖C，C又依赖A。</p>\n<img src=\"/post/Java/Spring/11-Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/image-20200302234814943.png\" class=\"\">\n\n\n\n<ol><li><p>准备创建A</p>\n</li>\n<li><p>发现A依赖B</p>\n</li>\n<li><p>检查A是否被B依赖</p>\n<ul><li><p>检查A的DependentBeanMap</p>\n</li>\n<li><p>发现没有，则说明当前没有发现被B依赖</p>\n</li>\n</ul><img src=\"/post/Java/Spring/11-Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/image-20200302233739411.png\" class=\"\">\n</li>\n<li><p>记录当前发现的依赖关系</p>\n<ul><li>A依赖B</li>\n<li>B被A依赖</li>\n</ul></li>\n</ol><img src=\"/post/Java/Spring/11-Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/image-20200302234721066.png\" class=\"\">\n\n<ol><li><p>准备创建B</p>\n</li>\n<li><p>发现B依赖C</p>\n</li>\n<li><p>检查B是否被C依赖</p>\n<ul><li>查看B的DependentBeanMap，发现不包含C，但是DependentBeanMap不为空</li>\n<li><strong>此时可能发生间接循环引用</strong></li>\n</ul></li>\n<li><p><strong>递归检查每一个依赖B的Bean是否被C依赖</strong></p>\n</li>\n</ol><ul><li>检查到有，说明发生了间接循环引用<ul><li>未检查到，说明当前未发现</li>\n</ul></li>\n</ul><ol><li>[递归中]检查A是否被C依赖</li>\n</ol><ul><li>查看A的DependentBeanMap，发现为null，则说明当前没有发现A被C依赖</li>\n</ul><ol><li>[递归返回]检查完了每一个依赖B的Bean，发现当前未被C依赖，说明当前B未被C依赖</li>\n<li>记录当前发现的依赖关系<ul><li>B依赖C</li>\n<li>C被B依赖</li>\n</ul></li>\n</ol><img src=\"/post/Java/Spring/11-Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/image-20200303000209433.png\" class=\"\">\n\n<ol><li>准备创建C</li>\n<li>发现C依赖A</li>\n<li>检查C是否被A依赖<ul><li>查看C的DependentBeanMap，发现不包含A，但是不为空</li>\n<li><strong>此时可能发生间接循环引用</strong></li>\n</ul></li>\n<li><strong>递归检查每一个依赖C的Bean是否被A依赖</strong></li>\n<li>[递归中]检查B是否被A依赖<ul><li>查看B的DependentBeanMap，发现包含A</li>\n</ul></li>\n<li>发生了间接循环引用</li>\n</ol><h1 id=\"源码分析\">源码分析<a href=\"#源码分析\" title=\"源码分析\"></a></h1><img src=\"/post/Java/Spring/11-Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/image-20200303000632037.png\" class=\"\">\n\n<img src=\"/post/Java/Spring/11-Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/image-20200303000950836.png\" class=\"\">\n\n<h1 id=\"循环引用解决方案\">循环引用解决方案<a href=\"#循环引用解决方案\" title=\"循环引用解决方案\"></a></h1><img src=\"/post/Java/Spring/11-Spring%E4%B9%8B%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/image-20200302234655149.png\" class=\"\">\n\n<h2 id=\"使用setter注入依赖\">使用Setter注入依赖<a href=\"#使用setter注入依赖\" title=\"使用Setter注入依赖\"></a></h2><p>使用Setter注入时，A与B都可顺利创建完毕，然后再使用Setter给其注入依赖。</p>\n","prev":{"title":"12-Spring之AOP原理","link":"post/Java/Spring/12-Spring之AOP原理"},"next":{"title":"10-Spring之IoC容器初始化与Bean生命周期","link":"post/Java/Spring/10-Spring之IoC容器初始化与Bean生命周期"},"plink":"https://beginc.github.io/post/Java/Spring/11-Spring之循环引用/","toc":[{"id":"循环引用","title":"循环引用","index":"1"},{"id":"spring检测循环引用","title":"Spring检测循环引用","index":"2","children":[{"id":"基础数据结构","title":"基础数据结构","index":"2.1","children":[{"id":"dependentbeanmap","title":"DependentBeanMap","index":"2.1.1"},{"id":"dependenciesforbeanmap","title":"DependenciesForBeanMap","index":"2.1.2"}]},{"id":"检测机制","title":"检测机制","index":"2.2","children":[{"id":"直接循环引用","title":"直接循环引用","index":"2.2.1"},{"id":"间接循环引用","title":"间接循环引用","index":"2.2.2"}]}]},{"id":"源码分析","title":"源码分析","index":"3"},{"id":"循环引用解决方案","title":"循环引用解决方案","index":"4","children":[{"id":"使用setter注入依赖","title":"使用Setter注入依赖","index":"4.1"}]}]}