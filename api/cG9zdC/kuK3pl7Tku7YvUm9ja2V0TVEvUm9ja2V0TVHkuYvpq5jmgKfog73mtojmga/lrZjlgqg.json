{"title":"RocketMQ之高性能消息存储","date":"2020-02-27T12:04:21.000Z","date_formatted":{"ll":"Feb 27, 2020","L":"02/27/2020","MM-DD":"02-27"},"thumbnail":"post/中间件/RocketMQ/RocketMQ之高性能消息存储/cover.png","link":"post/中间件/RocketMQ/RocketMQ之高性能消息存储","categories":["RocketMQ","中间件"],"updated":"2020-02-29T16:17:20.759Z","content":"<h1 id=\"消息发送流程\">消息发送流程<a href=\"#消息发送流程\" title=\"消息发送流程\"></a></h1><p>在RocketMQ所有消息都会被持久化存储。</p>\n<ul><li>消息发送：先持久化消息再回复ACK</li>\n<li>消息消费：需要从持久化文件中读取消息</li>\n</ul><p>消息I/O的性能决定了整个MQ系统的性能，因此必须设计出一套高效的消息存储方案。</p>\n<img src=\"/post/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ%E4%B9%8B%E9%AB%98%E6%80%A7%E8%83%BD%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/image-20200227200508757.png\" class=\"\">\n\n<h1 id=\"存储结构\">存储结构<a href=\"#存储结构\" title=\"存储结构\"></a></h1><h2 id=\"commitlog\">CommitLog<a href=\"#commitlog\" title=\"CommitLog\"></a></h2><p>MQ收到消息时会先把消息持久化，然后再返回ACK确认，为了保证I/O的高效性，RocketMQ用到了两个技术。</p>\n<h3 id=\"顺序写\">顺序写<a href=\"#顺序写\" title=\"顺序写\"></a></h3><p>对于磁盘介质来说，顺序读写时速度最快，因此Broker会维护CommitLog文件，当消息来时（任何主题的消息），会追加到该文件的末尾，来保证最高的性能。一个CommitLog文件默认最大大小为1G，超过后会重新创建一个CommitLog文件，以该文件第一个消息的Offset来命名。</p>\n<h3 id=\"零拷贝\">零拷贝<a href=\"#零拷贝\" title=\"零拷贝\"></a></h3><p>使用了mmap + write技术减少了CPU拷贝缓冲区的次数。</p>\n<p><strong>传统I/O</strong></p>\n<p>对于传统I/O方式一次I/O读和一次I/O写需要</p>\n<ul><li>4次用户态内核态上下文切换</li>\n<li>2次CPU Copy</li>\n<li>2次DMA Copy</li>\n</ul><img src=\"/post/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ%E4%B9%8B%E9%AB%98%E6%80%A7%E8%83%BD%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/v2-18e66cbb4e06d1f13e4335898c7b8e8c_720w.jpg\" class=\"\">\n\n<p><strong>mmap + write</strong></p>\n<p>使用内存映射文件(mmap)技术可将一块磁盘空间映射到一个用户和内核公用的内核缓冲区中，一次I/O读和I/O写需要</p>\n<ul><li>4次用户态内核态上下文切换</li>\n<li><strong>1次CPU Copy</strong></li>\n<li>2次DMA Copy</li>\n</ul><img src=\"/post/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ%E4%B9%8B%E9%AB%98%E6%80%A7%E8%83%BD%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/v2-28463616753963ac9f189ce23a485e2d_720w.jpg\" class=\"\">\n\n<h2 id=\"comsumequeue\">ComsumeQueue<a href=\"#comsumequeue\" title=\"ComsumeQueue\"></a></h2><p>在Broker中所有的消息都被写入了CommitLog文件时，而Consumer进行消息消费时，需要按照Topic进行消息检索，此时会有很大的查找开销，因此RocketMQ使用了ConsumeQueue文件来进行索引加速。每个Topic的每个队列都会有一个ConsumeQueue文件，存储了</p>\n<ul><li>CommitLog Offset消息在CommitLog中的起始Offset</li>\n<li>Size消息的大小</li>\n<li>Message Tag  HashCode</li>\n</ul><img src=\"/post/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ%E4%B9%8B%E9%AB%98%E6%80%A7%E8%83%BD%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/image-20200227202715907.png\" class=\"\">\n\n<h2 id=\"index\">Index<a href=\"#index\" title=\"Index\"></a></h2><p>该文件提供了索引结构以来支持按key或者时间区间对消息进行查询。</p>\n<h1 id=\"高可靠消息存储\">高可靠消息存储<a href=\"#高可靠消息存储\" title=\"高可靠消息存储\"></a></h1><h2 id=\"刷盘机制\">刷盘机制<a href=\"#刷盘机制\" title=\"刷盘机制\"></a></h2><p><strong>同步刷盘</strong></p>\n<p>Broker接收到消息时，将消息写入到CommitLog中后再返回ACK。</p>\n<ul><li>性能较低</li>\n</ul><p><strong>异步刷盘</strong></p>\n<p>Broker接收到消息时，消息只写入了缓冲区中，此时直接返回，在消息积累到一定程度时，统一触发刷盘操作。</p>\n<ul><li>性能较高</li>\n</ul><h2 id=\"主从复制\">主从复制<a href=\"#主从复制\" title=\"主从复制\"></a></h2><p><strong>同步复制</strong></p>\n<p>同步双写，当Master和Slave都写成功后，才返回ACK。</p>\n<ul><li>高可靠</li>\n<li>性能较低</li>\n</ul><p><strong>异步复制</strong></p>\n<p>Master写成功后，直接返回ACK，异步复制到Slave。</p>\n<ul><li>低可靠</li>\n<li>性能较高</li>\n</ul><h2 id=\"故障恢复\">故障恢复<a href=\"#故障恢复\" title=\"故障恢复\"></a></h2><p>由于消息会先存储到CommitLog中，然后异步地更新ConsumeQueue和Index文件，若来不及更新时就宕机，则会导致数据不一致。</p>\n<p><strong>解决方法</strong></p>\n<p>Broker在启动时会<strong>创建abort文件</strong></p>\n<ul><li>正常退出：在JVM钩子函数中删除abort文件</li>\n<li>非正常退出：启动时检测到abort文件存在，说明数据可能不一致，会进行修复</li>\n</ul>","prev":{"title":"Linux零拷贝","link":"post/Linux/Linux零拷贝"},"next":{"title":"RocketMQ之高可用消息发送","link":"post/中间件/RocketMQ/RocketMQ之高可用消息发送"},"plink":"https://beginc.github.io/post/中间件/RocketMQ/RocketMQ之高性能消息存储/","toc":[{"id":"消息发送流程","title":"消息发送流程","index":"1"},{"id":"存储结构","title":"存储结构","index":"2","children":[{"id":"commitlog","title":"CommitLog","index":"2.1","children":[{"id":"顺序写","title":"顺序写","index":"2.1.1"},{"id":"零拷贝","title":"零拷贝","index":"2.1.2"}]},{"id":"comsumequeue","title":"ComsumeQueue","index":"2.2"},{"id":"index","title":"Index","index":"2.3"}]},{"id":"高可靠消息存储","title":"高可靠消息存储","index":"3","children":[{"id":"刷盘机制","title":"刷盘机制","index":"3.1"},{"id":"主从复制","title":"主从复制","index":"3.2"},{"id":"故障恢复","title":"故障恢复","index":"3.3"}]}]}