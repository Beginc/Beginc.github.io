{"title":"MySQL事务","date":"2020-03-12T05:23:28.000Z","date_formatted":{"ll":"Mar 12, 2020","L":"03/12/2020","MM-DD":"03-12"},"thumbnail":"post/数据库/MySQL/MySQL事务/cover.png","link":"post/数据库/MySQL/MySQL事务","categories":["MySQL","数据库"],"updated":"2020-03-13T16:27:33.136Z","content":"<h1 id=\"不一致现象\">不一致现象<a href=\"#不一致现象\" title=\"不一致现象\"></a></h1><p><strong>丢失修改</strong></p>\n<p>如下所示，两次对A减10的修改丢失了一次。</p>\n<div class=\"cz\"><div class=\"db\"><table><thead><tr>\n<th>事务T1</th><th>事务T2</th><th>A</th></tr>\n</thead><tbody><tr>\n<td>Read(A, t1)将A读入t1变量中</td><td></td><td>100</td></tr>\n<tr>\n<td></td><td>Read(A, t2)将A读入t2变量中</td><td>100</td></tr>\n<tr>\n<td>t1 = t1 - 10</td><td></td><td>100</td></tr>\n<tr>\n<td></td><td>t2 = t2 - 10</td><td>100</td></tr>\n<tr>\n<td>Write(A, t1)</td><td></td><td>90</td></tr>\n<tr>\n<td></td><td>Write(A)</td><td>90</td></tr>\n</tbody></table></div></div><p><strong>不可重复读</strong></p>\n<p>事务T1并未进行写操作，但是重复读A却读到了不同的数据。</p>\n<div class=\"cz\"><div class=\"db\"><table><thead><tr>\n<th>事务T1</th><th>事务T2</th><th>A</th></tr>\n</thead><tbody><tr>\n<td>Read(A, t1)</td><td></td><td>100</td></tr>\n<tr>\n<td></td><td>Write(A, 90)</td><td>90</td></tr>\n<tr>\n<td>Read(A, t1)</td><td></td><td>90</td></tr>\n</tbody></table></div></div><p><strong>脏读</strong></p>\n<p>事务T1读到了事务T2未提交的数据，然后事务T2竟然回滚了，导致T1读到的数据和数据库不一致。</p>\n<div class=\"cz\"><div class=\"db\"><table><thead><tr>\n<th>事务T1</th><th>事务T2</th><th>A</th></tr>\n</thead><tbody><tr>\n<td></td><td>Begin T2</td><td>100</td></tr>\n<tr>\n<td></td><td>Write(A, 90)</td><td>90</td></tr>\n<tr>\n<td>Read(A, t1)</td><td></td><td>90</td></tr>\n<tr>\n<td></td><td>Rollback</td><td>100</td></tr>\n</tbody></table></div></div><p><strong>幻读</strong></p>\n<p>事务T1读到了事务T2插入的数据，导致前后第二次读到的数据多了一条。</p>\n<div class=\"cz\"><div class=\"db\"><table><thead><tr>\n<th>事务T1</th><th>事务T2</th><th>A表</th></tr>\n</thead><tbody><tr>\n<td>读A表所有记录（1条）</td><td></td><td>1条记录</td></tr>\n<tr>\n<td></td><td>插入A表一条记录</td><td>2条记录</td></tr>\n<tr>\n<td>读A表所有记录（2条）</td><td></td><td>2条记录</td></tr>\n</tbody></table></div></div><h1 id=\"事务的概念\">事务的概念<a href=\"#事务的概念\" title=\"事务的概念\"></a></h1><p>事务为一组原子性的操作，要么全部执行，要么全部不执行。</p>\n<h2 id=\"特性\">特性<a href=\"#特性\" title=\"特性\"></a></h2><h2 id=\"原子性\">原子性<a href=\"#原子性\" title=\"原子性\"></a></h2><p>事务的一组操作，要么全部执行，要么全部不执行。</p>\n<h2 id=\"一致性\">一致性<a href=\"#一致性\" title=\"一致性\"></a></h2><p>保证不出现不一致现象。</p>\n<h2 id=\"隔离性\">隔离性<a href=\"#隔离性\" title=\"隔离性\"></a></h2><p>事务之前不互相影响。</p>\n<h2 id=\"持久性\">持久性<a href=\"#持久性\" title=\"持久性\"></a></h2><p>已提交事务的影响是持久化到磁盘上了的。</p>\n<h1 id=\"事务的隔离级别\">事务的隔离级别<a href=\"#事务的隔离级别\" title=\"事务的隔离级别\"></a></h1><h3 id=\"四种隔离级别\">四种隔离级别<a href=\"#四种隔离级别\" title=\"四种隔离级别\"></a></h3><div class=\"cz\"><div class=\"db\"><table><thead><tr>\n<th style=\"padding:0\"></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr>\n</thead><tbody><tr>\n<td>Read Uncommitted</td><td></td><td></td><td></td></tr>\n<tr>\n<td>Read Committed</td><td>解决</td><td></td><td></td></tr>\n<tr>\n<td>Repeatable Read</td><td>解决</td><td>解决</td><td></td></tr>\n<tr>\n<td>Serializable</td><td>解决</td><td>解决</td><td>解决</td></tr>\n</tbody></table></div></div><h3 id=\"read-uncommited\">Read Uncommited<a href=\"#read-uncommited\" title=\"Read Uncommited\"></a></h3><p>可读未提交的数据。</p>\n<h3 id=\"read-commited\">Read Commited<a href=\"#read-commited\" title=\"Read Commited\"></a></h3><p>只能读已经提交的数据。</p>\n<h3 id=\"repeatable-read（默认）\">Repeatable Read（默认）<a href=\"#repeatable-read（默认）\" title=\"Repeatable Read（默认）\"></a></h3><p>可重复读。</p>\n<h3 id=\"serializable\">Serializable<a href=\"#serializable\" title=\"Serializable\"></a></h3><p>事务调度是可串行化的。</p>\n<h1 id=\"事务的隔离级别实现原理\">事务的隔离级别实现原理<a href=\"#事务的隔离级别实现原理\" title=\"事务的隔离级别实现原理\"></a></h1><h2 id=\"innodb多版本并发控制mvcc\">InnoDB多版本并发控制MVCC<a href=\"#innodb多版本并发控制mvcc\" title=\"InnoDB多版本并发控制MVCC\"></a></h2><p>InnoDB中对MVCC协议进行了实现。有关MVCC的最基础知识见<a href=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/\" title=\"数据库并发控制\">数据库并发控制</a>。</p>\n<h3 id=\"元组结构\">元组结构<a href=\"#元组结构\" title=\"元组结构\"></a></h3><div class=\"cz\"><div class=\"db\"><table><thead><tr>\n<th>RowID</th><th>IS_DELETE</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th><th>name</th></tr>\n</thead><tbody><tr>\n<td>InnoDB自动创建的ID列</td><td>元组是否被删除</td><td>相当于Begin</td><td>版本链指针</td><td>表中的姓名字段</td></tr>\n</tbody></table></div></div><h3 id=\"版本链\">版本链<a href=\"#版本链\" title=\"版本链\"></a></h3><p>InnoDB中的版本链存储使用的是<strong>Delta Storage</strong>，即存储增量更新。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">版本3(当前最新版本)\t\t\t版本2(旧版本)\t\t\t\t\t\t版本1(旧版本)</span><br><span class=\"line\">(name: lhw)     ---&gt;     (nameDelta: John)       ---&gt;       (nameDelta: Bob)</span><br><span class=\"line\">按照上述版本链我们可知：</span><br><span class=\"line\">版本2，由最新版本进行增量恢复name ---&gt; John，得到了版本2的元组</span><br><span class=\"line\">版本1，由版本2进行增量恢复name ---&gt; Bob，得到了版本1的元组</span><br></pre></td></tr></table></figure>\n\n<p>而这种增量存储和增量恢复，其实就是Undo日志的形式，所以InnoDB中版本链中的历史数据是存储在Undo日志中的。版本链通过DB_ROLL_PTR来串联，该指针实际上指向的就是Undo日志中的回滚段。而且InnoDB中的版本链组织顺序为由新到旧。</p>\n<h3 id=\"可见性\">可见性<a href=\"#可见性\" title=\"可见性\"></a></h3><p>可见性是通过创建Read View来实现的。</p>\n<h4 id=\"read-view\">Read View<a href=\"#read-view\" title=\"Read View\"></a></h4><p>Read View就是对当前所有事务状态的一个快照。</p>\n<p><strong>为什么要使用事务快照</strong></p>\n<p>我们首先需要明白为什么需要使用事务快照。以Repetable Read隔离级别举例，我们希望在事务并发调度中，我们当前事务不应该读到别的事务未提交的数据，和本应该在我们的读操作之后才发生的写操作写入的数据，但并发调度下执行顺序是不可预知的，因此在封锁协议中我们使用锁来进行限制，但带来的就是并发度的降低。在MVCC中我们对一个数据创建了多个历史版本，我们知道，对于一个事务来说，肯定有某个版本的数据是符合我们当前要求的，所以我们需要一种方法来判断哪个历史版本的数据是对我们可见的，因此我们使用事务快照来实现。</p>\n<p><strong>Read View结构</strong></p>\n<div class=\"cz\"><div class=\"db\"><table><thead><tr>\n<th>ReadView::id</th><th>ReadView::m_ids</th><th>ReadView::m_low_limit_id</th><th>ReadView::m_up_limit_id</th></tr>\n</thead><tbody><tr>\n<td>创建该视图的事务ID</td><td>创建ReadView时，活跃的读写事务ID数组(未提交的事务)</td><td>当前已经创建的最大事务ID（该事务可能提交了可能未提交）</td><td>ReadView:m_ids集合中的最小值</td></tr>\n</tbody></table></div></div><p>使用Read View我们将当前事务状态做了一个快照，分为三个部分</p>\n<ul><li>已经提交的事务（肯定是可见的）</li>\n<li>未提交与已提交的事务（未提交的不可见，提交的可见）</li>\n<li>未开始事务（肯定不可见）</li>\n</ul><img src=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL%E4%BA%8B%E5%8A%A1/image-20200312115721683.png\" class=\"\">\n\n<h4 id=\"可见性算法\">可见性算法<a href=\"#可见性算法\" title=\"可见性算法\"></a></h4><p>当我们要读取一行数据时我们进行如下比对</p>\n<ul><li>若DB_TRX_ID &lt; m_up_limit_id，可见</li>\n<li>若DB_TRX_ID &gt; m_low_limit_id，不可见</li>\n<li>若m_up_limit_id &lt; DB_TRX_ID &lt; m_low_limit_id<ul><li>若DB_TRX_ID在m_ids数组中，不可见</li>\n<li>若DB_TRX_ID不在m_ids数组中，可见</li>\n</ul></li>\n</ul><h3 id=\"操作\">操作<a href=\"#操作\" title=\"操作\"></a></h3><p>MVCC中有两种读的形式</p>\n<ul><li>快照读：读取可见版本，不加锁，即最普通的<code>select * from person</code></li>\n<li>当前读：读取最新版本，加行锁<ul><li>select * from person where name=lhw lock in share mode</li>\n<li>select * from person where name=lhw for update</li>\n<li>update person set name=John</li>\n<li>insert into person (name) values (Bob)</li>\n<li>delete from table where name=lhw</li>\n</ul></li>\n</ul><h4 id=\"读操作\">读操作<a href=\"#读操作\" title=\"读操作\"></a></h4><p>沿着版本链从新到旧进行查找，由可见性算法判断可见的数据是可读的。</p>\n<h4 id=\"写操作\">写操作<a href=\"#写操作\" title=\"写操作\"></a></h4><p>创建一个新的元组，旧元组放入Undo日志中。</p>\n<ul><li>DB_TRX_ID为当前事务ID</li>\n<li>DB_ROLL_PTR指向Undo日志中上一个数据版本</li>\n</ul><h2 id=\"innodb隔离级别实现原理\">InnoDB隔离级别实现原理<a href=\"#innodb隔离级别实现原理\" title=\"InnoDB隔离级别实现原理\"></a></h2><p>InnoDB中隔离级别的实现是使用了如下协议实现的</p>\n<ul><li>两阶段封锁协议</li>\n<li>MVCC多版本并发控制协议</li>\n</ul><h3 id=\"read-uncommitted\">Read Uncommitted<a href=\"#read-uncommitted\" title=\"Read Uncommitted\"></a></h3><ul><li>读最新的数据，不加锁，不会遍历版本链。<ul><li>因为读数据又不加锁又不使用MVCC所以会产生脏读</li>\n</ul></li>\n<li>写时加行锁，不加间隙锁，事务结束时解锁。<ul><li>即使用了封锁协议的1级协议，但是还是无法避免脏读，究其原因就是因为读不加锁！</li>\n</ul></li>\n</ul><h3 id=\"read-committed\">Read Committed<a href=\"#read-committed\" title=\"Read Committed\"></a></h3><p>用的是语句级别的事务快照。</p>\n<ul><li>读时<ul><li>创建Read View，下次读还需要再创建Read View，遍历版本链，使用可见性算法确定可见数据</li>\n<li>不加锁</li>\n</ul></li>\n<li>写时加行锁，不加间隙锁，事务结束时解锁。</li>\n</ul><h3 id=\"repeatable-read\">Repeatable Read<a href=\"#repeatable-read\" title=\"Repeatable Read\"></a></h3><ul><li>读时<ul><li>创建Read View，供本次事务所有读使用，遍历版本链，使用可见性算法确定可见数据</li>\n<li>不加锁</li>\n</ul></li>\n<li>写时<ul><li>有索引：行锁 + 间隙锁（带范围时，<strong>间隙锁可解决幻读</strong>）</li>\n<li>无索引：表锁</li>\n</ul></li>\n</ul><h3 id=\"serializable-1\">Serializable<a href=\"#serializable-1\" title=\"Serializable\"></a></h3><p>读写都加锁，使用S2PL严格两阶段封锁协议。</p>\n<ul><li>读时<ul><li>创建Read View，供本次事务所有读使用，遍历版本链，使用可见性算法确定可见数据</li>\n<li><strong>加共享锁</strong></li>\n</ul></li>\n<li>写时<ul><li>有索引：行锁 + 间隙锁</li>\n<li>无索引：表锁</li>\n</ul></li>\n</ul><h1 id=\"参考\">参考<a href=\"#参考\" title=\"参考\"></a></h1><ol><li><a href=\"https://www.zhihu.com/question/263820564\" target=\"_blank\">MySQL 是如何实现四大隔离级别的?</a></li>\n<li><a href=\"https://juejin.im/post/5da8493ae51d4524b25add55\" target=\"_blank\">你真的懂MVCC吗？来手动实践一下？</a></li>\n<li><a href=\"http://mysql.taobao.org/monthly/2015/12/01/\" target=\"_blank\">数据库内核日报: MySQL · 引擎特性 · InnoDB 事务子系统介绍</a></li>\n</ol>","prev":{"title":"地址解析协议","link":"post/计算机网络/地址解析协议"},"next":{"title":"数据库故障恢复","link":"post/数据库/数据库原理/数据库故障恢复"},"plink":"https://beginc.github.io/post/数据库/MySQL/MySQL事务/","toc":[{"id":"不一致现象","title":"不一致现象","index":"1"},{"id":"事务的概念","title":"事务的概念","index":"2","children":[{"id":"特性","title":"特性","index":"2.1"},{"id":"原子性","title":"原子性","index":"2.2"},{"id":"一致性","title":"一致性","index":"2.3"},{"id":"隔离性","title":"隔离性","index":"2.4"},{"id":"持久性","title":"持久性","index":"2.5"}]},{"id":"事务的隔离级别","title":"事务的隔离级别","index":"3","children":[{"id":"四种隔离级别","title":"四种隔离级别","index":"3.1"},{"id":"read-uncommited","title":"Read Uncommited","index":"3.2"},{"id":"read-commited","title":"Read Commited","index":"3.3"},{"id":"repeatable-read（默认）","title":"Repeatable Read（默认）","index":"3.4"},{"id":"serializable","title":"Serializable","index":"3.5"}]}]}