{"title":"数据库并发控制","date":"2020-03-12T05:17:07.000Z","date_formatted":{"ll":"Mar 12, 2020","L":"03/12/2020","MM-DD":"03-12"},"thumbnail":"post/数据库/数据库原理/数据库并发控制/cover.jpg","link":"post/数据库/数据库原理/数据库并发控制","categories":["数据库","数据库原理"],"updated":"2020-03-12T05:27:10.126Z","content":"<h1 id=\"事务调度\">事务调度<a href=\"#事务调度\" title=\"事务调度\"></a></h1><h2 id=\"概念\">概念<a href=\"#概念\" title=\"概念\"></a></h2><p>一组事务的基本步骤的一种执行顺序称作事务调度</p>\n<ul><li>读</li>\n<li>写</li>\n<li>加锁</li>\n<li>解锁</li>\n<li>...</li>\n</ul><h2 id=\"正确性\">正确性<a href=\"#正确性\" title=\"正确性\"></a></h2><p>只有当一个并发调度与串行调度的执行结果一致时，称该并发调度是正确的。</p>\n<h2 id=\"可串行性\">可串行性<a href=\"#可串行性\" title=\"可串行性\"></a></h2><p>不管数据库初始状态如何，若该调度都与串行调度结果一致，则称该事务调度是<strong>可串行化的</strong>。</p>\n<p><strong>与正确性的区别</strong></p>\n<ul><li>正确性：强调一次执行的正确性</li>\n<li>可串行性：强调不管初值是多少，执行多少次，都应该是正确的</li>\n</ul><h2 id=\"冲突可串行性\">冲突可串行性<a href=\"#冲突可串行性\" title=\"冲突可串行性\"></a></h2><h3 id=\"冲突\">冲突<a href=\"#冲突\" title=\"冲突\"></a></h3><p>若两个操作交换次序后会导致事务行为发生改变，则称两个操作是冲突的。</p>\n<p><strong>同一事务中</strong></p>\n<ul><li>任意两个操作都冲突</li>\n</ul><p><strong>不同事务中</strong></p>\n<ul><li>同一元素：写操作冲突</li>\n<li>同一元素：读后写，写后读冲突</li>\n</ul><h3 id=\"概念-1\">概念<a href=\"#概念-1\" title=\"概念\"></a></h3><p>若一个事务调度可通过交换无冲突的操作得到一个串行调度，则称该调度为冲突可串行化的调度。</p>\n<h3 id=\"意义\">意义<a href=\"#意义\" title=\"意义\"></a></h3><p>由于有如下关系</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务调度正确性 &gt; 事务调度可串行性 &gt; 事务调度冲突可串行性</span><br></pre></td></tr></table></figure>\n\n<p>要证明事务调度的正确性，我们可证明一个比其强的命题</p>\n<ul><li>事务调度是可串行化的</li>\n<li>事务调度是冲突可串行化的</li>\n</ul><p>但是可串行化是很难判断的，所以我们可以通过判断事务调度是不是冲突可串行化来判断一个事务调度是否正确。</p>\n<h3 id=\"判别算法\">判别算法<a href=\"#判别算法\" title=\"判别算法\"></a></h3><p><strong>前驱图</strong></p>\n<ol><li>每个事务一个节点</li>\n<li>若事务A中的某个操作T1与事务B中某个操作T2冲突，且满足如下条件，则绘制一条事务A指向事务B的有向边<ul><li>T1必须在T2之前执行</li>\n</ul></li>\n<li>若图中无环则可冲突串行化</li>\n</ol><img src=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200311204032683.png\" class=\"\">\n\n<img src=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200311204115865.png\" class=\"\">\n\n<h1 id=\"基于封锁的并发控制\">基于封锁的并发控制<a href=\"#基于封锁的并发控制\" title=\"基于封锁的并发控制\"></a></h1><h2 id=\"封锁协议内容\">封锁协议内容<a href=\"#封锁协议内容\" title=\"封锁协议内容\"></a></h2><p>一个封锁协议定义了如何使用锁来进行并发控制。</p>\n<h3 id=\"锁的类型\">锁的类型<a href=\"#锁的类型\" title=\"锁的类型\"></a></h3><h4 id=\"共享锁\">共享锁<a href=\"#共享锁\" title=\"共享锁\"></a></h4><ul><li>任何事务都可读</li>\n<li>任何事务都不可写</li>\n</ul><h4 id=\"排他锁\">排他锁<a href=\"#排他锁\" title=\"排他锁\"></a></h4><ul><li>拿到锁的事务可读写</li>\n<li>其他任何事务不可读写</li>\n</ul><h4 id=\"更新锁\">更新锁<a href=\"#更新锁\" title=\"更新锁\"></a></h4><ul><li>初始可读</li>\n<li>以后可升级为写</li>\n</ul><h4 id=\"增量锁\">增量锁<a href=\"#增量锁\" title=\"增量锁\"></a></h4><ul><li>专门用于执行增量操作 A = A + X</li>\n<li>双写操作本来是冲突的，但是两个增量操作是可交换次序的</li>\n</ul><h3 id=\"封锁粒度\">封锁粒度<a href=\"#封锁粒度\" title=\"封锁粒度\"></a></h3><p>属性值 ---&gt; 元组(行锁) ---&gt; 元组集合 ---&gt; 整个关系(表锁) ---&gt; 整个数据库</p>\n<ul><li>粒度小，封锁开销大，并发度高</li>\n<li>粒度大，封锁开销小，并发度低</li>\n</ul><h3 id=\"相容性矩阵\">相容性矩阵<a href=\"#相容性矩阵\" title=\"相容性矩阵\"></a></h3><p>定义持有一种锁时，是否还能再申请其他锁。</p>\n<img src=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200311205107462.png\" class=\"\">\n\n<img src=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200311205126874.png\" class=\"\">\n\n<h3 id=\"加锁解锁时机\">加锁解锁时机<a href=\"#加锁解锁时机\" title=\"加锁解锁时机\"></a></h3><h4 id=\"0级协议\">0级协议<a href=\"#0级协议\" title=\"0级协议\"></a></h4><p><strong>内容</strong></p>\n<ul><li>写之前加排他锁</li>\n<li>写完马上解锁</li>\n</ul><p><strong>解决的问题</strong></p>\n<ul><li>丢失修改<ul><li>读和写一起锁住保证原子性</li>\n</ul></li>\n</ul><p><strong>未解决的问题</strong></p>\n<ul><li>脏读</li>\n<li>不可重复读</li>\n<li>幻读</li>\n</ul><img src=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200311205600714.png\" class=\"\">\n\n\n\n<h4 id=\"1级协议\">1级协议<a href=\"#1级协议\" title=\"1级协议\"></a></h4><p><strong>内容</strong></p>\n<ul><li>写之前加排他锁</li>\n<li>事务提交后解锁</li>\n</ul><p><strong>解决的问题</strong></p>\n<ul><li>丢失修改</li>\n<li>脏读</li>\n</ul><p><strong>未解决的问题</strong></p>\n<ul><li>不可重复读</li>\n<li>幻读</li>\n</ul><img src=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200311205810331.png\" class=\"\">\n\n<h4 id=\"2级协议\">2级协议<a href=\"#2级协议\" title=\"2级协议\"></a></h4><p><strong>内容</strong></p>\n<ul><li>写之前加排他锁</li>\n<li>提交事务时解锁</li>\n<li>读之前加共享锁</li>\n<li>读完马上解锁</li>\n</ul><p><strong>解决的问题</strong></p>\n<ul><li>丢失修改</li>\n<li>脏读</li>\n<li>不可重复读</li>\n</ul><p><strong>未解决的问题</strong></p>\n<ul><li>幻读</li>\n</ul><img src=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200311205853607.png\" class=\"\">\n\n<h4 id=\"3级协议\">3级协议<a href=\"#3级协议\" title=\"3级协议\"></a></h4><p><strong>内容</strong></p>\n<ul><li>写之前加排他锁</li>\n<li>提交事务时解锁</li>\n<li>读之前加共享锁</li>\n<li>提交事务时解锁</li>\n</ul><p><strong>解决的问题</strong></p>\n<ul><li>丢失修改</li>\n<li>脏读</li>\n<li>不可重复读</li>\n<li>幻读</li>\n</ul><img src=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200311205832497.png\" class=\"\">\n\n\n\n<h2 id=\"两阶段封锁协议2pl\">两阶段封锁协议2PL<a href=\"#两阶段封锁协议2pl\" title=\"两阶段封锁协议2PL\"></a></h2><p>使用该协议可产生可串行化的事务调度。</p>\n<h3 id=\"内容\">内容<a href=\"#内容\" title=\"内容\"></a></h3><p>读写之前都要获取锁，并且该协议将堆锁的操作分为了两个阶段</p>\n<ul><li>加锁段</li>\n<li>解锁段</li>\n</ul><p><strong>加锁段先于解锁段</strong></p>\n<ul><li>加锁段中不能进行解锁</li>\n<li>解锁段中不能进行加锁</li>\n</ul><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 加锁段</span><br><span class=\"line\">Lock(A)</span><br><span class=\"line\">read(A)</span><br><span class=\"line\">lock(B)</span><br><span class=\"line\">write(B)</span><br><span class=\"line\"># 解锁段</span><br><span class=\"line\">Unlock(A)</span><br><span class=\"line\">unlock(B)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"死锁\">死锁<a href=\"#死锁\" title=\"死锁\"></a></h3><p>两阶段封锁协议可能产生死锁。</p>\n<h1 id=\"基于时间戳的并发控制\">基于时间戳的并发控制<a href=\"#基于时间戳的并发控制\" title=\"基于时间戳的并发控制\"></a></h1><h2 id=\"事务的时间戳\">事务的时间戳<a href=\"#事务的时间戳\" title=\"事务的时间戳\"></a></h2><ul><li>事务启动时，分配一个时间戳</li>\n<li>时间戳小的事务先执行，时间戳大的后执行</li>\n</ul><h2 id=\"并发控制\">并发控制<a href=\"#并发控制\" title=\"并发控制\"></a></h2><p>利用时间戳可进行无锁并发。</p>\n<ul><li>事务无冲突时：随便怎么执行</li>\n<li>事务冲突时：撤销重启该事务，分配一个更大的时间戳</li>\n</ul><p><strong>冲突</strong></p>\n<ul><li>读后写</li>\n<li>写后读</li>\n<li>写后写</li>\n</ul><h3 id=\"简单实现方法\">简单实现方法<a href=\"#简单实现方法\" title=\"简单实现方法\"></a></h3><p>每个数据有两个时间戳</p>\n<ul><li>WT：写过该数据的事务中最大的时间戳</li>\n<li>RT：读过该数据的事务中最大的时间戳</li>\n</ul><p>每个事务有一个时间戳</p>\n<ul><li>TS</li>\n</ul><h4 id=\"读写并发\">读写并发<a href=\"#读写并发\" title=\"读写并发\"></a></h4><p>防止读后写，写后读，即当发生了这两种冲突时，重启事务。</p>\n<p><strong>读数据</strong></p>\n<ul><li>若TS &gt; WT，操作允许，更新RT为max{RT, TS}</li>\n<li>若TS &lt; WT，操作失败，重启该事务</li>\n</ul><p><strong>写数据</strong></p>\n<ul><li>若TS &gt; RT，操作允许，更新WT为max{WT, TS}</li>\n<li>若TS &lt; RT，操作失败，重启该事务</li>\n</ul><h4 id=\"写写并发\">写写并发<a href=\"#写写并发\" title=\"写写并发\"></a></h4><p>防止写后写。</p>\n<ul><li>若TS &gt; WT，为按顺序写，允许操作，更新WT为TS</li>\n<li>若TS &lt; WT，即发生了写后写，重启该事务</li>\n</ul><h3 id=\"带提交位的实现方法\">带提交位的实现方法<a href=\"#带提交位的实现方法\" title=\"带提交位的实现方法\"></a></h3><p>简单实现方法中，无法解决脏读问题，即一个事务写数据后，另一个事务是可读的，但是若该写操作被撤销了，则导致了不一致性。</p>\n<p><strong>数据戳</strong></p>\n<ul><li>WT：写过该数据的事务中最大的时间戳</li>\n<li>RT：读过该数据的事务中最大的时间戳</li>\n<li>C：提交位，表明写该数据的事务是否已经提交</li>\n</ul><p>TODO</p>\n<h1 id=\"多版本并发控制mvcc\">多版本并发控制MVCC<a href=\"#多版本并发控制mvcc\" title=\"多版本并发控制MVCC\"></a></h1><p>在封锁协议中，我们可使用读写锁来达到</p>\n<ul><li>读读并发</li>\n<li>读写互斥</li>\n<li>写写互斥</li>\n</ul><p>提高了一定的并发度，而在MVCC中，通过引入版本和可见性控制，实现了</p>\n<ul><li>读读并发</li>\n<li>读写并发</li>\n<li>写写互斥</li>\n</ul><p>进一步提高了读多写少场景下的性能。</p>\n<h2 id=\"元组结构\">元组结构<a href=\"#元组结构\" title=\"元组结构\"></a></h2><ul><li>Version为版本标识</li>\n<li>Begin为最近创建或更新、删除该元组的事务时间戳</li>\n<li>End为该元组的过期时间戳（-代表当前未过期）</li>\n</ul><img src=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200312104740803.png\" class=\"\">\n\n<h2 id=\"操作\">操作<a href=\"#操作\" title=\"操作\"></a></h2><h3 id=\"更新操作\">更新操作<a href=\"#更新操作\" title=\"更新操作\"></a></h3><p>更新操作不会直接对原来的元组进行更新，而是会创建该元组的一个新的版本。</p>\n<ul><li>更新上一个版本的End为当前事务的时间戳</li>\n<li>新版本元组的Begin为当前事务的时间戳</li>\n</ul><img src=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200312105141075.png\" class=\"\">\n\n<img src=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200312105128354.png\" class=\"\">\n\n<h3 id=\"读操作\">读操作<a href=\"#读操作\" title=\"读操作\"></a></h3><p>对照元组的所有版本，若满足如下条件，则该版本的元组对当前事务来说是可见的</p>\n<ul><li>Begin &lt;= TS &lt;= End</li>\n</ul><h2 id=\"版本链version-chain\">版本链Version Chain<a href=\"#版本链version-chain\" title=\"版本链Version Chain\"></a></h2><p>由于一个元组有多个版本，因此我们使用链表的形式将其进行组织，组织的方式有如下两种</p>\n<ul><li>由新到旧</li>\n<li>由旧到新</li>\n</ul><h2 id=\"历史版本数据存储\">历史版本数据存储<a href=\"#历史版本数据存储\" title=\"历史版本数据存储\"></a></h2><p>对于历史版本的数据，我们有如下三种存储策略</p>\n<p><strong>Append Only Storage</strong></p>\n<p>所有版本的数据存储在同一个表中，使用版本链进行串联。</p>\n<img src=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200312105728626.png\" class=\"\">\n\n<p><strong>Time Travel Storage</strong></p>\n<p>旧版本的数据被复制到另一张表中，使用版本链进行串联。</p>\n<p><strong>Delta Storage</strong></p>\n<p>旧版本数据的增量被存储在另外的存储空间。</p>\n<ul><li>类似与Undo日志，Delta里面存储了该旧版本元组相对于新版本元组中，某个属性的旧值，这样我们可以通过对新版本的数据进行增量恢复，来得到旧版本的数据。</li>\n</ul><img src=\"/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/image-20200312110009213.png\" class=\"\">","prev":{"title":"数据库故障恢复","link":"post/数据库/数据库原理/数据库故障恢复"},"next":{"title":"Java并发之AQS","link":"post/Java并发之AQS"},"plink":"https://beginc.github.io/post/数据库/数据库原理/数据库并发控制/","toc":[{"id":"事务调度","title":"事务调度","index":"1","children":[{"id":"概念","title":"概念","index":"1.1"},{"id":"正确性","title":"正确性","index":"1.2"},{"id":"可串行性","title":"可串行性","index":"1.3"},{"id":"冲突可串行性","title":"冲突可串行性","index":"1.4","children":[{"id":"冲突","title":"冲突","index":"1.4.1"},{"id":"概念-1","title":"概念","index":"1.4.2"},{"id":"意义","title":"意义","index":"1.4.3"},{"id":"判别算法","title":"判别算法","index":"1.4.4"}]}]},{"id":"基于封锁的并发控制","title":"基于封锁的并发控制","index":"2","children":[{"id":"封锁协议内容","title":"封锁协议内容","index":"2.1","children":[{"id":"锁的类型","title":"锁的类型","index":"2.1.1"},{"id":"封锁粒度","title":"封锁粒度","index":"2.1.2"},{"id":"相容性矩阵","title":"相容性矩阵","index":"2.1.3"},{"id":"加锁解锁时机","title":"加锁解锁时机","index":"2.1.4"}]},{"id":"两阶段封锁协议2pl","title":"两阶段封锁协议2PL","index":"2.2","children":[{"id":"内容","title":"内容","index":"2.2.1"},{"id":"死锁","title":"死锁","index":"2.2.2"}]}]},{"id":"基于时间戳的并发控制","title":"基于时间戳的并发控制","index":"3","children":[{"id":"事务的时间戳","title":"事务的时间戳","index":"3.1"},{"id":"并发控制","title":"并发控制","index":"3.2","children":[{"id":"简单实现方法","title":"简单实现方法","index":"3.2.1"},{"id":"带提交位的实现方法","title":"带提交位的实现方法","index":"3.2.2"}]}]},{"id":"多版本并发控制mvcc","title":"多版本并发控制MVCC","index":"4","children":[{"id":"元组结构","title":"元组结构","index":"4.1"},{"id":"操作","title":"操作","index":"4.2","children":[{"id":"更新操作","title":"更新操作","index":"4.2.1"},{"id":"读操作","title":"读操作","index":"4.2.2"}]},{"id":"版本链version-chain","title":"版本链Version Chain","index":"4.3"},{"id":"历史版本数据存储","title":"历史版本数据存储","index":"4.4"}]}]}