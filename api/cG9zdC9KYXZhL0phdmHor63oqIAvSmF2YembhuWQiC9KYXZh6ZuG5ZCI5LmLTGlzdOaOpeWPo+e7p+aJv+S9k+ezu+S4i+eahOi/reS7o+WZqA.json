{"title":"Java集合之List接口继承体系下的迭代器","date":"2020-01-12T11:57:03.000Z","date_formatted":{"ll":"Jan 12, 2020","L":"01/12/2020","MM-DD":"01-12"},"thumbnail":"post/Java/Java语言/Java集合/Java集合之List接口继承体系下的迭代器/cover.jpg","link":"post/Java/Java语言/Java集合/Java集合之List接口继承体系下的迭代器","categories":["Java","Java语言","Java集合"],"updated":"2020-03-16T15:30:48.412Z","content":"<h1 id=\"abstractlist提供的迭代器\">AbstractList提供的迭代器<a href=\"#abstractlist提供的迭代器\" title=\"AbstractList提供的迭代器\"></a></h1><p><code>AbstractList</code>提供了两种迭代器的实现。</p>\n<ul><li><code>Itr</code>实现了<code>Iterator</code>接口</li>\n<li><code>ListItr</code>实现了<code>ListIterator</code>接口</li>\n</ul><h2 id=\"itr迭代器\">Itr迭代器<a href=\"#itr迭代器\" title=\"Itr迭代器\"></a></h2><p>该迭代器为标准的<code>Iterator</code>的实现类，实现了所有的方法。</p>\n<h3 id=\"concurrentmodification\">ConcurrentModification<a href=\"#concurrentmodification\" title=\"ConcurrentModification\"></a></h3><p>使用迭代器对集合进行遍历的时候不允许进行对集合有结构型改变的操作（使集合的长度发生变化），否则会使迭代器遍历行为异常。<code>AbstractList</code>中使用<code>modCount</code>来避免这种行为，<code>modCount</code>负责记录当前对集合的结构性修改的次数，在执行<code>add</code>、<code>remove</code>等方法时需要将<code>modCount++</code>。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BList%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/image-20200112190635768.png\" class=\"\">\n\n<ul><li>初始化迭代器时记录当前<code>modCount</code></li>\n</ul><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BList%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/image-20200112190706907.png\" class=\"\">\n\n<ul><li>若当前<code>modCount</code>不等于预期的<code>expectedModCount</code>，即发生了<code>ConcurrentModification</code>，则抛出异常</li>\n</ul><h3 id=\"hasnext\">hasNext<a href=\"#hasnext\" title=\"hasNext\"></a></h3><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BList%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/image-20200112190831371.png\" class=\"\">\n\n<h3 id=\"next\">next<a href=\"#next\" title=\"next\"></a></h3><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BList%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/image-20200112193151572.png\" class=\"\">\n\n<h3 id=\"remove\">remove<a href=\"#remove\" title=\"remove\"></a></h3><p>想要移除当前元素可以使用迭代器提供的<code>remove</code>方法进行合法操作。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BList%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/image-20200112191200162.png\" class=\"\">\n\n\n\n<h2 id=\"listitr迭代器\">ListItr迭代器<a href=\"#listitr迭代器\" title=\"ListItr迭代器\"></a></h2><p><code>ListItr</code>迭代器是专门为<code>List</code>实现了增强版的<code>Itr</code>迭代器，不仅支持前向遍历，还支持反向遍历，还支持替换元素和增加元素。操作逻辑和<code>Itr</code>相同：</p>\n<ul><li>通过<code>modCount</code>避免<code>ConcurrentModification</code></li>\n<li>使用<code>cursor</code>和<code>lastRet</code>来进行遍历</li>\n</ul><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BList%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/image-20200112191453924.png\" class=\"\">\n\n\n\n<h1 id=\"arraylist提供的迭代器\">ArrayList提供的迭代器<a href=\"#arraylist提供的迭代器\" title=\"ArrayList提供的迭代器\"></a></h1><p><code>ArrayList</code>提供了<code>Itr</code>和<code>ListItr</code>的优化实现。</p>\n<h3 id=\"next-1\">next<a href=\"#next-1\" title=\"next\"></a></h3><p>手动检查下标越界，不依赖<code>try catch</code>，其他方法也类似</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BList%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/image-20200112193550281.png\" class=\"\">\n\n\n\n\n\n<h1 id=\"linkedlist提供的迭代器\">LinkedList提供的迭代器<a href=\"#linkedlist提供的迭代器\" title=\"LinkedList提供的迭代器\"></a></h1><p>由于<code>AbstractList</code>中提供的<code>Itr</code>迭代器和<code>ListItr</code>在遍历时，维持下标<code>cursor</code>和<code>lastRet</code>，在获取元素时通过<code>get(cursor)</code>来获取元素，这对于<code>ArrayList</code>来说没有问题，因为它可随机访问，但是对于<code>LinkedList</code>来说，每一次<code>get(cursor)</code>都意味着必须将指针从首节点开始移动到目标节点，这意味着对于<code>LinkedList</code>若使用<code>AbstractList</code>提供的迭代器实现，遍历一次的时间复杂度为<code>O(n^2)</code>，多出了很多无意义的指针移动，因此必须进行重新实现。</p>\n<h3 id=\"itr\">Itr<a href=\"#itr\" title=\"Itr\"></a></h3><p><code>LinkedList</code>的父类<code>AbstractSequentialList</code>重写了<code>iterator</code>方法，直接调用了<code>listIterator</code>方法。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BList%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/image-20200112194541776.png\" class=\"\">\n\n\n\n<h3 id=\"listitr\">ListItr<a href=\"#listitr\" title=\"ListItr\"></a></h3><p>使用指针来维护当前节点和上一个返回节点的位置。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BList%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8/image-20200112194741337.png\" class=\"\">","prev":{"title":"6-MyBatis注解开发","link":"post/Java/MyBatis/6-MyBatis注解开发"},"next":{"title":"Java集合之List","link":"post/Java/Java语言/Java集合/Java集合之List"},"plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之List接口继承体系下的迭代器/","toc":[{"id":"abstractlist提供的迭代器","title":"AbstractList提供的迭代器","index":"1","children":[{"id":"itr迭代器","title":"Itr迭代器","index":"1.1","children":[{"id":"concurrentmodification","title":"ConcurrentModification","index":"1.1.1"},{"id":"hasnext","title":"hasNext","index":"1.1.2"},{"id":"next","title":"next","index":"1.1.3"},{"id":"remove","title":"remove","index":"1.1.4"}]},{"id":"listitr迭代器","title":"ListItr迭代器","index":"1.2"}]},{"id":"arraylist提供的迭代器","title":"ArrayList提供的迭代器","index":"2","children":[{"id":"next-1","title":"next","index":"2.1"}]}]}