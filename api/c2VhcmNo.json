[{"title":"MySQL主从复制","date":"2020-02-12T08:31:43.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-02-12T13:19:15.969Z","content":"MySQL主从复制原理工作线程Binary Log Dump线程\n主节点上的该线程用于将数据更改写到本机上的二进制日志bin-log中。\nI/O线程\n从节点上的该线程用于从主节点上读取二进制日志，并写入本机的中继日志relay log中。\nSQL线程\n从节点上的该线程用于读取中继日志，解析数据更改，并在从节点上进行重放。\n\n\n复制模式异步模式slave主动连接master，获取bin-log，不能保证数据的强一致性。该模式为默认的模式。\n同步模式主节点和从节点全部commit之后才会向客户端返回成功，可保证数据的强一致性。\n半同步模式主节点只要等到一个从节点的commit之后就会执行commit，否则会等到超时之后切换成异步模式再提交。该模式不是内置的，需要安装插件。\nMySQL主从复制配置主节点配置文件重启服务。\n1234567891011[mysqld]# idserver-id=1# 二进制日志文件log-bin=/var/lib/mysql/mysql-bin# 错误记录文件log-error=/var/lib/mysql/mysql-error# 主从复制时同步的数据库binlog-do-db=test# 主从复制时忽略的数据库# binlog-ignore-db=mysql\n\n授权从节点1GRANT REPLICATION SLAVE ON *.* TO 'root'@'192.168.31.202' IDENTIFIED BY 'Lq18851195070.';\n\n查看主节点状态记录下两个字段，配置从节点需要用。\nFile\nPosition\n1show master status;\n\n\n\n防火墙配置这里直接关闭防火墙。\n1systemctl stop firewalld.service\n\n\n\n从节点配置文件重启服务。\n123456789[mysqld]# idserver-id=2# 二进制日志文件log-bin=/var/lib/mysql/mysql-bin# 错误记录文件log-error=/var/lib/mysql/mysql-error# 主从复制时同步的数据库replicate-do-db=test\n\n授权主节点1234567CHANGE MASTER TOMASTER_HOST = '192.168.31.201',MASTER_USER = 'root',MASTER_PASSWORD = 'Lq18851195070.',MASTER_PORT = 3306,master_log_file = 'mysql-bin.000001',master_log_pos = 154;\n\n开启主从同步1start slave;\n\n查看同步状态主要看两个属性是否为yes\nSlave_IO_Running\nSlave_SQL_Running\n1show slave status \\G;\n\n\n\n处理错误观察到Last_IO_Error说主从节点有一样的UUID，查看/usr/lib/mysql.auto.cnf发现果然一样（由于是复制的虚拟机）。解决办法为停止从节点的mysqld服务，删除它的auto.cnf文件，再启动数据库服务即可。\n","thumbnail":"post/数据库/MySQL/MySQL主从复制/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/MySQL主从复制/"},{"title":"MySQL锁机制","date":"2020-02-12T08:31:24.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-02-12T13:19:11.091Z","content":"锁分类根据操作读锁\n即共享锁，锁定时其他会话可以进行读，但不能写。\n写锁\n即排他锁，锁定时其他会话不能进行读，也不能进行写。\n根据范围表锁\n锁定一张表。开销小，加锁快，不会出现死锁，锁定的粒度大，容易发生冲突，并发度低。\n行锁\n只锁定一行数据。开销大，加锁慢，会出现死锁，锁定的粒度小，不容易发生冲突，并发度高。\n页锁\nTODO\n表锁加锁后的行为若对表T进行加锁的会话是A。\n读锁\n\n读：表T写：表T读：其他表写：其他表\n\n会话A允许不允许不允许不允许\n\n其他会话允许不允许允许允许\n写锁\n\n读：表T写：表T读：其他表写：其他表\n\n会话A允许允许不允许不允许\n\n其他会话不允许不允许允许允许\n锁操作读锁加锁\n1lock table 表名 read;\n\n解锁\n1unlock tables;\n\n写锁加锁\n1lock table 表明 write;\n\n解锁\n1unlock tables;\n\n查看锁定状态查看哪些表加了锁\n1show open tables;\n\n\n\n查看锁定表数量\nTable_locks_immediate未被上锁的表的数量\nTable_locks_waited被上锁的表的数量\n1show status like 'table%';\n\n\n\n行锁加锁后的行为若对行T进行加锁的会话是A。\n读锁\n\n读：行T写：行T读：其他行写：其他行\n\n会话A允许允许允许允许\n\n其他会话允许不允许允许允许\n写锁\n\n读：行T写：行T读：其他行写：其他行\n\n会话A允许允许允许允许\n\n其他会话允许不允许允许允许\n锁操作加锁隐式加锁\n自动加锁。\n显示加锁\nfor update\n上排他锁。\n1select * from 表名 for update\n\nlock in share mode\n上共享锁。\n1select * from 表名 lock in share mode\n\n解锁提交事务或者回滚事务时解除锁定。\n不同存储引擎的锁模式MyISAM采用表锁。\n查询时自动给涉及的所有表加读锁。\n更新时自动给涉及的表加写锁。\n因为是一次性获取所需要的全部锁，所以不会产生死锁。\nInnoDB锁种类InnoDB使用行锁与表锁共存。\n行锁\n共享锁\n排他锁\n表锁\n意向共享锁事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。\n\n意向排他锁事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。\n\n锁模式兼容意向锁之间不冲突。\n表被意向共享锁锁定后不能加排他锁。\n表被意向排他锁锁定后不能加排他锁和共享锁。\n\n\n锁操作加锁隐式加锁\n意向锁由InnoDB自动加。\nUPDATE, DELETE, INSERT操作InnoDB自动加排他锁。\nSELECT语句InnoDB不会自动加任何锁。\n显示加锁\nfor update\n上排他锁。\n1select * from 表名 for update\n\nlock in share mode\n上共享锁。\n1select * from 表名 lock in share mode\n\n解锁锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。\n间隙锁当语句带有范围时，如update people set name = &#39;p&#39; where id &lt; 4, 此时若加行锁，则id为1,2,3的行都会加上行锁，若id为2的行不存在，也会加上行锁。\n死锁问题TODO\n","thumbnail":"post/数据库/MySQL/MySQL锁机制/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/MySQL锁机制/"},{"title":"5-SQL优化之索引优化","date":"2020-02-12T08:30:35.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-02-12T13:19:05.210Z","content":"建立索引的原则建立索引\n主键自动建立索引\n频繁作为查询条件的字段应该创建索引\n查询中与其他表关联的字段应该创建索引\n不建立索引\n频繁更新的字段不建立索引\nWhere条件用不到的字段不建立索引\n表记录太少不建立索引\n索引优化的一些原则复合索引最佳左前缀原则使用复合索引时不要跳列进行查询，否则会导致需要回表查询。\n建表\n123456create table people(\tid int primary key auto_increment,    name varchar(50) not null,    age int not null,    hobby varchar(50) not null)engine=innodb default charset=utf8;\n\n插入数据\n12345insert into people(name, age, hobby) values('p1', 18, 'soccer'),('p2', 19, 'tennis'),('p3', 20, 'swimming'),('p4', 21, 'bike');\n\n建立复合索引\n1create index ind on people(name, age, hobby);\n\n符合最佳左前缀原则进行查询\n1explain select id from people where name = 'p1' and age = 18 and hobby='soccer';\n\ntype为ref，rows为1，Extra为using index，索引全部用上，效果很好。\n\n\n1explain select id from people where hobby='soccer' and name = 'p1' and age = 18;\n\n打乱顺序也没有关系。\n\n\n不符合最佳左前缀原则进行查询\n1explain select id from people where age = 18 and hobby='soccer';\n\n缺了带头大哥name，出现了using where回表查询，rows为4。\n\n\n1explain select id from people where name = 'p1' and hobby='soccer';\n\n却了中间的跟班小弟age，出现了using where回表查询。\n\n\nOrder By优化order by和where保持一致保持一致可以避免using filesort。\n1explain select id from people where id = 1 order by name;\n\n此处where中使用的是id，然而排序使用的是name，带来了using filesort。\n\n\n1explain select id from people where id = 1 order by id;\n\n此处where中使用的是id，排序也使用的是id，无using filesort。\n\n\nusing filesort优化using filesort有两种算法，当max_length_for_sort_data太低时，MySQL会切换到双路排序，因此可以调大max_length_for_sort_data。\n双路排序：MySQL4.1之前默认使用\n单路排序：MySQL4.1之后默认使用\n多表查询优化小表驱动大表在查询中最好使用小表驱动大表，因为在外层表循环内层的时候，会锁定外层表，如果大表在外，会被锁定较多的次数。\n12# 小表驱动大表where 小表.x = 大表.y;\n\n外连接索引对于左外连接，给左表加索引。\n对于右外连接，给右表加索引。\n子查询优化exists与in对于\n1select ... from table where exists/in (子查询)\n\n主查询数据较多，使用in。\n子查询数据较多，使用exists。\n覆盖索引所谓覆盖索引就是要查询的字段全部都在索引之中，无需回表查询。\n1234# 回表select * from people where id = 1;# 不覆盖索引select id from people where id = 1;\n\n索引失效情况避免在索引上进行计算在索引上进行任何计算（计算，函数，类型转换）都会导致索引失效。\n先删除people表的复合索引。\n1drop index ind on people;\n\n1explain select id from people where id + 1 = 2;\n\n对主键索引id进行计算，索引失效。\n\n\n避免在索引上使用不等于1explain select id from people where id != 1;\n\n对主键索引id进行不等于操作，索引失效。\n\n\n避免在索引上使用判空12explain select id from people where id is null;explain select id from people where id is not null;\n\n\n\n避免在索引上使用范围查询和in12explain select id from people where id &gt; 2;explain select id from people where id in (1, 2);\n\n\n\n避免在索引上使用以%开头的模糊查询在name上建立索引。\n1create index ind on people(name);\n\n12explain select id from people where name like '%p%';drop index ind on people;\n\n\n\n避免在索引上使用or1explain select id from people where id = 1 or id = 2;\n\n","thumbnail":"post/数据库/MySQL/5-SQL优化之索引优化/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/5-SQL优化之索引优化/"},{"title":"4-SQL优化之排查方法","date":"2020-02-12T08:30:19.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-02-12T13:18:58.363Z","content":"慢查询日志MySQL提供了慢查询日志来记录响应时间超过阈值的SQL语句，默认是关闭的。\n查询是否打开\n1show variables like '%slow_query_log%';\n\n\n\n查询阈值\n默认为10秒。\n1show variables like '%long_query_time%';\n\n\n\n临时开启开启\n1set global slow_query_log = 1;\n\n\n\n设置阈值\n需要重新登录后生效。\n1set global long_query_time = 3;\n\n测试\n1select sleep(4);\n\n\n\n永久开启永久开启需要改写配置文件/etc/my.cnf，重启服务。\n1234[mysqld]slow_query_log = 1slow_query_log_file = /var/lib/mysql/localhost-slow.loglong_query_time = 3\n\n\n\nProfile使用MySQL的profile可以记录所有SQL语句的记录，并进行消耗时间的查看，默认是关闭的。\n查询是否打开\n1show variables like '%profiling%';\n\n\n\n打开\n1set profiling = 1;\n\n\n\n查看\nQuery_ID\nDuration\nQuery\n1show profiles;\n\n\n\n精确分析\n精确分析每一条语句耗时的详情。\n1show profile all for query 查询的ID（Query_ID）;\n\n\n\n全局查询日志记录开启之后的全部SQL语句，默认关闭。\n查看是否开启\n1show variables like '%general_log%';\n\n\n\n打开\n1set global general_log = 1;\n\n设置记录在表中\n查询记录会记录在mysql.general_log表中\n1set global log_output = 'table';\n\n\n\n设置记录在文件中\n12set global log_output = 'file';set global general_log_file = '/tmp/general.log';\n\n","thumbnail":"post/数据库/MySQL/4-SQL优化之排查方法/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/4-SQL优化之排查方法/"},{"title":"Flexbox布局","date":"2020-02-11T13:43:37.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-02-11T14:08:12.398Z","content":"结构\n\nContainer属性display指定布局为flexbox布局。\n123.container &#123;  display: flex;&#125;\n\nflex-direction指定item排布的顺序。\n123.container &#123;  flex-direction: row | row-reverse | column | column-reverse;&#125;\n\nrow\n从左到右。默认。\n\n\nrow-reverse\n从右到左。\n\n\ncolumn\n从上到下。\n\n\ncolumn-reverse\n从下到上。\n\n\nflex-wrap指定如何换行。\n123.container&#123;  flex-wrap: nowrap | wrap | wrap-reverse;&#125;\n\nnowrap\n不换行。默认\n\n\nwrap\n换行，新的一行在下面。\n\n\nwrap-reverse\n\n\n换行，新的一行在上面。\njustify-content123.container &#123;  justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly | start | end | left | right ... + safe | unsafe;&#125;\n\n指定行内item在水平方向上如何排布。\n\n\nspace-around\n弹性盒子元素会平均地分布在行里，两端保留子元素与子元素之间间距大小的一半。\nspace-evenly\n弹性盒子元素会平均地分布在行里，没两个子元素间的距离都一样。\nalign-items指定行内item在垂直方向上如何排布。\n123.container &#123;  align-items: stretch | flex-start | flex-end | center | baseline | first baseline | last baseline | start | end | self-start | self-end + ... safe | unsafe;&#125;\n\n\n\nalign-content指定不同行之间如何排布。\n123.container &#123;  align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch | start | end | baseline | first baseline | last baseline + ... safe | unsafe;&#125;\n\n\n\nItem属性order用于指定子元素排布在行内的顺序。数值小的排在前面，可以为负值。\n123.item &#123;  order: &lt;integer&gt;; /* default is 0 */&#125;\n\nflex-growTODO\nflex-shrinkTODO\nflex-basisTODO\nalign-self用于覆盖父容器指定的align-items。\n参考文档A Complete Guide to Flexbox\n\nFlexbox布局详解\n\n","plink":"https://beginc.github.io/post/Web/CSS/Flexbox布局/"},{"title":"3-SQL优化之Explain","date":"2020-02-11T06:59:12.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-02-11T13:24:32.032Z","content":"Explain使用方法explain SQL语句，如explain select * from account\n\n\n字段id该字段用于表示多张表被处理的顺序。\nid相同\n处理顺序由上至下。数据库小的表会优先处理，因为优先处理小表产生的中间表较小，占用内存少。\n\n\n\n\nid不同\nid越大越先被处理。\n\n\nselect_type表示查询的种类。\nSIMPLE\n简单查询，无子查询，无Union。\n\n\nPRIMARY\n带子查询的主查询。\n\n\nDERIVED\n衍生查询，在查询的时候用到了临时表。\n在from子查询中只有一张表。\n在from子查询中只有一张表，如果有table1 union table2，则table1就是DERIVED。\n此查询本应该是DERIVED，但在MySQL5.7中对SQL进行了改写，消除了子查询。\n\n\n可用show warnings查看。\n\n\n\n\nUNION\n\n\nUNION RESULT\n\n\ntable表名。\npartitionsTODO\ntype索引类型。性能排序为:\n1system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all\n\nsystem\n只有一条数据的系统表的查询。\n\n衍生表只有一条记录的主查询。\n\n这里本来应该是system，但是由于MySQL5.7消除了子查询，所以为const。\n\n\nconst\n仅仅能查到一条数据的查询。用于Primary Key或者Unique索引。\n\n\n注意需要是在主键索引或唯一索引上的查询。\n\n\neq_ref\n唯一性索引。对于每个索引键，查询返回匹配的唯一数据（匹配到必须只有一条，匹配到的也不能为0条），常见于唯一索引和主键索引。\n在aid字段上建立唯一索引。\n\n\n此时，对于people中每个aid都在account中有唯一匹配，所以是eq_ref。\n\n\n\n\n\n\n但是，如果people中如果多了一条数据，在account中没有匹配，则不是eq_ref。先在aid字段上换成普通索引。然后插入一条aid为3的数据，最后进行查询。\n\n\nref\n非唯一性索引，对于每个索引键，查询返回匹配的所有数据（匹配到可以只有一条，匹配到的可以为0条，也可以为多条）\n\n\nrange\n范围查询。\n\n\n当in后包含所有的索引键，则失效。\n\n\nindex\n查询全部索引中的数据，不需要查表。\n\n\nall\n查询全部表中的数据。\n\n\npossible_keys可能用到的索引，不准确。\n\n\nkey实际用到的索引。\n\n\nkey_len索引的长度。用于判断复合索引是否被完全使用。\n给people表添加复合索引。\n\n\n计算方式\n考虑编码UTF-8:：1个字符3个字节\nGBK：1个字符2个字节\nLatin：1个字符1个字节\n\n考虑是否可以为NULL可以为NULL则添加1个字节用于标识\n\n考虑是否长度可变若长度可变则添加2个字节标识\n\n按uname进行查询。varchar(50) + UTF-8 + 非空，则为3 * 50 + 2 = 152\n\n\n按uname和aid进行查询。aid为int，占用4个字节。\n\n\n未按最左前缀原则进行书写，只用到了aid索引。\n\n\nref指明当前表所参照的字段。\n\n\n参照常量。\n\n\nrows MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数，越低越好。\n根据主键id对account进行查询，有索引，只需扫描一条记录。\n\n\n根据balance对account进行查询，无索引，需扫描全部两条记录。\n\n\nfilteredTODO\nExtrausing filesort\n需要额外的一次排序，性能消耗较大。\n对于单索引，如果排序和查找用的是同一个字段，则无需额外的一次排序。\n对于复合索引，若查找和排序符合最佳左前缀原则，则无需额外的一次排序。\nwhere和order by不用同一个字段\n\n\nwhere和order by用同一个字段\n\n\n创建(id, uname, aid)上的复合索引\n\n\n按最佳左前缀原则查询\n1explain select id from people where id = 1 order by uname;\n\n不按最佳左前缀原则查询\n1explain select id from people where id = 1 order by aid;\n\nusing index\n覆盖索引，不用读取数据文件，只从索引文件中获取数据。\n\n\nusing where\n需要回表查询。\n","thumbnail":"post/数据库/MySQL/3-SQL优化之Explain/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/3-SQL优化之Explain/"},{"title":"2-SQL优化之索引原理","date":"2020-02-11T06:58:57.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-02-12T08:30:55.983Z","content":"索引分类单列索引单列索引即在单个字段上建立索引。\n普通索引允许有重复值\n允许有NULL\n主键索引不允许有重复值\n不允许有NULL\n唯一索引不允许有重复值\n允许有NULL\n复合索引在表中的多个字段组合上创建的索引。\n全文索引MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引。\nMySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引。\n只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。\n空间索引MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。必须使用 GIS 相关的函数来维护数据。\n索引结构B+TreeM阶B-Tree特点\n若根节点不是终端节点，则至少有两颗子树（即至少一个关键字）。\n每个结点至多有M棵子树（即至多M - 1个关键字）。\n除根节点外的所有非叶节点至少有ceil(M / 2)棵子树（即至少包含ceil(M / 2) - 1个关键字）。\n所有非叶节点的结构类似如下:\n123 |P1|K1|P2|K2|P3|  &#x2F;     |      \\Child  Child  Child\n\n所有叶子节点出现在同一层次，不带任何信息，表示查找失败。\n\n\n\n\nM阶B+Tree特点\n与B-Tree不同的点有：\n结点中每个关键字 对应一颗子树。\n\n每个结点至多有M棵子树（即至多M个关键字）。\n\n除根节点外的所有非叶节点至少有ceil(M / 2) 棵子树（即至少包含ceil(M / 2)个关键字）。\n\n所有非叶节点不包含信息，只包含对应子树的最大关键字和指向该子树的指针，仅仅起索引作用。\n\n叶节点包含了全部关键字，叶子节点的指针指向记录存储的地址。\n\n所有叶子节点连接成一个单链表，有一个指针指向关键字最小的叶子节点。\n\n\n\n\n\nB+Tree的优点\n查找效率高。\n相对于B-Tree，B+Tree具有有序性，适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找（联合索引）。\n复合索引下B+Tree的结构\nTODO\nHashHash索引优点\n查找效率高，O(1)。\nHash索引缺点\n无法用于排序和分组。\n无法用于区间查找。\nMySQL索引索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。\nMyISAM非聚簇索引非聚簇索引指指索引项的排序方式和表中数据记录排序方式不一致的索引。\n一张表分三个文件存储。数据和索引分开存储。\n\n文件内容\n\n表名.frm存储表结构\n\n表名.MYD存储行数据\n\n表名.MYI存储索引\n索引结构MyISAM使用B+Tree作为索引结构，在叶子结点上存储指向记录的指针。\n\n\n\n\nInnoDB聚簇索引非聚簇索引指指索引项的排序方式和表中数据记录排序方式一致的索引。\n一张表分两个文件存储。数据和索引存储在一个文件中。\n\n文件内容\n\n表名.frm存储表结构\n\n表名.idb存储行数据和索引\n如果一个主键被定义了，那么这个主键就是作为聚集索引。\n如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引。\n如果没有主键也没有合适的唯一索引，那么InnoDB内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，该列的值会随着数据的插入自增。\n索引结构InnoDB使用B+Tree作为索引结构，在叶子结点上直接存储了行数据。\n\n\n\n\nMySQL索引操作建立索引普通索引\n123CREATE INDEX 索引名称 ON 表名(列名);或者ALTER TABLE 表名 ADD INDEX 索引名称(列名);\n\n唯一索引\n123CREATE UNIQUE INDEX 索引名称 ON 表名(列名);或者ALTER TABLE 表名 ADD UNIQUE INDEX 索引名称(列名);\n\n主键索引\n1ALTER TABLE 表名 ADD PRIMARY KEY (列名)\n\n删除索引删除普通/唯一索引\n123DROP INDEX 索引名称 ON 表名;或ALTER TABLE 表名 DROP INDEX 索引名称;\n\n删除主键\n1ALTER TABLE 表名 DROP PRIMARY KEY;\n\n查看索引1SHOW INDEX FROM 表名;\n\n\n\n","thumbnail":"post/数据库/MySQL/2-SQL优化之索引原理/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/2-SQL优化之索引原理/"},{"title":"1-SQL优化之SQL解析顺序","date":"2020-02-11T06:58:35.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-02-11T07:41:24.189Z","content":"手写SQL顺序1234567select &lt;&gt;from &lt;&gt;on &lt;&gt;where &lt;&gt;group by &lt;&gt;having &lt;&gt;order by &lt;&gt;\n\nSQL解析顺序","thumbnail":"post/数据库/MySQL/1-SQL优化之SQL解析顺序/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/1-SQL优化之SQL解析顺序/"},{"title":"MySQL存储引擎","date":"2020-02-11T06:57:49.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-02-11T07:36:34.014Z","content":"存储引擎简介MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。\nMySQL支持的所有引擎\n\n\n\nInnoDB\n功能支持\n\n外键完整性约束支持\n\n事务支持\n\n锁行锁\n\n缓存缓存索引和表数据\n支持高并发。\nMyISAM\n功能支持\n\n外键完整性约束不支持\n\n事务不支持\n\n锁表锁\n\n缓存缓存索引\n","thumbnail":"post/数据库/MySQL/MySQL存储引擎/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/MySQL存储引擎/"},{"title":"MySQL常用命令","date":"2020-02-11T06:57:39.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-02-11T07:21:11.233Z","content":"show databases查询所有数据库\nuse dbName使用数据库\nshow engines查询所有存储引擎\n","thumbnail":"post/数据库/MySQL/MySQL常用命令/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/MySQL常用命令/"},{"title":"Linux下MySQL核心目录","date":"2020-02-11T06:57:09.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-02-12T12:56:03.615Z","content":"数据库目录\n/var/lib/mysql/\n配置文件\n/etc/my.cnf\n日志文件\n/var/log/mysqld.log\n","thumbnail":"post/数据库/MySQL/Linux下MySQL核心目录/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/Linux下MySQL核心目录/"},{"title":"CentOS7下MySQL5.7安装","date":"2020-02-11T06:55:21.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-02-11T07:14:44.209Z","content":"下载安装文件下载链接\n下载链接\n\n\n\n\n核心组件\ncommon\nlibs\nclient\nserver\n\n\n\n\n解决包冲突12rpm -e postfixrpm -e mariadb-libs\n\n安装安装顺序\ncommon\nlibs\nclient\nserver\n1234567rpm -ivh /opt/mysql-community-common-5.7.29-1.el7.x86_64.rpm  rpm -ivh /opt/mysql-community-libs-5.7.29-1.el7.x86_64.rpmrpm -ivh /opt/mysql-community-client-5.7.29-1.el7.x86_64.rpmrpm -ivh /opt/mysql-community-server-5.7.29-1.el7.x86_64.rpm\n\n更改Root密码查看初始临时密码\n1cat &#x2F;var&#x2F;log&#x2F;mysqld.log  | grep &quot;temporary password&quot;\n\n\n\n/var/log/mysqld.log无内容解决方法\n删除原来安装过的mysql残留的数据\n1rm -rf /var/lib/mysql\n\n\n\n重启mysqld服务\n1systemctl restart mysqld.service\n\n更改Root密码\n1set password=password(\"密码\")\n\n开启MySQL远程连接注意防火墙端口是否开放。\n123mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'USERNAME'@'%' IDENTIFIED BY 'PASSWORD' WITH GRANT OPTION;mysql&gt; FLUSH PRIVILEGES;\n\n","thumbnail":"post/数据库/MySQL/CentOS7下MySQL5-7安装/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/CentOS7下MySQL5-7安装/"},{"title":"Vagrant自动虚拟机部署","date":"2020-02-08T09:25:26.000Z","date_formatted":{"ll":"Feb 8, 2020","L":"02/08/2020","MM-DD":"02-08"},"updated":"2020-02-08T09:32:09.938Z","content":"Vagrantfile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- mode: ruby -*-# vi: set ft=ruby :# 三台虚拟机boxes = [  &#123;    # 主机名    :hostname =&gt; \"master\",    # IP地址    :ip =&gt; \"192.168.31.201\",    # 分配的内存    :mem =&gt; \"2048\",    # CPU核心    :cpu =&gt; \"1\"  &#125;,  &#123;    :hostname =&gt; \"node1\",    :ip =&gt; \"192.168.31.103\",    :mem =&gt; \"2048\",    :cpu =&gt; \"1\"  &#125;,  &#123;    :hostname =&gt; \"node2\",    :ip =&gt; \"192.168.31.104\",    :mem =&gt; \"2048\",    :cpu =&gt; \"1\"  &#125;]Vagrant.configure(\"2\") do |config|  # 使用centos/7 Box  config.vm.box = \"centos/7\"  # Box版本  config.vm.box_version = \"1905.1\"  boxes.each do |opts|    config.vm.define opts[:hostname] do |config|      config.vm.hostname = opts[:hostname]      config.vm.provider \"virtualbox\" do |v|        v.customize [\"modifyvm\", :id, \"--memory\", opts[:mem]]        v.customize [\"modifyvm\", :id, \"--cpus\", opts[:cpu]]      end      # 设置共有网络，静态IP      config.vm.network \"public_network\", ip: opts[:ip]    end  end  # 安装wget工具  config.vm.provision \"shell\", privileged: true, inline: \"yum install wget -y\"end\n\n虚拟机管理\n命令作用\n\nvagrant up部署启动虚拟机\n\nvagrant suspend挂起虚拟机\n\nvagrant halt关机\n\nvagrant destroy撤销虚拟机一切资源\n存在的问题 TODO目前只能用vagrant ssh进行登录，不能通过正常的SSH进行登录，这样就无法使用Ansible进行自动化运维。\n","thumbnail":"post/自动化运维/Vagrant自动虚拟机部署/cover.png","plink":"https://beginc.github.io/post/自动化运维/Vagrant自动虚拟机部署/"},{"title":"7-Ansible执行速度优化","date":"2020-02-07T13:24:27.000Z","date_formatted":{"ll":"Feb 7, 2020","L":"02/07/2020","MM-DD":"02-07"},"updated":"2020-02-08T02:54:03.698Z","content":"优化一：开启SSH长连接Ansible使用SSH和远程主机进行通信, 所以Ansible对SSH的依赖性非常强, 在OpenSSH 5.6版本以后SSH就支持了Multiplexing。所以如果Ansible中被控端的SSH 版本高于5.6时, 我们可以直接在ansible.cfg文件中设置SSH长连接。\n123[ssh_connection]# ControlPersist=5d意思为SSH长连接持续5天ssh_args = -C -o ControlMaster=auto -o ControlPersist=5d\n\n优化二：开启PipeliningPipelining也是OpenSSH的一个特性, 在Ansible的整个执行流程中, 把生成好的本地Python脚本PUT到远程服务器. 如果开启了Pipelining, 这个过程将在SSH会话中进行, 这样可以大大提高整个执行效率.当然开启Pipelining, 需要被控机/etc/sudoers文件编辑当前Ansible的SSH用户的配置为requiretty. 否则在执行Ansible的时候会提示报错.\n优化三：开启accelerate模式已经废弃了。\n","thumbnail":"post/自动化运维/Ansible/8-Ansible执行速度优化/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/8-Ansible执行速度优化/"},{"title":"6-Ansible常用Playbook关键字","date":"2020-02-07T12:59:22.000Z","date_formatted":{"ll":"Feb 7, 2020","L":"02/07/2020","MM-DD":"02-07"},"updated":"2020-02-08T02:58:38.816Z","content":"用于Playhosts指定主机列表。\n123---# 指定主机列表为mq组内所有主机- hosts: mq\n\nremote_user指定远程执行命令的用户。\n12345---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root\n\ngather_facts指定是否收集主机信息。\n12345678---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  vars_files:    - vars.yml  gather_facts: no\n\npre_tasks在tasks之前执行的task。\n12345678---- hosts: all  gather_facts: no  pre_tasks:    - debug: msg=pre  tasks:    - debug: msg=task\n\npost_tasks在tasks之后执行的task。\n12345678910---- hosts: all  gather_facts: no  pre_tasks:    - debug: msg=pre  tasks:    - debug: msg=task  post_tasks:    - debug: msg=post\n\n用于Taskchanged_when用于设置何时任务“发生了改变”，需要重新执行。\n1234567891011---- hosts: all  gather_facts: no    tasks:    - debug: msg=task    - name: check if $ROCKET_HOME exists      shell: cat /etc/bashrc      register: bashrc      # 指定该任务总是需要执行      changed_when: True\n\ncheck_mode设置了该模式的命令只会预测在主机上执行结果，而不会真正的执行。\n1234567---- hosts: all  gather_facts: no    tasks:    - shell: echo hello      check_mode: yes\n\nenvironment可用来设置环境变量。\n1234567- hosts: all  gather_facts: no    tasks:    - shell: echo $var &gt; ~/test.txt      environment:        var: 123\n\nignore_errors指定是否忽略命令出错，继续向下执行。\n123- name: this will not be counted as a failure  command: /bin/false  ignore_errors: yes\n\nfailed_when指定命令什么情况下算执行失败。\n1234- name: Fail task when the command error output prints FAILED  command: /usr/bin/example-command -x -y -z  register: command_result  failed_when: \"'FAILED' in command_result.stderr\"\n\nregister将命令执行的返回值注册成一个变量。可在后续使用。\n123456789---- name: check if $ROCKET_HOME exists  shell: cat /etc/bashrc  register: bashrc  changed_when: True- name: append $ROCKET_HOME  shell: echo ROCKET_HOME=/usr/local/&#123;&#123; unarchive_filename &#125;&#125; &gt;&gt; /etc/bashrc; echo PATH='$PATH:$ROCKET_HOME'/bin &gt;&gt; /etc/bashrc  when: not bashrc.stdout is search(\"ROCKET_HOME\")\n\nloop用于执行循环。和with_*不同，该循环不依赖插件。\n12345678- name: add several users  user:    name: \"&#123;&#123; item &#125;&#125;\"    state: present    groups: \"wheel\"  loop:     - testuser1     - testuser2\n\nwith_items用于执行循环。\n1234- name: with_items  debug:    msg: \"&#123;&#123; item &#125;&#125;\"  with_items: \"&#123;&#123; items &#125;&#125;\"\n\nwith_indexed_items带索引的循环。item.0为索引，item.1为值。\n1234- name: with_indexed_items  debug:    msg: \"&#123;&#123; item.0 &#125;&#125; - &#123;&#123; item.1 &#125;&#125;\"  with_indexed_items: \"&#123;&#123; items &#125;&#125;\"","thumbnail":"post/自动化运维/Ansible/7-Ansible常用Playbook关键字/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/7-Ansible常用Playbook关键字/"},{"title":"5-Ansible之Jinja2语法","date":"2020-02-07T12:34:09.000Z","date_formatted":{"ll":"Feb 7, 2020","L":"02/07/2020","MM-DD":"02-07"},"updated":"2020-02-08T02:53:58.099Z","content":"变量12345# 直接使用&#123;&#123; var &#125;&#125;# 做运算&#123;&#123; var * 2 &#125;&#125;\n\n控制结构判断12345&#123;%if var == 10 %&#125;    等于10&#123;% else %&#125;    不等于10&#123;% endif %&#125;\n\n去除前导空字符\n使用-去除前导空字符\n12345&#123;%- if var == 10 -%&#125;    等于10&#123;%- else -%&#125;    不等于10&#123;%- endif -%&#125;\n\n循环123&#123;% for i in range(var) %&#125;    &#123;&#123; i &#125;&#125;&#123;% endfor %&#125;\n\n过滤器使用过滤器可对变量或常量做一些处理。使用管道符|进行传递。\n123456# Abc&#123;&#123; \"abc\" | capitalize   &#125;&#125;# 1&#123;&#123; [1, 2, 3] | first &#125;&#125;# 12&#123;&#123; \"12\" | int &#125;&#125;\n\nAnsible中所有的过滤器见Filter。\n测试过滤器会对变量做一些处理后返回，而测试主要是进行一些判断，返回布尔值。\n1234# True&#123;&#123; 1 is eq 1 &#125;&#125;# False&#123;&#123; var is defined &#125;&#125;\n\nAnsible中所有的测试见Test。\nAnsible之When在when中我们可以使用Jinja2语法进行模板书写，但是要注意的是，我们引用变量不用写{{}}。通常我们可以搭配register注册变量进行使用。register将命令的返回值存储到注册的变量当中。\n123456789---- name: check if $ROCKET_HOME exists  shell: cat /etc/bashrc  register: bashrc  changed_when: True- name: append $ROCKET_HOME  shell: echo ROCKET_HOME=/usr/local/&#123;&#123; unarchive_filename &#125;&#125; &gt;&gt; /etc/bashrc; echo PATH='$PATH:$ROCKET_HOME'/bin &gt;&gt; /etc/bashrc  when: not bashrc.stdout is search(\"ROCKET_HOME\")\n\n","thumbnail":"post/自动化运维/Ansible/6-Ansible之Jinja2语法/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/6-Ansible之Jinja2语法/"},{"title":"4-Ansible之导入","date":"2020-02-07T11:57:43.000Z","date_formatted":{"ll":"Feb 7, 2020","L":"02/07/2020","MM-DD":"02-07"},"updated":"2020-02-08T02:53:55.231Z","content":"Ansible复用在ansible中，task, var, handler到playbook和role都是可以进行复用的，因此我们需要类似于Java中import的机制来对复用组件进行导入。\n动态导入与静态导入在Ansible中include_*为动态导入，import_*为静态导入。\n区别\n静态导入相当于C语言中的预处理，它在解析Playbook时进行处理，而不是在运行时。\n动态导入在运行时进行处理时才进行导入。\n在使用when对include_*和import_*处理时，行为有些许不同。\n12345# common_tasks.yml- name: placeholder foo  command: /bin/foo- name: placeholder bar  command: /bin/bar\n\nimport_tasks静态导入。\n123456789# main.yml- import_tasks: other_tasks.yml  when: x is not defined # other_tasks.yml- set_fact:    x: foo- debug:    var: x\n\n在预处理后相当于给other_tasks.yml中的每一个task都加上了when语句，造成只有一个任务执行了，不符合我们的预期。\n12345678# 该任务会执行，因为初始情况下x未定义- set_fact:    x: foo  when: x is not defined# 该任务不会执行，因为执行了上面的任务后，x已经定义了- debug:    var: x  when: x is not defined\n\ninclude_tasks动态导入\n该处的when只控制导入的这个行为是否发生，因此第一个任务和第二个任务都会得到执行。\n123456789# main.yml- include_tasks: other_tasks.yml  when: x is not defined # other_tasks.yml- set_fact:    x: foo- debug:    var: x\n\n各种导入include_*include_tasks动态导入任务。\n12345678- hosts: all  tasks:\t# 和普通命令一样使用    - name: Include task list in play      include_tasks: stuff.yaml    # 可使用vars传入变量      vars:      \tname: lhw\n\ninclude_role动态导入角色。\n1234567891011---- hosts: all  tasks:    # 和普通命令一样使用    - include_role: name=role_A    # 可使用vars传入变量      vars:        name: maurice        age: 100    - import_role:        name: role_B\n\nimport_*import_tasks用法同include_tasks\nimport_role用法同include_role\nimport_playbook用于在一个Playbook中导入另一个Playbook的Play，且只能在顶层Playbook中导入，不能在tasks中导入\n12345678910111213141516- hosts: localhost  tasks:    - debug:        msg: play1# 导入Playbook- name: Include a play after another play  import_playbook: otherplays.yaml# 错误导入方法，不能在tasks中导入- name: This DOES NOT WORK  hosts: all  tasks:    - debug:        msg: task1    - name: This fails because I'm inside a play already      import_playbook: stuff.yaml\n\n\n\n","thumbnail":"post/自动化运维/Ansible/5-Ansible之导入/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/5-Ansible之导入/"},{"title":"3-Ansible之Roles","date":"2020-02-06T14:06:26.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:53:52.261Z","content":"Roles简介Roles可以层次性、结构化地组织Playbook，对重复的部分进行复用，实现更为复杂的任务。\nRoles目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051site.ymlwebserver.ymldbserver.ymlgroup_vars/\tall/\tgroup1/\tgroup2/host_vars/\t192.168.31.101/\t192.168.31.102/roles/    dbserver/        # 存放各种任务        tasks/        \tmain.yml        # 存放各种handler        handlers/        \tmain.yml        # 存放文件        files/        # 存放模板文件        templates/        # 存放变量定义文件        vars/        \tmain.yml        # 存放默认变量        defaults/        \tmain.yml        # 存放角色依赖关系        meta/        \tmain.yml    webserver/        # 存放各种任务        tasks/        \tmain.yml        # 存放各种handler        handlers/        \tmain.yml        # 存放文件        files/        # 存放模板文件        templates/        # 存放变量定义文件        vars/        \tmain.yml        # 存放默认变量        defaults/        \tmain.yml        # 存放角色依赖关系        meta/        \tmain.yml\n\nTasks该目录可以存放各种任务文件，还必须包含一个main.yml来组织起目录下各个任务的执行。\n使用include_tasks来导入。\ntasks/task1.yml\n123---- name: task1  shell: echo hello\n\ntasks/task2.yml\n123---- name: task1  shell: echo hello\n\ntasks/main.yml\n12- include_tasks: task1.yml- include_tasks: task2.yml\n\n\n\nHandlers该目录可以存放各种包含handler的文件，还必须包含一个main.yml。\n使用include来导入\nhandlers/handler1.yml\n123---- name: handler1  shell: echo handler1\n\nhandlers/handler2.yml\n123---- name: handler2  shell: echo handler2\n\nhandlers/main.yml\n123---- include: handler1.yml- include: handler2.yml\n\nfiles该目录用于存放文件，放在该文件夹里的文件可以使用文件名直接引用。\ntemplates该目录用于存放模板文件，放在该文件夹里的模板文件可以使用文件名直接引用。\nvars该目录用于存放变量定义文件，在此处定义过的变量可以直接引用。\n方式一：所有变量定义都放在vars/main.yml中123---name: lhwage: 18\n\n方式二：变量定义在vars/main目录下的YAML文件中该方式可以将变量分成多个文件进行定义。\nvars/main/var1.yml\n1name: lhw\n\nvars/main/var2.yml\n1age: 18\n\ndefaults该目录用于存放默认变量定义文件，在此处定义过的默认变量可以直接引用。默认变量不同的地方是，它的优先级最低，任何其他地方定义的变量优先级都高于它。\n方式一：所有变量定义都放在defaults/main.yml中同vars\n方式二：变量定义在vars/main目录下的YAML文件中同vars\nmeta用于存放角色间的依赖关系，例如rocketmq-broker角色要想执行其任务，必须先有Java的环境，因此该角色依赖于Java角色。\n在dependencies中定义，可为依赖的角色传入参数。\n123---dependencies:  - &#123; role: java arg1: \"123\", arg2: \"456\"&#125;\n\ngroup_vars该方式用于定义组变量，效果和在/etc/ansible/hosts中定义组变量效果相同，但是其优先级高于/etc/ansible/hosts中的组变量。\n方式一：组变量定义在group_vars/组名.yml中group_vars/broker.yml\n该文件里定义的变量只能由broker组使用。\n12---brokerName: broker\n\ngroup_vars/namesrv.yml\n该文件里定义的变量只能由namesrv组使用。\n12---port: 9876\n\ngroup_vars/all.yml\n该文件里定义的变量可由所有组使用。\n12---msg: global\n\n\n\n方式二：组变量定义在group_vars/组名/目录下的YAML文件中这种方式允许我们将一个组的变量定义在不同的文件中。\nhost_vars该方式用于定义主机变量，效果和在/etc/ansible/hosts中定义主机变量效果相同，但是其优先级高于/etc/ansible/hosts中的主机变量。\n方式一：主机变量定义在host_vars/主机名.yml中同group_vars。\n方式二：主机变量定义在host_vars/主机名/目录下的YAML文件中同group_vars。\n使用Roles在与roles目录同级的地方定义Playbook，使用定义好的角色。\ndbserver.yml\n12345678---- hosts: dbserver  remote_user: root  gather_facts: no  roles:  \t# 直接使用    - dbserver\n\nwebserver.yml\n123456789101112---- hosts: webserver  remote_user: root  gather_facts: no  roles:  \t# 使用多个角色  \t# 传参给角色    - role: dbserver      port: 3306    - role: webserver      port: 8080\n\n","thumbnail":"post/自动化运维/Ansible/4-Ansible之Roles/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/4-Ansible之Roles/"},{"title":"3-Ansible之Playbook","date":"2020-02-06T10:30:24.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:53:49.407Z","content":"Playbook简介Playbook通过YAML配置的方式，组织多个命令的执行，完成一系列复杂的任务。\nPlaybook核心元素常用通用信息hosts指定主机列表。\n123---# 指定主机列表为mq组内所有主机- hosts: mq\n\nremote_user指定远程执行命令的用户。\n12345---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root\n\ngather_facts指定是否收集主机信息。\n12345678---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  vars_files:    - vars.yml  gather_facts: no\n\n\n\n任务指定一系列任务。\n123456789101112131415161718192021---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  task:      # name指定任务名称    - name: Create a file      # 模块名：参数      file: path=~/hello.txt state=touch      # 指定sudo用户      sudo_user: test      # 使用sudo执行      sudo: yes      # 若执行错误，是否忽略，继续往下执行      ignore_errors: True      # 指定标签      tags:        - tag1        - tag2\n\n变量Playbook变量来源命令行中定义变量使用-e定义变量。此种方式定义的变量优先级最高。\n1ansible-playbook -e 'filename=hello.txt' playbook.yml\n\nhosts文件中定义变量组变量\n123456[mq]192.168.31.101192.168.31.102[mq:vars]filename=hello.txt\n\n主机变量\n优先级高于组变量。\n123456[mq]192.168.31.101 filename=another.txt192.168.31.102[mq:vars]filename=hello.txt\n\n独立的变量YAML文件中定义变量标准的变量定义文件应该放在vars目录下，则可以直接引用。\nvars/vars.yml\n1filename: hello.txt\n\nplaybook.yml\n12345678910111213---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  vars_files:    - vars.yaml  task:      # name指定任务名称    - name: Create a file      # 模块名：参数      file: path=~/&#123;&#123; filename &#125;&#125; state=touch\n\nPlaybook中定义变量使用vars定义变量。\n12345678910111213---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  vars:    filename: hello.txt  task:      # name指定任务名称    - name: Create a file      # 模块名：参数      file: path=~/&#123;&#123; filename &#125;&#125; state=touch\n\n调用setup模块的变量setup模块用于收集远程机器信息，可直接使用其变量，这种变量称为facts。\n1234567891011---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  task:      # name指定任务名称    - name: Create a file      # 模块名：参数      file: path=~/&#123;&#123; ansible_fqdn &#125;&#125; state=touch\n\n处理器有些时候我们希望一些命令执行后才通知其他一些命令执行，如配置文件发生改变，重新进行了分发时，我们希望重启服务。此时我们需要使用handlers和notify\n1234567891011121314151617# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  vars:    filename: hello.txt  task:      # name指定任务名称    - name: Create a file      # 模块名：参数      file: path=~/&#123;&#123; filename &#125;&#125; state=touch      notify:        - Create another file  handlers:    - name: create another file      file: path=~/another_&#123;&#123; filename &#125;&#125; state=touch\n\n模板有时候我们希望根据主机的一些信息动态进行配置文件编写，此时我们需要使用模板技术，Ansible使用Jinja2语言提供模板技术。\n模板文件template命令来分发配置文件src模板文件路径\ndest目标路径\nbackup是否备份\ngroup\nowner\nmode\n\n模板文件应以.j2结尾\nplaybook.yml\n123456789101112131415---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  vars:    items:      - C      - Java      - Python  task:      # name指定任务名称    - name: Distribute conf file      template: src=conf.j2 dest=~/conf\n\n模板文件templates/conf.j2\n模板文件放在标准目录templates下，可直接引用。\nfor进行循环\nif进行判断\n1234567# 若定义了该变量则执行&#123;% if items is defined %&#125;  # 循环写入  &#123;% for item in items %&#125;    &#123;&#123; item &#125;&#125;  &#123;% endfor%&#125;&#123;% endif %&#125;\n\nwhen条件测试，当为真时才执行命令。\n在任务中指定when, when支持Jinja2语法\n123456789101112---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  task:      # name指定任务名称    - name: Create a file      file: path=~/hello.txt state=touch      # 当主机ip为192.168.31.101时，才创建文件      when: ansible_all_ipv4_addresses == \"192.168.31.101\"\n\nansible-playbook命令使用直接运行一个Playbook\n1ansible-playbook playbook.yml\n\n检查运行一个Playbook\n只检测可能会发生的改变，但不真正执行操作。\n1ansible-playbook -C playbook.yml\n\n指定其他参数\n--list-hosts列出运行任务的主机\n--list-tags列出playbook文件中定义所有的tags\n--list-tasks列出playbook文件中定义的所有task\n--limit只针对主机列表中的某个主机或者某个组执行\n-f指定并发数，默认为5个\n-t指定tags运行，运行某一个或者多个tags的任务\n-v显示过程-vv, -vvv更详细\nPlaybook示例运行RocketMQ NameServer集群\n1234567891011121314151617181920212223242526272829---- hosts: mq  remote_user: root  vars:    archive_filename: rocketmq-all-4.6.0-bin-release.zip    unarchive_filename: rocketmq-all-4.6.0-bin-release    tasks:    - name: copy      copy: src=&#123;&#123; archive_filename &#125;&#125; dest=/opt    - name: unzip      unarchive:        src: /opt/&#123;&#123; archive_filename &#125;&#125;        dest: /usr/local        creates: /usr/local/&#123;&#123; unarchive_filename &#125;&#125;        remote_src: yes    - name: rename      shell:        cmd: mv /usr/local/&#123;&#123; unarchive_filename &#125;&#125; /usr/local/rocketmq        creates: /usr/local/rocketmq    - name: check env      shell: ls /etc/bashrc      register: bashrc      changed_when: True    - name: set env      shell: echo PATH='$PATH':/usr/local/rocketmq/bin &gt;&gt; /etc/bashrc      when: not bashrc.stdout is search('PATH=$PATH:/usr/local/rocketmq/bin')    - name: start name server      shell: nohup mqnamesrv &gt; /dev/null 2&gt;&amp;1 &amp;\n\n","thumbnail":"post/自动化运维/Ansible/3-Ansible之Playbook/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/3-Ansible之Playbook/"},{"title":"2-Ansible模块","date":"2020-02-06T08:39:32.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:53:46.404Z","content":"模块概述Ansible内置了许多模块，每一个模块都对应着在被控端的一些操作。\nAnsible可使用ansible来调用模块。\n调用格式1ansible 主机模式 -m 模块名 -a 参数 ansible参数\n\nansible参数\n--version显示版本\n1ansible --version\n\n-k提示输入SSH连接密码\n\n-K提示输入sudo的密码\n\n-C进行检查，并不真实执行模块\n\n-T执行命令的超时时间\n\n-u远程执行的用户\n\n主机模式\n192.168.31.101单独一个主机\n组名组内所有主机\nall所有主机\n192.168.31.10*通配符\ngroup1:group2组1或组2内的主机都匹配\ngroup1:&amp;group2同时在组1和组2的主机匹配\ngroup1:!group2在组1但不在组2的主机匹配\n192.168.10[1:2]正则表达式\n常用模块command默认模块，若不加-m 模块名，则默认执行该模块。\n该模块用于执行一些Shell命令，但该模块不能执行一些带有特殊符号的命令，如|, &lt;, &gt;, ;, &amp;等。\n参数\nchdir执行命令前先进入某个目录\ncreates判断文件是否存在，若存在则不执行\nremoves判断文件是否存在，若存在则执行\n示例\n1ansible mq -m command -a 'removes=/etc/hosts chdir=/etc/ cat ./hosts'\n\n\n\nShellcommand模块的升级版，支持特殊符号。\nCopy用于将文件从主控端复制到被控端。\n参数\nsrc源文件（软连接文件会复制源文件）\ndest目的文件\nbackup若目的文件存在是否进行备份\ncontent手动指定内容\ngroup文件属组\nowner文件所有者\nmode文件权限（如0777，前面需要加0）\nremote_srcno将本机上的文件分发到远程主机\nyes复制远程主机上的文件\n\n示例\n1ansible mq -m copy -a 'src=./hello.txt dest=~/hello.txt mode=0777'\n\nFetch用于抓取远程机器上的文件。\n参数\nsrc要复制的文件\ndest本机用于保存文件的目录\n示例\n1ansible mq -m fetch -a 'src=~/hello.txt dest=./fetch'\n\nFile创建、删除文件 对文件权限进行修改。\n参数\npath要操作的文件路径\ngroup文件属组\nowner文件所有者\nmode文件权限\nrecurse是否递归设置\nsrc创建软连接的源\nstateabsent删除文件\ndirectory创建目录\nfile即使文件不存在，也不会创建\nlink软链接\nhard硬链接\ntouch如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间\n\n示例\n1234567891011121314151617181920ansible mq -m file -a 'path=~/hello.txt state=absent'``` ## Yum用于使用包管理器`yum`**参数**- `name`软件包名称- `state`  - `removed`删除  - `installed`安装  - `latest`升级到最新**示例**```bashansible mq -m yum -a 'name=vim state=removed'\n\nService用于管理服务。\n参数\nname服务名称\nenabled是否开机启动\nstatereloaded平滑重启\nrestarted重启\nstarted启动\nstopped停止\n\nCron管理定时任务。\n参数\nname注释信息\nminute/hour/day/month/weekday设置时间* 取值范围内的所有数字\n/ 每过多少个数字\n-从X到Z\n，并列\n\njob要执行的任务\ndisabled是否注释定时任务\nstatepresent创建定时任务\nabsent删除定时任务\n\n示例\n1ansible mq -m cron -a 'name=echo minute=*/1 hour=* day=* month=* weekday=* job=\"echo hello &gt;&gt; ~/cron.txt\" state=present'\n\nGroup创建或删除用户组信息。\n参数\nname组名称\ngid组id\nstatepresent创建组\nabsent删除组\n\nUser创建或删除用户信息。\n参数\nname用户名\npassword密码\nuid用户id\ngroup用户基本组\ngroups用户附加组\nhome用户的家目录\nsystem是否建立系统用户\nshell/bin/bash可以登陆\n/sbin/nologin无法登陆\n\nstatepresent创建\nabsent删除\n\nUnarchive用于解压。\n参数\nsrc压缩包路径\ndest远程主机上的一个路径，即文件解压的路径\ncreates若指定的文件存在，则不解压\ncopy解压前是否将文件复制到远程主机（若为no，则压缩包必须存在于远程主机上）\ngroup解压文件的属组\nowner解压文件的属主\nmode解压文件的权限\n","thumbnail":"post/自动化运维/Ansible/2-Ansible模块/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/2-Ansible模块/"},{"title":"1-Ansible入门","date":"2020-02-06T08:21:31.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:53:40.519Z","content":"环境准备主控端主控端只能是Linux主机，我们准备了一个CentOS7的虚拟机，配置IP地址为192.168.31.200\n被控端node01\nOS: CentOS7\nIP: 192.168.31.101\n\nnode02\nOS: CentOS7\nIP: 192.168.31.102\n\n配置无密SSH登录在主控端执行：\n1234ssh-key-genssh-copy-id root@192.168.31.101ssh-copy-id root@192.168.31.102\n\n\nAnsible安装Ansible属于Agentless，采用SSH协议进行工作，无需在被控端主机上安装任何软件，只要支持SSH协议即可，在主控端我们需要安装Ansible。\n安装1pip3 install ansible\n\n配置ansible.cfg\n下载https://github.com/ansible/ansible/tree/devel/examples下的ansible.cfg放到/etc/ansible目录下。\ninventory主机列表配置文件\nlibrary库文件位置\nremote_tmp执行操作时被控端暂存文件目录\nlocal_tmp执行操作时主控端暂存文件目录\nforks执行操作时的并发数\nask_pass是否每次执行都询问SSH密码\nremote_user远程登录的用户\nlog_path日志文件路径\nsudo_user默认sudo用户\nremote_port主机端口号\nhost_key_checking是否每次执行都检查key\npipeling是否打开SSH Pipeling，可大幅提高性能\nhosts\n在/etc/ansible目录下新建hosts文件。\nAnsible入门配置Inventory将两台被控机加入到/etc/ansible/hosts中\n12[mq]192.168.31.10[1:2]\n\n测试1ansible mq -m ping\n\n","thumbnail":"post/自动化运维/Ansible/1-Ansible入门/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/1-Ansible入门/"},{"title":"8-shiro集成Spring","date":"2020-02-06T07:29:59.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:51:54.891Z","content":"","thumbnail":"post/Java/Shiro/8-shiro集成Spring/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/8-shiro集成Spring/"},{"title":"7-shiro集成Web","date":"2020-02-06T07:29:51.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:51:49.982Z","content":"","thumbnail":"post/Java/Shiro/7-shiro集成Web/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/7-shiro集成Web/"},{"title":"6-shiro之Session","date":"2020-02-06T06:32:18.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:51:47.279Z","content":"Shiro Session特点Shiro采用SessionDAO来对Session进行存储，可以通过自定义SessionDAO将Session存储到不同的位置，如数据库，文件系统等。\nShiro完全实现了一套Sesssion机制，不依赖任何运行时容器，如Servlet Container。\nShiro提供了Session Listener来监听Session生命周期的各个事件。\n...\nShiro Session API1234567891011121314151617181920212223242526public interface Session &#123;    // 获取Session ID    Serializable getId();    // 获取启动Session的时间    Date getStartTimestamp();    // 获取上次交互的时间    Date getLastAccessTime();    // 获取剩余超时时间    long getTimeout() throws InvalidSessionException;    // 设置Session最大存活时间    void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException;    // 获取创建Session的主机的Host    String getHost();    // 更新lastAccessTime    void touch() throws InvalidSessionException;    // 销毁Session    void stop() throws InvalidSessionException;     // 获取属性键集合    Collection&lt;Object&gt; getAttributeKeys() throws InvalidSessionException;    // 获取属性    Object getAttribute(Object key) throws InvalidSessionException;    // 设置属性    void setAttribute(Object key, Object value) throws InvalidSessionException;    // 移除所有属性    Object removeAttribute(Object key) throws InvalidSessionException;&#125;\n\nSessionManagerShiro提供了SessionManager来对Session做统一管理，同时SessionManager又由SecurityManager进行管理。\n默认的SessionManager为DefaultSessionManager\nWeb环境下应该使用DefaultWebSessionManager\n配置globalSessionTimeout会话超时时间，默认为30分钟\nsessionListeners会话监听器\nsessionDAO会话存储DAO，默认存在内存里\nsessionValidationScheduler会话检测调度器，负责按一定规律验证并清理孤儿会话(Orphan Session)\nsessionValidationSchedulerEnabled决定会话检测调度器是否启用\ndeleteInvalidSessions决定是否删除无效的会话\nsessionValidationInterval会话检测调度器检测的时间间隔\n组件SessionListener监听的事件onStart开启Session\nonStop关闭Session\nonExpiration会话过期\n实现SessionListener实现SessionListener接口，重写三个方法。\n12345678910111213141516public class SessionListener1 implements SessionListener &#123;    @Override    public void onStart(Session session) &#123;        System.out.println(\"Session\" + session.getId() + \" started on \" + session.getHost());    &#125;    @Override    public void onStop(Session session) &#123;        System.out.println(\"Session\" + session.getId() + \" stopped on \" + session.getHost());    &#125;    @Override    public void onExpiration(Session session) &#123;        System.out.println(\"Session\" + session.getId() + \" expired on \" + session.getHost());    &#125;&#125;\n\n配置SessionListener123456789101112[users]user1=123,useruser2=456,admin[roles]user=user:queryadmin=user:*[main]listener1=cn.edu.njust.listener.SessionListener1securityManager.sessionManager.globalSessionTimeout=10000securityManager.sessionManager.sessionListeners=$listener1\n\nSessionValidationSchedulerTODO\nSessionDAOTODO\n","thumbnail":"post/Java/Shiro/6-shiro之Session/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/6-shiro之Session/"},{"title":"5-shiro加密","date":"2020-02-06T04:38:18.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:51:44.253Z","content":"敏感信息存储在数据库中存储用户的敏感信息时我们不能直接存储明文，否则万一数据库信息泄露，则用户的敏感信息会被直接窃取。\n因此我们需要将用户的敏感信息进行加密后，再存储到数据库中。而加密又可分为可逆加密和不可逆加密，我们应使用不可逆加密算法来对用户的信息进行加密。\n带加密的注册过程\n\n\n带加密的登录过程\n\n\nShiro加密方式直接加密直接对信息使用加密算法进行加密，该方式易受到暴力破解。\ninfo = encrypt(info)\n加盐加密加上一个Salt之后再进行加密。\ninfo = encrypt(info + salt)\n加盐多次迭代加密多次进行加盐和加密。\n12for _ in range(iter):    info = encrypt(info + salt)\n\nShiro加密APIMd5Hash\nSha256Hash\nSha512Hash\n123456789101112131415161718192021222324252627282930313233String password = \"123\";String salt = UUID.randomUUID().toString();int iter = 50;// 简单加密// 简单加密 ---&gt; 16进制String pwd = new Md5Hash(password).toHex();// 简单加密 ---&gt; Base64编码pwd = new Md5Hash(password).toBase64();// 加盐加密 ---&gt; Base64编码pwd = new Md5Hash(password, salt).toBase64();// 加盐多次迭代加密 ---&gt; Base64编码pwd = new Md5Hash(password, salt, iter).toBase64();// 简单加密// 简单加密 ---&gt; 16进制pwd = new Sha256Hash(password).toHex();// 简单加密 ---&gt; Base64编码pwd = new Sha256Hash(password).toBase64();// 加盐加密 ---&gt; Base64编码pwd = new Sha256Hash(password, salt).toBase64();// 加盐多次迭代加密 ---&gt; Base64编码pwd = new Sha256Hash(password, salt, iter).toBase64();// 简单加密// 简单加密 ---&gt; 16进制pwd = new Sha512Hash(password).toHex();// 简单加密 ---&gt; Base64编码pwd = new Sha512Hash(password).toBase64();// 加盐加密 ---&gt; Base64编码pwd = new Sha512Hash(password, salt).toBase64();// 加盐多次迭代加密 ---&gt; Base64编码pwd = new Sha512Hash(password, salt, iter).toBase64();\n\nShiro加密认证对密码进行加密后，则在认证时无法直接使用默认的密码比对器进行密码比对，需要使用HashedCredentialsMatcher。\n对密码进行加盐加密后，则Realm在返回AuthenticationInfo时，还需要传入加密时所加的salt。\n配置hashAlgorithmName加密算法\nhashIterations迭代次数\nhashSalted是否加盐\nstoredCredentialsHexEncoded是否是16进制编码toBase64: false\ntoHex: true\n\n12345678910[main]credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatchercredentialsMatcher.hashAlgorithmName=MD5credentialsMatcher.hashIterations=50credentialsMatcher.hashSalted=truecredentialsMatcher.storedCredentialsHexEncoded=falserealm3 = cn.edu.njust.realm.Realm3realm3.credentialsMatcher=$credentialsMatchersecurityManager.realms = $realm3\n\nRealm12345678910111213141516171819202122232425262728293031323334public class Realm3 extends AuthorizingRealm &#123;    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;        String username = (String) principals.getPrimaryPrincipal();        SimpleAuthorizationInfo info = null;        // 直接Hard Code        //  可替换成数据库操作        if (username.equals(\"user3\")) &#123;            Set&lt;String&gt; roles = new HashSet&lt;&gt;();            roles.add(\"user\");            Set&lt;String&gt; permissions = new HashSet&lt;&gt;();            permissions.add(\"user:query\");            info = new SimpleAuthorizationInfo(roles);            info.addStringPermissions(permissions);        &#125;        return info;    &#125;    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;        String username = (String) token.getPrincipal();        SimpleAuthenticationInfo info = null;        if (username.equals(\"user3\"))&#123;            // 传入salt            String salt = \"salt\";            info = new SimpleAuthenticationInfo(\"user3\", \"zjnFk4aKrdISF6OTslZKCQ==\", ByteSource.Util.bytes(salt), getName());        &#125;        return info;    &#125;&#125;\n\n测试12345678910111213141516171819202122public class Test03 &#123;    @Test    public void test03()&#123;        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");        SecurityManager securityManager = factory.getInstance();        SecurityUtils.setSecurityManager(securityManager);        Subject subject = SecurityUtils.getSubject();        UsernamePasswordToken token = new UsernamePasswordToken();        token.setUsername(\"user3\");        token.setPassword(\"123\".toCharArray());        try&#123;            subject.login(token);            System.out.println(\"登录成功\");        &#125; catch (AuthenticationException e)&#123;            System.out.println(\"登录失败\");            e.printStackTrace();        &#125;    &#125;&#125;","thumbnail":"post/Java/Shiro/5-shiro加密/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/5-shiro加密/"},{"title":"4-shiro授权","date":"2020-02-06T03:07:41.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:51:41.532Z","content":"权限管理模型权限管理模型一般抽象为User, Role, Permission模型。\nUser可以有多个Role\nRole可以有多个Permission\nPermission代表了对资源访问的权限\nPermission表示方式\n资源:操作:实例\nuser:query用户的查询权限\n\nuser:add添加用户的权限\n\nuser:query:1查询用户1的权限\n\n*:query任何资源的查询权限(只能匹配前面一级)\n\nuser:*任何用户实例的任何权限(可匹配多级)\n\n*所有权限\n\nShiro授权API角色检查返回boolean\nSubject.hasRole\nSubject.hasRoles\nSubject.hasAllRoles\n抛异常\nSubject.checkRole\nSubject.checkRoles\n权限检查返回boolean\nSubject.isPermitted\nSubject.isPermittedAll\n抛异常\nSubject.checkPermission\nSubject.checkPermissions\nShiro授权流程Subject.hasRole(&quot;user&quot;)进行认证\n\nSecurityManager调用Authorizer进行认证\n\nAuthorizer调用Realm进行授权信息查询\n\nAuthorizer根据查询到的信息判断是否有权限\n\n源码分析DelegatingSubject调用hasRole方法进行角色查询。\n\n\n没有认证则直接返回false，否则DelegatingSubject调用DefaultSecurityManager的hasRole方法进行角色查询。\n\n\nhasRole方法定义在AuthorizingSecurityManager中，调用authorizer的hasRole方法进行角色查询。\n\n\nDefaultSecurityManager的默认authorizer为ModularRealmAuthorizer，它调用所有实现了Authorizer接口的Realm的hasRole方法进行角色查询，只要有一个Realm返回true，则hasRole返回true。\n\n\nAuthorizingRealm实现了Authorizer接口，实现了hasRole方法，它调用getAuthorizationInfo进行授权信息查询，随后将信息交由hasRole的重载方法进行角色查询。\n\n\ngetAuthorizationInfo方法最终又会调用doGetAuthorizationInfo方法进行授权信息查询。\n\n\ndoGetAuthorizationInfo为抽象方法，子类需要实现该方法进行授权信息查询。\n\n\n\n授权相关组件AuthorizerAuthorizer的主要职责就是实现hasRole等方法进行权限验证。\nRealm作用由源码分析可知，只有实现了Authorizer接口的Realm才会在授权时起作用，它主要负责根据Principal进行授权信息查询。\n扩展继承AuthorizingRealm，实现doGetAuthenticationInfo方法进行认证信息查询，实现doGetAuthorizationInfo方法进行授权信息查询。\n配置同中Realm的配置。\n自定义Realm实现授权扩展Realm12345678910111213141516171819202122232425262728293031323334353637383940public class Realm2 extends AuthorizingRealm &#123;    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;        String username = (String) principals.getPrimaryPrincipal();        SimpleAuthorizationInfo info = null;        // 直接Hard Code        //  可替换成数据库操作        if (username.equals(\"user1\")) &#123;            Set&lt;String&gt; roles = new HashSet&lt;&gt;();            roles.add(\"user\");            Set&lt;String&gt; permissions = new HashSet&lt;&gt;();            permissions.add(\"user:query\");            info = new SimpleAuthorizationInfo(roles);            info.addStringPermissions(permissions);        &#125; else if (username.equals(\"user2\"))&#123;            Set&lt;String&gt; roles = new HashSet&lt;&gt;();            roles.add(\"admin\");            Set&lt;String&gt; permissions = new HashSet&lt;&gt;();            permissions.add(\"user:*\");            info = new SimpleAuthorizationInfo(roles);            info.addStringPermissions(permissions);        &#125;        return info;    &#125;    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;        String username = (String) token.getPrincipal();        SimpleAuthenticationInfo info = null;        if (username.equals(\"user1\"))            info = new SimpleAuthenticationInfo(\"user1\", \"123\", getName());        else if (username.equals(\"user2\"))            info = new SimpleAuthenticationInfo(\"user2\", \"456\", getName());        return info;    &#125;&#125;\n\n配置Realm123[main]realm2 = cn.edu.njust.realm.Realm2securityManager.realms = $realm2\n\n测试123456789101112131415161718192021222324public class Test02 &#123;    @Test    public void test01() &#123;        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");        SecurityManager securityManager = factory.getInstance();        SecurityUtils.setSecurityManager(securityManager);        Subject subject = SecurityUtils.getSubject();        UsernamePasswordToken token = new UsernamePasswordToken();        token.setUsername(\"user1\");        token.setPassword(\"123\".toCharArray());        try&#123;            subject.login(token);            System.out.println(subject.hasRole(\"user\"));            System.out.println(subject.hasRole(\"admin\"));            System.out.println(subject.isPermitted(\"user:query\"));            System.out.println(subject.isPermitted(\"user:add\"));        &#125; catch (AuthenticationException e)&#123;            System.out.println(\"登录失败\");            e.printStackTrace();        &#125;    &#125;&#125;\n\n","thumbnail":"post/Java/Shiro/4-shiro授权/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/4-shiro授权/"},{"title":"3-shiro认证","date":"2020-02-05T14:04:33.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2020-02-08T02:51:38.356Z","content":"Shiro认证APISubject.login\nSubject.logout\nShiro认证流程Subject.login(token)进行认证\n\nSecurityManager调用Authenticator进行认证\n\nAuthenticator调用Realm进行认证信息查询与比对\n\nAuthenticator根据AuthenticationStrategy决定认证是否通过\n\n源码分析DelegatingSubject调用login方法进行认证。\n\n\nDelegatingSubject调用DefaultSecurityManager的login方法进行认证。\n\n\nlogin方法定义在AuthenticatingSecurityManager中，调用authenticate方法进行认证。\n\n\nauthenticate方法定义在父类AuthenticatingSecurityManager中，调用自身的authenticator的authenticate方法进行认证。\n\n\nDefaultSecurityManager的默认authenticator为ModularRealmAuthenticator，其authenticate方法定义在父类AbstractAuthenticator中，该方法调用doAuthenticate方法进行认证。\n\n\ndoAuthenticate方法为抽象方法，要由子类实现。\n\n\nModularRealmAuthenticator重写了doAuthenticate方法，根据Realms的数量调用doSingleRealmAuthentication方法或doMultiRealmAuthentication方法。\n\n\ndoSingleRealmAuthentication直接调用Realm的getAuthenticationInfo方法进行认证信息查询和比对。\n\n\ndoMultiRealmAuthentication对多个Realm进行认证信息查询和比对，根据AuthenticationStrategy对多个结果进行聚合，决定认证是否通过。\n\n\nRealm的getAuthenticationInfo在AuthenticatingRealm中进行了实现，该方法调用doGetAuthenticationInfo方法进行认证信息查询，然后通过CredentialsMatcher进行认证信息比对，决定认证是否通过。\n\n\ndoGetAuthenticationInfo为抽象方法，子类需要实现该方法进行认证信息查询。\n\n\n认证相关组件Authenticator作用由源码分析可知，Authenticator主要职责就是实现authenticate方法进行认证。\n扩展可通过继承AbstractAuthenticator，重写doAuthenticate方法来自定义Authentiactor。\n配置123[main]authenticator = cn.edu.njust.authenticator.CustomAuthenticatorsecurityManager.authenticator = $authenticator\n\nAuthenticationStrategy作用由源码分析可知，AuthenticationStrategy主要是在有多个Realm的情况下发挥作用。\n实现AtLeastOneSuccessfulStrategy只要有一个Realm认证成功就算成功。\nFirstSuccessfulStrategy第一个Realm认证成功就算成功。\nAllSuccessfulStrategy全部Realm认证成功就算成功。\n扩展TODO\nRealm作用由源码分析可知，Realm作用就是根据查询认证信息，和token进行比对。\n扩展继承AuthenticatingRealm，实现doGetAuthenticationInfo方法。\n配置配置主要牵涉到Realm的查询顺序问题\n隐式顺序\n按声明的顺序, realm1, realm2, realm3。\n1234[main]realm1 = cn.edu.njust.realm.Realm1realm2 = cn.edu.njust.realm.Realm1realm3 = cn.edu.njust.realm.Realm1\n\n显式顺序\n按设置的顺序, realm2, realm1, realm3。\n12345[main]realm1 = cn.edu.njust.realm.Realm1realm2 = cn.edu.njust.realm.Realm1realm3 = cn.edu.njust.realm.Realm1securityManager.realms = $realm2, $realm1, $realm3\n\n\n自定义Realm实现认证扩展Realm123456789101112131415public class Realm1 extends AuthenticatingRealm &#123;    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;        String username = (String) token.getPrincipal();        SimpleAuthenticationInfo info = null;        // 此处直接Hard Code        // 可以换成数据库查询操作        if (username.equals(\"user1\"))            info = new SimpleAuthenticationInfo(\"user1\", \"123\", getName());        else if(username.equals(\"user2\"))            info = new SimpleAuthenticationInfo(\"user2\", \"456\", getName());        return info;    &#125;&#125;\n\n配置Realm123[main]realm1 = cn.edu.njust.realm.Realm1securityManager.realms = $realm1\n\n测试123456789101112131415161718192021public class Test01 &#123;    @Test    public void test01() &#123;        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");        SecurityManager securityManager = factory.getInstance();        SecurityUtils.setSecurityManager(securityManager);        Subject subject = SecurityUtils.getSubject();        UsernamePasswordToken token = new UsernamePasswordToken();        token.setUsername(\"user1\");        token.setPassword(\"456\".toCharArray());        try&#123;            subject.login(token);            System.out.println(\"登录成功\");        &#125; catch (AuthenticationException e)&#123;            System.out.println(\"登录失败\");            e.printStackTrace();        &#125;    &#125;&#125;\n","thumbnail":"post/Java/Shiro/3-shiro认证/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/3-shiro认证/"},{"title":"2-shiro架构概述","date":"2020-02-05T13:56:01.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2020-02-08T02:51:35.544Z","content":"Shiro架构图\n\n核心组件Subject可以理解为抽象的用户。\nSecurityManager核心组件，协调所有组件。\nAuthenticator认证器，负责进行认证（登录）。\nAuthorizer授权器，控制访问权限。\nSessionManager会话管理器，Shiro自己实现了会话机制，不依赖于任何容器环境（如Servlet Container）。\nRealm认证和授权信息的数据源。\nSessionDAO对会话进行持久化操作。\nCacheManager对缓存进行管理。\nCryptography加密组件。\n","thumbnail":"post/Java/Shiro/2-shiro架构概述/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/2-shiro架构概述/"},{"title":"1-shiro入门","date":"2020-02-05T13:35:03.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2020-02-08T02:51:28.385Z","content":"创建Maven项目编译设置12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;shiro01&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;project.sourceEncoding&gt;UTF-8&lt;/project.sourceEncoding&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;    &lt;/properties&gt;&lt;/project&gt;\n\n导入依赖shiro-core\njunit\nlogback\njcl-over-slf4j(commons-logging到slf4j的bridge)\n123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;shiro01&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;project.sourceEncoding&gt;UTF-8&lt;/project.sourceEncoding&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;            &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;            &lt;version&gt;1.4.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;            &lt;version&gt;1.7.25&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;            &lt;version&gt;1.2.3&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\n编写配置文件[users]配置用户（用户名=密码，角色1，角色2...）\n[roles]配置角色（角色名=权限1，权限2...）\n12345678[users]user1=123user2=123,useruser3=123,admin[roles]user=user:queryadmin=user:*\n\n编写测试读取配置文件\n创建SecurityManager\n创建Subject\n设置Token\n认证\n12345678910111213141516171819202122public class Test01 &#123;    @Test    public void test01() &#123;        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");        SecurityManager securityManager = factory.getInstance();        SecurityUtils.setSecurityManager(securityManager);        Subject subject = SecurityUtils.getSubject();        UsernamePasswordToken token = new UsernamePasswordToken();        token.setUsername(\"user1\");        token.setPassword(\"123\".toCharArray());        try&#123;            subject.login(token);        &#125; catch (AuthenticationException e)&#123;            System.out.println(\"登录失败\");            e.printStackTrace();        &#125;        System.out.println(\"登录成功\");    &#125;&#125;\n","thumbnail":"post/Java/Shiro/1-shiro入门/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/1-shiro入门/"},{"title":"6-SpringMVC实现Restful","date":"2020-02-05T11:21:52.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2020-02-08T02:43:29.595Z","content":"依赖要将JSON字符串和pojo对象互相转化必须引入jackson-databind包。\n方式一：@Controller + @RequestMapping + @RequestBody + @ResponseBody编写pojo类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class User &#123;    private Integer id;    private String name;    private List&lt;String&gt; hobbies;    public User(Integer id, String name, List&lt;String&gt; hobbies) &#123;        this.id = id;        this.name = name;        this.hobbies = hobbies;    &#125;    public User() &#123;    &#125;    @Override    public String toString() &#123;        return \"User&#123;\" +                \"id=\" + id +                \", name='\" + name + '\\'' +                \", hobbies=\" + hobbies +                '&#125;';    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public List&lt;String&gt; getHobbies() &#123;        return hobbies;    &#125;    public void setHobbies(List&lt;String&gt; hobbies) &#123;        this.hobbies = hobbies;    &#125;&#125;\n\nRestful API设计GET /users/查找所有用户\nGET /users/1/查找id为1的用户\nPOST /users/添加用户\nDELETE /users/删除所有用户\nDELETE /users/1/删除id为1的用户\nPUT /users/1/更新id为1的用户\n编写Controller类@RequestMethod指定请求方法（下列DELETE方法和PUT方法会返回403错误，稍后解决）\n@RequestBody解析JSON参数转化成对象\n@ResponseBody将返回值转化成JSON\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Controllerpublic class PlainController &#123;    @RequestMapping(path=\"/users/\", method = RequestMethod.GET)    @ResponseBody    public List&lt;User&gt; findAll()&#123;        List&lt;User&gt; users = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 5; i++) &#123;            User user = new User();            List&lt;String&gt; hobbies = new ArrayList&lt;&gt;();            hobbies.add(\"打球\");            hobbies.add(\"吃火锅\");            user.setHobbies(hobbies);            user.setId(i);            user.setName(\"罗浩文\");            users.add(user);        &#125;        return users;    &#125;    @RequestMapping(path = \"/users/&#123;id&#125;/\", method = RequestMethod.GET)    @ResponseBody    public User findById(@PathVariable(name = \"id\", required = true) int id)&#123;        User user = new User();        List&lt;String&gt; hobbies = new ArrayList&lt;&gt;();        hobbies.add(\"打球\");        hobbies.add(\"吃火锅\");        user.setHobbies(hobbies);        user.setId(id);        user.setName(\"罗浩文\");        return user;    &#125;    @RequestMapping(path = \"/users/\", method = RequestMethod.POST)    public void add(@RequestBody User user)&#123;        System.out.println(user);    &#125;    // 返回403 Forbidden    @RequestMapping(path = \"/users/\", method = RequestMethod.DELETE)    public void deleteAll()&#123;        System.out.println(\"delete all\");    &#125;    // 返回403 Forbidden    @RequestMapping(path = \"/users/&#123;id&#125;/\", method = RequestMethod.DELETE)    public void deleteById(@PathVariable(name = \"id\", required = true) int id)&#123;        System.out.println(\"delete user \" + id);    &#125;    // 返回403 Forbidden    @RequestMapping(path = \"/users/&#123;id&#125;/\", method = RequestMethod.PUT)    public void updateById(@PathVariable(name = \"id\", required = true) int id, @RequestBody User user)&#123;        System.out.println(\"update user \" + id + \"  \" + user);    &#125;&#125;\n\n状态码在请求成功和出错时应该返回适当的状态码。\n@ResponseStatus指定状态码\n请求成功Controller方法上使用@ResponseStatus可指定请求成功时返回的状态码。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Controllerpublic class PlainController &#123;    @RequestMapping(path=\"/users/\", method = RequestMethod.GET)    @ResponseBody    @ResponseStatus(HttpStatus.OK)    public List&lt;User&gt; findAll()&#123;        List&lt;User&gt; users = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 5; i++) &#123;            User user = new User();            List&lt;String&gt; hobbies = new ArrayList&lt;&gt;();            hobbies.add(\"打球\");            hobbies.add(\"吃火锅\");            user.setHobbies(hobbies);            user.setId(i);            user.setName(\"罗浩文\");            users.add(user);        &#125;        return users;    &#125;    @RequestMapping(path = \"/users/&#123;id&#125;/\", method = RequestMethod.GET)    @ResponseBody    @ResponseStatus(HttpStatus.OK)    public User findById(@PathVariable(name = \"id\", required = true) int id)&#123;        User user = new User();        List&lt;String&gt; hobbies = new ArrayList&lt;&gt;();        hobbies.add(\"打球\");        hobbies.add(\"吃火锅\");        user.setHobbies(hobbies);        user.setId(id);        user.setName(\"罗浩文\");        return user;    &#125;    @RequestMapping(path = \"/users/\", method = RequestMethod.POST)    @ResponseStatus(HttpStatus.OK)    public void add(@RequestBody User user)&#123;        System.out.println(user);    &#125;    @RequestMapping(path = \"/users/\", method = RequestMethod.DELETE)    @ResponseStatus(HttpStatus.OK)    public void deleteAll()&#123;        System.out.println(\"delete all\");    &#125;    @RequestMapping(path = \"/users/&#123;id&#125;/\", method = RequestMethod.DELETE)    @ResponseStatus(HttpStatus.OK)    public void deleteById(@PathVariable(name = \"id\", required = true) int id)&#123;        System.out.println(\"delete user \" + id);    &#125;    @RequestMapping(path = \"/users/&#123;id&#125;/\", method = RequestMethod.PUT)    @ResponseStatus(HttpStatus.OK)    public void updateById(@PathVariable(name = \"id\", required = true) int id, @RequestBody User user)&#123;        System.out.println(\"update user \" + id + \"  \" + user);    &#125;&#125;\n\n请求失败方式一：自定义异常类指定状态码抛出自定义异常类\n在自定义异常类上用@ResponseStatus指明异常时返回的状态码\n自定义异常\n1234567891011@ResponseStatus(HttpStatus.BAD_REQUEST)public class CustomException extends RuntimeException &#123;    public CustomException() &#123;        super();    &#125;    public CustomException(String s) &#123;        super(s);    &#125;&#125;\nController\n123456789@Controllerpublic class PlainController &#123;    @RequestMapping(path = \"/error/\", method = RequestMethod.GET)    @ResponseStatus(HttpStatus.OK)    public void error()&#123;        throw new CustomException(\"custom exception\");    &#125;&#125;\n\n方式二：@ControllerAdvice处理异常指定状态码使用@ControllerAdvice和@ExceptionHandler进行异常处理，并指定状态码。\n123456789@ControllerAdvicepublic class MyControllerAdvice &#123;    @ResponseStatus(HttpStatus.BAD_REQUEST)    @ExceptionHandler(CustomException.class)    public void handleCustomException(CustomException e)&#123;        System.out.println(e.getMessage());    &#125;&#125;\n\n方式二：@RestController + @XXXMapping + @RequestBody@RestController的所有方法都使用@ResponseBody返回JSON\nXXXMappingGetMapping\nPostMapping\nPutMapping\nDeleteMapping\n...\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@RestControllerpublic class RestfulController &#123;    @GetMapping(\"/rest/users/\")    @ResponseStatus(HttpStatus.OK)    public List&lt;User&gt; findAll() &#123;        List&lt;User&gt; users = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 5; i++) &#123;            User user = new User();            List&lt;String&gt; hobbies = new ArrayList&lt;&gt;();            hobbies.add(\"打球\");            hobbies.add(\"吃火锅\");            user.setHobbies(hobbies);            user.setId(i);            user.setName(\"罗浩文\");            users.add(user);        &#125;        return users;    &#125;    @GetMapping(\"/rest/users/&#123;id&#125;/\")    @ResponseStatus(HttpStatus.OK)    public User findById(@PathVariable(name = \"id\", required = true) int id) &#123;        User user = new User();        List&lt;String&gt; hobbies = new ArrayList&lt;&gt;();        hobbies.add(\"打球\");        hobbies.add(\"吃火锅\");        user.setHobbies(hobbies);        user.setId(id);        user.setName(\"罗浩文\");        return user;    &#125;    @PostMapping(\"/rest/users/\")    @ResponseStatus(HttpStatus.OK)    public void add(@RequestBody User user) &#123;        System.out.println(user);    &#125;    @DeleteMapping(\"/rest/users/\")    @ResponseStatus(HttpStatus.OK)    public void deleteAll() &#123;        System.out.println(\"delete all\");    &#125;    @DeleteMapping(\"/rest/users/&#123;id&#125;/\")    @ResponseStatus(HttpStatus.OK)    public void deleteById(@PathVariable(name = \"id\", required = true) int id) &#123;        System.out.println(\"delete user \" + id);    &#125;    @PutMapping(\"/rest/users/&#123;id&#125;/\")    @ResponseStatus(HttpStatus.OK)    public void updateById(@PathVariable(name = \"id\", required = true) int id, @RequestBody User user) &#123;        System.out.println(\"update user \" + id + \"  \" + user);    &#125;    @GetMapping(\"/rest/error\")    @ResponseStatus(HttpStatus.OK)    public void error() &#123;        throw new CustomException(\"custom exception\");    &#125;&#125;","thumbnail":"post/Java/SpringMVC/6-SpringMVC实现Restful/cover.png","plink":"https://beginc.github.io/post/Java/SpringMVC/6-SpringMVC实现Restful/"},{"title":"5-SpringMVC拦截器","date":"2020-02-05T10:23:17.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2020-02-08T02:43:26.289Z","content":"拦截器概述SpringMVC中的拦截器可用于拦截处理器方法执行，用于对其进行预处理和后处理。\n拦截器实现编写拦截器类实现HandlerInterceptor接口\n根据需要改写三个方法：preHandle调用处理器方法之前执行\npostHandle调用处理器方法之后执行\nafterCompletion当DispatcherServlet处理完请求后执行\n\n1234567891011121314public class MyInterceptor1 implements HandlerInterceptor &#123;    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(\"Interceptor1 preHandle\");        return true;    &#125;    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123;        System.out.println(\"Interceptor1 postHandle\");    &#125;    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123;        System.out.println(\"Interceptor1 afterCompletion\");    &#125;&#125;\n\n1234567891011121314public class MyInterceptor2 implements HandlerInterceptor &#123;    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(\"Interceptor2 preHandle\");        return true;    &#125;    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123;        System.out.println(\"Interceptor2 postHandle\");    &#125;    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123;        System.out.println(\"Interceptor2 afterCompletion\");    &#125;&#125;\n\n配置拦截器mapping指定要拦截的路径\nexclude-mapping指定不拦截的路径\n配置的先后顺序决定了调用的顺序\n123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;context:component-scan base-package=\"controller\"/&gt;    &lt;context:component-scan base-package=\"exception\"/&gt;    &lt;!--注册类型转换器--&gt;    &lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt;    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;        &lt;property name=\"prefix\" value=\"/\"&gt;&lt;/property&gt;        &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--注册类型转换器--&gt;    &lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt;        &lt;property name=\"converters\"&gt;            &lt;array&gt;                &lt;bean class=\"converter.StringToDateConverter\"&gt;                &lt;/bean&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置拦截器--&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;mvc:mapping path=\"/inter/\"/&gt;        &lt;!--&lt;mvc:exclude-mapping path=\"\"/&gt;--&gt;            &lt;bean class=\"interceptor.MyInterceptor1\"&gt;            &lt;/bean&gt;        &lt;/mvc:interceptor&gt;        &lt;mvc:interceptor&gt;            &lt;mvc:mapping path=\"/inter/\"/&gt;            &lt;!--&lt;mvc:exclude-mapping path=\"\"/&gt;--&gt;            &lt;bean class=\"interceptor.MyInterceptor2\"&gt;            &lt;/bean&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;&lt;/beans&gt;\n\n拦截器调用顺序preHandle按配置的顺序先后执行。\npostHandle按配置的顺序逆序执行。\nafterCompletion按配置的顺序逆序执行。\n拦截器与过滤器区别过滤器是ServletAPI的一部分，任何Web应用都能使用；拦截器只有SpringMVC项目才能使用。\n过滤器可以过滤任何资源；拦截器只能拦截处理器方法。\n顺序当同事配置了拦截器和过滤器，执行顺序为：\n过滤器\n拦截器\n","thumbnail":"post/Java/SpringMVC/5-SpringMVC拦截器/cover.png","plink":"https://beginc.github.io/post/Java/SpringMVC/5-SpringMVC拦截器/"},{"title":"4-SpringMVC异常处理","date":"2020-02-05T09:05:59.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2020-02-08T02:43:23.604Z","content":"异常处理概述在三层项目中，若我们在每一层都对发生的异常进行try catch单独处理，则会导致代码异常处理十分混乱不易于管理。因此较好的做法是，在DAO层和Service层以及Controller层产生的异常我们都不做处理，而是直接向上抛出，最后再为Controller层配置一个统一的异常处理器，对异常进行集中处理。\n方式一：HandlerExceptionResolver自定义异常处理器实现HandlerExceptionResolver接口\n重写resolveException方法\n123456789101112public class ExceptionResolver implements HandlerExceptionResolver &#123;    @Override    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler, Exception e) &#123;        if(e instanceof ArithmeticException)&#123;            System.out.println(\"处理了算术异常\");        &#125;        ModelAndView mv = new ModelAndView();        // 转向错误页面        mv.setViewName(\"error\");        return mv;    &#125;&#125;\n\n注册异常处理器直接实例化即可。\n1234567891011121314151617181920212223242526272829303132&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;context:component-scan base-package=\"controller\"/&gt;    &lt;!--注册类型转换器--&gt;    &lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt;    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;        &lt;property name=\"prefix\" value=\"/\"&gt;&lt;/property&gt;        &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--注册类型转换器--&gt;    &lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt;        &lt;property name=\"converters\"&gt;            &lt;array&gt;                &lt;bean class=\"converter.StringToDateConverter\"&gt;                &lt;/bean&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--注册异常处理器--&gt;    &lt;bean class=\"resolver.ExceptionResolver\"&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nControllerController发生异常后，会交由我们自定义的异常处理器进行处理。\n12345678910@Controller@RequestMapping(\"/exception\")public class ExceptionController &#123;    @RequestMapping    public String exceptionView()&#123;        int i = 1 / 0;        return \"success\";    &#125;&#125;\n\n方式二：@ControllerAdvice + @ExceptionHandler被@ControllerAdvice注解的类可以理解为增强的Controller。\n参数basePackages指定要通知的包\nbasePackageClasses用包中的一个类来指定要通知的包\nassignableTypes指定要通知的类\n\n可实现功能全局异常处理\n全局数据绑定\n全局数据预处理\n\n全局异常处理使用@ExceptionHandler注解在方法上，指定要处理的异常。\n12345678910@ControllerAdvicepublic class MyControllerAdvice &#123;    @ExceptionHandler(ArithmeticException.class)    public String handleArithmeticException(Exception e)&#123;        e.printStackTrace();        System.out.println(\"算术异常\");        return \"error\";    &#125;  &#125;\n\n全局数据绑定使用@ModelAttribute注解在方法上，可为所有的Controller预先绑定参数到ModelMap中（不限于在@ControllerAdvice中指定的类中的Controller）。\nControllerAdvice中的@ModelAttribute注解的方法要先于Controller的@ModelAttribute注解的方法执行(即MyControllerAdvice.bindModelMap要先于ExceptionController.bindModelMap执行)\n123456789@ControllerAdvicepublic class MyControllerAdvice &#123;    @ModelAttribute    public void bindModelMap(ModelMap map)&#123;        System.out.println(\"bind global\");        map.addAttribute(\"global\", new Date());    &#125;&#125;\n\n123456789101112131415161718@Controller@RequestMapping(\"/exception\")public class ExceptionController &#123;    @RequestMapping    public String exceptionView(@ModelAttribute(\"date\")Date global, @ModelAttribute(\"local\") Date local)&#123;        System.out.println(global);        System.out.println(local);        int i = 1 / 0;        return \"success\";    &#125;    @ModelAttribute    public void bindModelMap(ModelMap map)&#123;        System.out.println(\"bind local\");        map.addAttribute(\"local\", new Date());    &#125;&#125;\n\n全局数据预处理使用@InitBinder。\n","thumbnail":"post/Java/SpringMVC/4-SpringMVC异常处理/cover.png","plink":"https://beginc.github.io/post/Java/SpringMVC/4-SpringMVC异常处理/"},{"title":"3-SpringMVC请求响应","date":"2020-02-05T03:02:14.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2020-02-08T02:43:20.856Z","content":"返回字符串字符串指定试图名称。\n默认默认为请求转发\n12345678910@Controller@RequestMapping(\"/response\")public class ResponseController &#123;    @RequestMapping(\"defaultString\")    public String defaultStringResponse()&#123;        System.out.println(\"defaultStringResponse\");        return \"success\";    &#125;&#125;\n\n转发用forward指定转发\n视图名称必须用全名称\n12345678910@Controller@RequestMapping(\"/response\")public class ResponseController &#123;    @RequestMapping(\"forwardString\")    public String forwardStringResponse()&#123;        System.out.println(\"forwardStringResponse\");        return \"forward:/success.jsp\";    &#125;&#125;\n\n重定向用redirect指定重定向\n视图名称必须用全名称\n12345678910@Controller@RequestMapping(\"/response\")public class ResponseController &#123;    @RequestMapping(\"redirectString\")    public String redirectStringResponse()&#123;        System.out.println(\"redirectStringResponse\");        return \"redirect:/success.jsp\";    &#125;&#125;\n\n返回ModelAndViewaddObject绑定数据到requestScope中\nsetViewName指定视图名称\n12345678910111213@Controller@RequestMapping(\"/response\")public class ResponseController &#123;    @RequestMapping(\"modelAndView\")    public ModelAndView modelAndViewResponse()&#123;        ModelAndView mv = new ModelAndView();        mv.addObject(\"now\", new Date());        mv.setViewName(\"success\");        return mv;    &#125;&#125;\n\n返回void绑定HttpServletRequest进行转发\n绑定HttpServletResponse进行重定向\n获取PrintWriter直接输出\n1234567891011@Controller@RequestMapping(\"/response\")public class ResponseController &#123;    @RequestMapping(\"void\")    public void voidResponse(HttpServletResponse response) throws IOException &#123;        response.setContentType(\"text/html;charset=utf-8\");        response.setCharacterEncoding(\"utf-8\");        response.getWriter().write(\"success\");    &#125;&#125;\n\n返回Json见\n","thumbnail":"post/Java/SpringMVC/3-SpringMVC请求响应/cover.png","plink":"https://beginc.github.io/post/Java/SpringMVC/3-SpringMVC请求响应/"},{"title":"maven多模块构建","date":"2020-01-29T05:40:52.000Z","date_formatted":{"ll":"Jan 29, 2020","L":"01/29/2020","MM-DD":"01-29"},"updated":"2020-02-08T02:48:26.156Z","content":"","thumbnail":"post/Java/Maven/maven多模块构建/cover.jpg","plink":"https://beginc.github.io/post/Java/Maven/maven多模块构建/"},{"title":"maven基本使用","date":"2020-01-29T04:41:35.000Z","date_formatted":{"ll":"Jan 29, 2020","L":"01/29/2020","MM-DD":"01-29"},"updated":"2020-02-08T02:48:29.813Z","content":"Maven的功能依赖管理\n一键构建\nMaven配置本地仓库conf/settings.xml\n1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\"          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt;  &lt;localRepository&gt;F:\\repository&lt;/localRepository&gt;&lt;/settings&gt;\n\n中央仓库配置阿里云的镜像。\nconf/settings.xml\n1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\"          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt;  &lt;localRepository&gt;F:\\repository&lt;/localRepository&gt;  &lt;mirrors&gt;     &lt;mirror&gt;          &lt;id&gt;alimaven&lt;/id&gt;          &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          &lt;name&gt;aliyun maven&lt;/name&gt;          &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;      &lt;/mirror&gt;   &lt;/mirrors&gt;&lt;/settings&gt;\n\nMaven项目结构1234567891011121314151617181920Project/    # 源码    src/        main/          # 源码          java/          # 资源、配置文件等(编译后会放入target/classes目录下)          resources/        test/          # 测试代码          java/    # 构建出来的文件    target/        # 编译src/main/java生成的字节码文件        classes/        # 编译src/test/java生产的字节码文件        test-classes/        ...    # Maven项目配置文件    pom.xml\n\nMaven常用命令命令mvn clean\n清除target文件夹。\nmvn compile\n编译src/main/java。\nmvn test\n运行src/test/java下的测试。\nmvn package\n将项目打包成jar/war放到target目录下。\nmvn install\n将项目安装到本地仓库。\n流程执行一个命令时都会从头开始执行。如mvn test会运行mvn clean, mvn compile,mvn test。\n\n\nMaven生命周期清除生命周期\n默认生命周期\n站点生命周期\n\n\nMaven项目配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;!--maven项目对象模型版本--&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;!--组织名--&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;!--项目名--&gt;    &lt;artifactId&gt;spring-03&lt;/artifactId&gt;    &lt;!--版本号--&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;!--定义属性--&gt;    &lt;properties&gt;        &lt;spring.version&gt;5.2.1.RELEASE&lt;/spring.version&gt;    &lt;/properties&gt;    &lt;!--依赖版本锁定--&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-test&lt;/artifactId&gt;              &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;              &lt;scope&gt;test&lt;/scope&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-context&lt;/artifactId&gt;              &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;              &lt;scope&gt;test&lt;/scope&gt;          &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;!--项目依赖--&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.15&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;!--插件--&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                    &lt;source&gt;11&lt;/source&gt;                    &lt;target&gt;11&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n项目信息modelVersion\nmaven项目对象模型的版本。\ngroupId\n组织名。\nartifactId\n项目名。\nversion\n版本号。\nPropertyproperties\n定义一些属性。\n依赖dependencies\n项目依赖。\ngroupId\nartifactId\nversion\nscope\n版本锁定dependencyManagement\n将依赖的版本进行锁定，该项目的子模块无法进行替换。\n插件plugins\n依赖管理依赖定位groupId\nartifactId\nversion\n依赖作用范围compile\n编译、测试、运行时都需要。\nruntime\n只有测试、运行时需要。\ntest\n只有\nprovided\n","thumbnail":"post/Java/Maven/maven基本使用/cover.jpg","plink":"https://beginc.github.io/post/Java/Maven/maven基本使用/"},{"title":"Jave内置日志介绍","date":"2020-01-28T09:16:19.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:39:22.684Z","content":"主要组件Logger实际使用的日志类。\nHandler接收日志，并输出到目的地。\nFilter过滤器，决定一个日志记录是否可以输出。\nErrorManager错误管理器，负责处理Handler处理日志时发生的错误。\nLogRecord日志记录，每次调用方法输出日志会产生一个该类实例。\nLogManager日志管理器。\n将所有Logger组织成一个层次结构\n维护一些配置信息\nLevel日志级别。\nOFF\nSEVERE\nWARNING\nINFO\nCONFIG\nFINE\nFINER\nFINEST\nALL\n基本使用创建和输出12345678910public void testJavaLogging()&#123;    Logger logger = Logger.getLogger(getClass().getName());    logger.severe(\"log\");    logger.warning(\"log\");    logger.info(\"log\");    logger.config(\"log\");    logger.fine(\"log\");    logger.finer(\"log\");    logger.finest(\"log\");&#125;\n\nTODO由于JUL使用不多，不做深入研究。\n","thumbnail":"post/Java/日志/Jave内置日志介绍/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/Jave内置日志介绍/"},{"title":"日志框架迁移","date":"2020-01-28T09:05:52.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:38:46.260Z","content":"Spring替换commons-logging为slf4j排除spring-core.jar对commons-logging的依赖\n1234567891011&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;commons-logging&lt;/groupId&gt;            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;\n\n引入slf4j\n12345&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;    &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;\n\n引入辅助包进行适配\n12345&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;    &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;\n\n\nMyBatis指定日志框架在SqlMapConfig.xml中settings配置logImpl\n    可为SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING\n12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;properties resource=\"jdbc.properties\"/&gt;    &lt;settings&gt;        &lt;setting name=\"logImpl\" value=\"slf4j\"/&gt;    &lt;/settings&gt;    &lt;typeAliases&gt;        &lt;package name=\"bean\"/&gt;    &lt;/typeAliases&gt;    &lt;environments default=\"dev\"&gt;        &lt;environment id=\"dev\"&gt;            &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt;            &lt;dataSource type=\"POOLED\"&gt;                &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt;                &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt;                &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt;                &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=\"sqlmap/ManagerMapper.xml\"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;","thumbnail":"post/Java/日志/日志框架迁移/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/日志框架迁移/"},{"title":"logback介绍","date":"2020-01-28T09:05:39.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:39:33.705Z","content":"包介绍logback-core.jar基础核心包\nlogback-classic.jar对slf4j API的直接实现\nlogback-access.jar实现在HTTP环境中进行日志\n架构组件基本和Java日志框架概况中说明的组件相同（名称等略有不同）。\n层次性遵从Java日志框架概况说明的层次性。\n配置配置文件查找顺序找clasapath:logback-test.xml\n找clasapath:logback.groovy\n找clasapath:logback.xml\n找META-INF\\services\\ch.qos.logback.classic.spi中指定的类(ServiceProvider)\n使用BasicConfigurator进行基本配置，默认输出到控制台\n配置模板1234567891011121314151617&lt;configuration&gt;  &lt;property name=\"属性名称\" value=\"属性值\" /&gt;  &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;    &lt;encoder&gt;      &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;    &lt;/encoder&gt;  &lt;/appender&gt;  &lt;logger name=\"logger\" level=\"info\" additivity=\"false\"&gt;  &lt;/logger&gt;  &lt;root level=\"debug\"&gt;    &lt;appender-ref ref=\"STDOUT\" /&gt;  &lt;/root&gt;&lt;/configuration&gt;\n\n常用AppenderConsoleAppender输出到控制台。\ntarget\nSystem.out\nSystem.error\nFileAppender输出到文件。\nappend\n是否追加。\nfile\n文件名\nprudent\n是否安全写入文件（并发写情况下有用，若为true默认为追加）\nimmediateFlush\n是否写的时候立即刷新缓冲区。\nRollingFileAppender滚动追加。（有FileAppender所有属性）\nrollingPolicy\n指定如何滚动。\ntriggeringPolicy\n指定何时触发滚动。\n","thumbnail":"post/Java/日志/logback介绍/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/logback介绍/"},{"title":"log4j介绍","date":"2020-01-28T09:05:32.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:39:29.955Z","content":"Deprecatedlog4j已经被弃用，现在被log4j2代替\n","thumbnail":"post/Java/日志/log4j介绍/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/log4j介绍/"},{"title":"log4j2介绍","date":"2020-01-28T09:05:24.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:39:27.130Z","content":"包介绍log4j-api包含了API\nlog4j-core核心包（根据不同的需求有额外的依赖）\n\n\n架构组件基本和Java日志框架概况中说明的组件相同（名称等略有不同）。\n\n\n层次性遵从Java日志框架概况说明的层次性。\n配置配置文件查找顺序查找名为log4j.configurationFile的System Property对应的配置文件。\n\n查找classpath:log4j2-test.properties\n\n查找classpath:log4j2-test.yaml或classpath:log4j2-test.yaml\n\n查找classpath:log4j2-test.json或classpath:log4j2-test.jsn\n\n查找classpath:log4j2-test.xml\n\n查找classpath:log4j2.properties\n\n查找classpath:log4j2.yaml或classpath:log4j2.yaml\n\n查找classpath:log4j2.json或classpath:log4j2.jsn\n\n查找classpath:log4j2.xml\n\n使用默认配置\n\nConsoleAppender添加到RootLogger\nPatternLayout添加到RootLogger\nRootLogger的Level为ERROR\n配置模板1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;;&lt;Configuration&gt;  &lt;!--定义变量--&gt;  &lt;Properties&gt;    &lt;Property name=\"变量名\"&gt;变量值&lt;/property&gt;  &lt;/Properties&gt;  &lt;Filter名 属性1=\"值\" 属性2=\"值\"&gt;  &lt;/Filter名&gt;  &lt;Appenders&gt;    &lt;Appender名 属性1=\"值\" 属性2=\"值\"&gt;      &lt;Filter名 属性1=\"值\" 属性2=\"值\"&gt;      &lt;/Filter名&gt;      &lt;Layout名 属性1=\"值\" 属性2=\"值\"&gt;      &lt;/Layout名&gt;    &lt;/Appender名&gt;  &lt;/Appenders&gt;  &lt;Loggers&gt;    &lt;Logger name=\"logger\" level=\"info\" addictivity=\"false\"&gt;      &lt;Filter名 属性1=\"值\" 属性2=\"值\"&gt;      &lt;/Filter名&gt;      &lt;AppenderRef ref=\"name\"&gt;        &lt;Filter名 属性1=\"值\" 属性2=\"值\"&gt;        &lt;/Filter名&gt;      &lt;/AppenderRef&gt;    &lt;/Logger&gt;    &lt;Root level=\"error\"&gt;      &lt;AppenderRef ref=\"name\"/&gt;    &lt;/Root&gt;  &lt;/Loggers&gt;&lt;/Configuration&gt;\n\n常用AppenderConsoleAppender输出到控制台。\ntarget\nSYSTEM_OUT\nSYSTEM_ERROR\nFileAppender输出到文件。\nappend\n是否追加。\nbufferedIO\n是否写日志先写到缓冲区，满了再写到磁盘，可提高性能。\nbufferSize\n缓冲区大小。\ncreateOnDemand\n是否在真正写日志时再创建文件。\nfileName\n文件名。\nimmediateFlush\n每次写到缓冲区都会马上刷新。\nlocking\n是否写时上锁。会极大影响性能。\nRollingFileAppender输出到文件，可指定何时进行滚动。（FileAppender的属性都有）\npolicy\n决定是否发生滚动。\nstrategy\n决定滚动产生的文件的位置和名称。\n常用FilterBurstFilter控制每秒打印的日志数量。\nlevel\n低于或等于该级别的日志会被过滤。\nrate\n允许的日志输出速率。\nmaxBurst\n最大排队日志数量，默认为rate * 10, 当超过该数量时，日志将会被丢弃。\nonMatch\n符合条件时的行为\nACCEPT通过\nDENY拒绝（过滤掉）\nNEUTRAL（交给其他过滤器继续决定）\nonMismatch\n不符合条件时的行为\nACCEPT通过\nDENY拒绝（过滤掉）\nNEUTRAL（交给其他过滤器继续决定）\n常用LayoutHTML Layout输出成HTML的形式，每条日志都在一个table中。\ncharset\n字符集。\ntitle\n标题。\nfontName\n字体名。\nfontSize\n字体大小。\nJSON Layout输出成JSON格式。\ncharset\n字符集。\ncompact\n紧凑形式，设置compact和eventEol都为true，则为一条记录占一行。\ncomplete\n若为false，将省略数组的[]和隔开字段的,。\nobjectMessageAsJsonObject\n若为true，则ObjectMessage将会被序列化成JSON。\nPattern Layout格式化输出。\ncharset\n字符集。\npattern\n指定格式。\n%logger{precision}\n输出Logger名称\n\n\n%class{precision}\n输出调用者全限定类名\n\n%date{pattern}\n输出日期\n\n\n%msg\n日志信息。\n\n%method\n方法名\n\n%pid\n进程id\n\n%tid\n线程id\n\n%level\n\n日志级别\n","thumbnail":"post/Java/日志/log4j2介绍/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/log4j2介绍/"},{"title":"commons-logging介绍","date":"2020-01-28T09:01:49.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:38:51.336Z","content":"","thumbnail":"post/Java/日志/commons-logging介绍/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/commons-logging介绍/"},{"title":"slf4j介绍","date":"2020-01-28T09:01:39.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:39:37.690Z","content":"SLF4J包介绍slf4j-api-1.7.27.jar核心包，只要使用slf4j则必须引入\nslf4j-log4j12-1.7.27.jar绑定log4j1.2版本的包\nslf4j-jdk14-1.7.27.jar绑定使用java.util.logging的包\nslf4j-nop-1.7.27.jar不进行任何日志操作\nslf4j-simple-1.7.27.jar使用简单的日志框架实现的包\nslf4j-jcl-1.7.27.jar绑定使用Jakarta Commons Logging的包\nlogback-classic-1.2.3.jar绑定使用logback的包\n绑定具体日志框架引入slf4j-api-1.7.27.jar\n引入日志框架的包\n引入对应的绑定日志框架的包\n使用\nLoggerFactory.getLogger(logger名字)\nlogger.trace()\nlogger.debug()\nlogger.info()\nlogger.warn()\nlogger.error()\n12345678910111213141516import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class TestLog &#123;    @Test    public void test01() &#123;        Logger logger = LoggerFactory.getLogger(\"test\");        logger.trace(\"From slf4j, from class &#123;&#125;\", getClass().getName());        logger.debug(\"From slf4j, from class &#123;&#125;\", getClass().getName());        logger.info(\"From slf4j, from class &#123;&#125;\", getClass().getName());        logger.warn(\"From slf4j, from class &#123;&#125;\", getClass().getName());        logger.error(\"From slf4j, from class &#123;&#125;\", getClass().getName());    &#125;&#125;","thumbnail":"post/Java/日志/slf4j介绍/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/slf4j介绍/"},{"title":"2-SpringMVC参数绑定","date":"2020-01-28T02:33:22.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:43:17.238Z","content":"表单参数绑定绑定规则变量名与表单名的name相同则可直接绑定\n\n变量名与表单名的name不相同\n @RequestParam注解：\nname:名称\nrequired:必须有值\ndefaultValue：默认值\n\n基本类型与String基本类型123456&lt;div class=\"form\"&gt;    &lt;form action=\"bind/int\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"int\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\n123456@RequestMapping(path = \"/int\")public String intView(int var)&#123;    System.out.println(var);    return \"success\";&#125;\n\nString123456&lt;div class=\"form\"&gt;    &lt;form action=\"bind/string\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"String\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\n12345@RequestMapping(path = \"/string\")public String stringView(String var)&#123;    System.out.println(var);    return \"success\";&#125;\n\n集合类型Array都填相同的名字\n12345678&lt;div class=\"form\"&gt;    &lt;form action=\"bind/array\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"array\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"array\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"array\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\n12345@RequestMapping(path = \"/array\")public String arrayView(int[] var)&#123;    System.out.println(Arrays.toString(var));    return \"success\";&#125;\n\nList都填相同的名字\n参数必须用@RequestParam修饰\n12345678&lt;div class=\"form\"&gt;    &lt;form action=\"bind/list\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"list\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"list\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"list\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\n1234567@RequestMapping(path = \"/list\")public String listView(@RequestParam(\"var\") List&lt;Integer&gt; var)&#123;    for (Integer integer : var) &#123;        System.out.println(integer);    &#125;    return \"success\";&#125;\n\nSet都填相同的名字\n参数必须用@RequestParam修饰\n12345678&lt;div class=\"form\"&gt;    &lt;form action=\"bind/set\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"set\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"set\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"set\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\n1234567@RequestMapping(path = \"/set\")public String setView(@RequestParam(\"var\") Set&lt;Integer&gt; var)&#123;    for (Integer integer : var) &#123;        System.out.println(integer);    &#125;    return \"success\";&#125;\n\n对象类型属性名必须和参数名相同\nPojo对象12345678public class People &#123;    private String name;    private Integer age;    private List&lt;Account&gt; accounts;    private Map&lt;String, Phone&gt; phoneMap;&#125;\n\n12345public class Phone &#123;    private String name;    private Float price;&#125;\n\n1234public class Account &#123;    private Float money;&#125;\n\n属性绑定12345@RequestMapping(path = \"/object\")public String objectView(People people)&#123;    System.out.println(people);    return \"success\";&#125;\n\n基本类型和String1234567&lt;div class=\"form\"&gt;    &lt;form action=\"bind/object\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"name\" placeholder=\"name\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"age\" placeholder=\"age\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\n对象集合List1234567&lt;div class=\"form\"&gt;    &lt;form action=\"bind/object\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"accounts[0].money\" placeholder=\"account.money\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"accounts[1].money\" placeholder=\"account.money\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\nMap123456789&lt;div class=\"form\"&gt;    &lt;form action=\"bind/object\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"phoneMap['android'].name\" placeholder=\"phone.name\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"phoneMap['android'].price\" placeholder=\"phone.price\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"phoneMap['iphone'].name\" placeholder=\"phone.name\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"phoneMap['iphone'].price\" placeholder=\"phone.price\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\n自定义类型转换SpringMVC对于日期的类型转换只支持2018/8/8格式，不支持2018-8-8格式，此时我们可以自定义类型转换器来对日期做转换。\n类型转换器实现Converter&lt;S, T&gt;接口, S为参数类型，T为目标类型。\n重写convert方法。\n12345678910111213141516171819public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123;    @Override    public Date convert(String s) &#123;        String pattern;        if (s.contains(\"/\"))            pattern = \"yyyy/MM/dd\";        else            pattern = \"yyyy-MM-dd\";        SimpleDateFormat format = new SimpleDateFormat(pattern);        try &#123;            return format.parse(s);        &#125; catch (ParseException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;\n\n注册ConversionService1234567891011121314151617181920212223242526272829&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;context:component-scan base-package=\"controller\"/&gt;    &lt;!--注册类型转换器--&gt;    &lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt;    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;        &lt;property name=\"prefix\" value=\"/\"&gt;&lt;/property&gt;        &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--注册类型转换器--&gt;    &lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt;        &lt;property name=\"converters\"&gt;            &lt;array&gt;                &lt;bean class=\"converter.StringToDateConverter\"&gt;                &lt;/bean&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n异步请求JSON数据绑定必须引入依赖\njackson-core\njackson-annotation\njackson-databind\n\n必须使用@RequestBody注解方法参数\n\n12345@RequestMapping(path = \"/json\")public String jsonView(@RequestBody Phone phone)&#123;    System.out.println(phone);    return \"success\";&#125;\n\n\nServletAPI对象绑定HttpServletRequest\nHttpServletResponse\nHttpSession\n123456@RequestMapping(path = \"/object\")public void servletView(HttpServletResponse response) throws IOException &#123;    response.setContentType(\"text/html;charset=utf-8\");    response.setCharacterEncoding(\"utf-8\");    response.getWriter().write(\"success\");&#125;\n\nHTTP其他相关数据绑定@PathVariable获取路径中占位符的值\nURL中指定占位符\nname指定名称\nrequired指定是否必须\n12345@RequestMapping(path = \"/path/&#123;id&#125;\")public String pathView(@PathVariable(name = \"id\", required = true) Integer id)&#123;    System.out.println(id);    return \"success\";&#125;\n@RequestHeader获取请求头\nname指定名称\nrequired指定是否必须\n12345@RequestMapping(path = \"/header\")public String headerView(@RequestHeader(name = \"Accept\", required = true) String contentType)&#123;    System.out.println(contentType);    return \"success\";&#125;\n@CookieValue获取cookie\nname指定名称\nrequired指定是否必须\n12345@RequestMapping(path = \"/cookie\")public String cookieView(@CookieValue(name = \"JSESSIONID\", required = true) String jsessionId)&#123;    System.out.println(jsessionId);    return \"success\";&#125;\n\n\n域参数绑定利用如下一些API我们可以利用Spring提供的抽象，不依赖ServletAPI来将参数绑定到requestScope和sessionScope中。\nModelMap用于将参数绑定到requestScope中。\n1234@RequestMapping(path = \"/modelmap\")public void modelMapView(ModelMap map) throws IOException &#123;    map.addAttribute(\"date\", new Date());&#125;\n\n@ModelAttibute加在方法上被注解的方法将会在所有mapping方法执行前执行。可用于在所有mapping方法执行前执行对ModelMap进行参数绑定，后续的mapping方法可从ModelMap中取出对应参数。\n被注解的方法可以绑定mapping方法能绑定的参数。\n带返回值--直接返回\n默认以返回值的类名（首字母小写）作为key，将返回值存入ModelMap中。\n12345678910// 相当于modelMap.addAttribute(\"string\", \"123\")@ModelAttributepublic String beforeAll()&#123;    return \"123\";&#125;// 相当于modelMap.addAttribute(\"people\", new People())@ModelAttributepublic People beforeAll()&#123;    return new People();&#125;\n\n带返回值--指定key返回\n在注解中指明。\n1234@ModelAttribute(\"str\")public String beforeAll()&#123;    return \"123\";&#125;\n\n不带返回值--绑定到ModelMap\n直接绑定到ModelMap中。\n1234@ModelAttributepublic void beforeAll(ModelMap map)&#123;    map.addAttribute(\"str\", \"123\");&#125;\n\n加在参数上用于取出存在ModelMap中的参数。\n12345@ModelAttribute(\"str\")public String getModelMapParam(@ModelAttribute(\"str\") msg)&#123;    System.out.println(msg);    return \"success\";&#125;\n\n@SessionAttributes将ModelMap中的参数绑定到sessionScope中，用于在多个请求之间传递参数\n绑定过程在mapping方法执行过后进行\n使用@SessionAttribute注释方法参数可取出sessionScope中的参数\n1234567891011121314151617@Controller@RequestMapping(\"/bind\")@SessionAttributes(&#123;\"date\"&#125;)public class BindController &#123;    @RequestMapping(path = \"/getmodelmap\")    public String getModelMapView(@SessionAttribute(\"date\") Date date)&#123;        System.out.println(date);        return \"success\";    &#125;    @RequestMapping(path = \"/modelmap\")    public String modelMapView(ModelMap map) throws IOException &#123;        map.addAttribute(\"date\", new Date());        return \"success\";    &#125;&#125;\n","thumbnail":"post/Java/SpringMVC/2-SpringMVC参数绑定/cover.png","plink":"https://beginc.github.io/post/Java/SpringMVC/2-SpringMVC参数绑定/"},{"title":"7-注解开发","date":"2020-01-26T15:43:27.000Z","date_formatted":{"ll":"Jan 26, 2020","L":"01/26/2020","MM-DD":"01-26"},"updated":"2020-02-08T02:35:26.051Z","content":"查找表@Component\n@Repository\n@Service\n@Controller\n@Scope\n@PostConstruct\n@PreDestroy\n@Value\n@Autowired\n@Qualifier\n@Resource\n@Aspect\n@Pointcut\n@Before\n@After\n@AfterReturning\n@AfterThrowing\n@Around\n@Transactional\n@RunWith\n@ContextConfiguration\n@Configuration\n@ComponentScan\n@ComponentScans\n@Bean\n@Import\n@PropertyResource\n@PropertyResources\n@EnableAspectJAutoProxy\n@EnableTransactionManagement\n导入依赖Spring必备依赖\nJavax Annotation API（有些注解需要该包的支持）\n开启包扫描指定要扫描的包，Spring会对当前包以及子包下的类进行扫描，寻找注解。\n123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;context:component-scan base-package=\"controller\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"service\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"dao\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"pojo\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;\n\nBean管理Bean注册@Component\n注册Bean\n可指定id\n若不指定id默认为类名（第一个字母小写）\n123456789101112@Component(\"accountControlller\")public class AccountController &#123;    private AccountService accountService;    public void setAccountService(AccountService accountService) &#123;        this.accountService = accountService;    &#125;    public void transfer() &#123;        accountService.transfer(3, 4, 100);    &#125;&#125;\n\n@Repository\n同@Component，用于注册DAO类\n@Service\n同@Component，用于注册Service类\n@Controller\n同@Component，用于注册Controller类\nBean作用范围@Scope\n指定作用范围\n12345678910111213@Controller(\"accountControlller\")@Scope(\"prototype\")public class AccountController &#123;    private AccountService accountService;    public void setAccountService(AccountService accountService) &#123;        this.accountService = accountService;    &#125;    public void transfer() &#123;        accountService.transfer(3, 4, 100);    &#125;&#125;\n\nBean生命周期方法1234567891011121314151617181920212223@Controller(\"accountControlller\")@Scope(\"prototype\")public class AccountController &#123;    private AccountService accountService;    public void setAccountService(AccountService accountService) &#123;        this.accountService = accountService;    &#125;    public void transfer() &#123;        accountService.transfer(3, 4, 100);    &#125;    @PostConstruct    public void init() &#123;        System.out.println(\"Account Controller Init...\");    &#125;    @PreDestroy    public void destroy() &#123;        System.out.println(\"Account Controller Destroy...\");    &#125;&#125;\n\n@PostConstruct\n创建Bean时调用的方法\n@PreDestroy\n销毁Bean时调用的方法\nBean依赖注入@Value\n用于注入基本类型和String, 可使用SpEL表达式\n123456789101112131415161718192021222324252627@Controller(\"accountControlller\")@Scope(\"prototype\")public class AccountController &#123;    @Value(\"1\")    private int intForTest;        private AccountService accountService;    public void setAccountService(AccountService accountService) &#123;        this.accountService = accountService;    &#125;    public void transfer() &#123;        accountService.transfer(3, 4, 100);    &#125;    @PostConstruct    public void init() &#123;        System.out.println(\"Account Controller Init...\");    &#125;    @PreDestroy    public void destroy() &#123;        System.out.println(\"Account Controller Destroy...\");    &#125;&#125;\n\n@Autowired\n按照类型注入\nIoC容器中能找到唯一对应：直接注入\nIoC容器中能找到多个对应：使用变量名与id匹配注入\n123456789101112131415161718192021222324252627@Controller(\"accountControlller\")@Scope(\"prototype\")public class AccountController &#123;    @Value(\"1\")    private int intForTest;    @Autowired    private AccountService accountService;    public void setAccountService(AccountService accountService) &#123;        this.accountService = accountService;    &#125;    public void transfer() &#123;        accountService.transfer(3, 4, 100);    &#125;    @PostConstruct    public void init() &#123;        System.out.println(\"Account Controller Init...\");    &#125;    @PreDestroy    public void destroy() &#123;        System.out.println(\"Account Controller Destroy...\");    &#125;&#125;\n\n@Qualifier\n必须和@Autowired同时使用，在按照@Autowired按类型注入的基础上，再按照id注入\n1234567891011121314151617181920212223242526272829@Controller(\"accountControlller\")@Scope(\"prototype\")public class AccountController &#123;    @Value(\"1\")    private int intForTest;        @Autowired    @Qualifier(\"accountService\")    private AccountService accountService;    public void setAccountService(AccountService accountService) &#123;        this.accountService = accountService;    &#125;    public void transfer() &#123;        accountService.transfer(3, 4, 100);    &#125;    @PostConstruct    public void init() &#123;        System.out.println(\"Account Controller Init...\");    &#125;    @PreDestroy    public void destroy() &#123;        System.out.println(\"Account Controller Destroy...\");    &#125;&#125;\n\n@Resource\n按照id注入，要写name属性\n12345678910111213141516@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123;    @Resource(name = \"accountDao\")    private AccountDao accountDao;    public void setAccountDao(AccountDao accountDao) &#123;        this.accountDao = accountDao;    &#125;    @Override    public void transfer(int src, int dest, int num) &#123;        accountDao.in(dest, num);        int i = 1 / 0;        accountDao.out(src, num);    &#125;&#125;\n\n\nAOP开启AOP注解支持12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;context:component-scan base-package=\"controller\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"service\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"dao\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"pojo\"&gt;&lt;/context:component-scan&gt;        &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;\n\n配置切面类@Aspect\n12345@Aspect@Componentpublic class Logger &#123;&#125;\n\n配置切入点@Pointcut\n方法名为切入点名称\n12345678@Aspect@Componentpublic class Logger &#123;    @Pointcut(\"execution(public void service.impl.AccountServiceImpl.transfer(int, int, int))\")    void accountServicePointcut()&#123;&#125;;&#125;\n\n配置通知引用切入点需要加入()\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Aspect@Componentpublic class Logger &#123;    @Pointcut(\"execution(public void service.impl.AccountServiceImpl.transfer(int, int, int))\")    void accountServicePointcut()&#123;&#125;;    @Before(\"accountServicePointcut()\")    void before() &#123;        System.out.println(\"[Before]: 记录日志\");    &#125;    @After(\"accountServicePointcut()\")    void after() &#123;        System.out.println(\"[After]: 记录日志\");    &#125;    @AfterReturning(\"accountServicePointcut()\")    void afterReturning() &#123;        System.out.println(\"[AfterReturning]: 记录日志\");    &#125;    @AfterThrowing(\"accountServicePointcut()\")    void afterThrowing() &#123;        System.out.println(\"[After-Throwing]: 记录日志\");    &#125;    @Around(\"accountServicePointcut()\")    Object around(ProceedingJoinPoint proceedingJoinPoint)&#123;        try&#123;            // 前置            before();            Object[] args = proceedingJoinPoint.getArgs();            // 方法调用            Object returnVal = proceedingJoinPoint.proceed(args);            // 后置            afterReturning();            return returnVal;        &#125; catch (Throwable throwable) &#123;            // 异常            afterThrowing();            throwable.printStackTrace();        &#125; finally &#123;            // 最终            after();        &#125;        return null;    &#125;&#125;\n\n@Before\n前置通知\n@After\n最终通知\n@AfterReturning\n后置通知\n@AfterThrowing\n异常通知\n@Around\n环绕通知\n事务管理开启事务控制注解支持需要传入transactionManager事务管理器\n12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;context:component-scan base-package=\"controller\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"service\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"dao\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"pojo\"&gt;&lt;/context:component-scan&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC&amp;amp;useSSL=false\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"LQ18851195070\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;tx:annotation-driven transaction-manager=\"transactionManager\"&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt;\n\n注解配置事务@Transactional\n可配置在类上应用到所有方法，也可以配置在方法上单独配置\n1234567891011121314151617@Service(\"accountService\")@Transactional(isolation = Isolation.REPEATABLE_READ, propagation = Propagation.REQUIRED, readOnly = false, timeout = -1)public class AccountServiceImpl implements AccountService &#123;    @Resource(name = \"accountDao\")    private AccountDao accountDao;    public void setAccountDao(AccountDao accountDao) &#123;        this.accountDao = accountDao;    &#125;    @Override    public void transfer(int src, int dest, int num) &#123;        accountDao.in(dest, num);        int i = 1 / 0;        accountDao.out(src, num);    &#125;&#125;\n\n测试Spring提供对Junit的支持，可注入依赖的属性。\n需要引入Spring Test包\n12345678910111213141516@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = Config.class)public class Test01 &#123;    @Autowired    private AccountController controller;    public void setController(AccountController controller) &#123;        this.controller = controller;    &#125;    @Test    public void test()&#123;        controller.transfer();    &#125;&#125;\n\n@RunWith\n指定Runner\n@ContextConfiguration\n指定配置位置\n可指定配置文件\n可指定配置类\n注解类在前面的注解开发中我们都是使用xml + annotation组合的，从Spring4.0开始，我们可完全抛弃xml使用注解类进行配置。\n@Configuration\n表明该类是配置类\n1234@Configurationpublic class Config &#123;&#125;\n\n@ComponentScans\n相当于多个&lt;context:component-scan base-package=&quot;&quot;&gt;&lt;/context:component-scan&gt;\n123456789@Configuration@ComponentScans(&#123;        @ComponentScan(\"dao\"),        @ComponentScan(\"service\"),        @ComponentScan(\"controller\"),        @ComponentScan(\"pojo\"),&#125;)public class Config &#123;&#125;\n\n@Bean\n将当前方法的返回值注册到IoC容器中\n可指定id\nBean的id默认为方法名\n@Qualifier指定方法参数的id，会从IoC容器中获取\n参数默认id为形参名\n12345678910111213141516171819202122232425262728@Configuration@ComponentScans(&#123;        @ComponentScan(\"dao\"),        @ComponentScan(\"service\"),        @ComponentScan(\"controller\"),        @ComponentScan(\"pojo\"),&#125;)public class Config &#123;    @Bean(\"dataSource\")    public DataSource dataSource()&#123;        DriverManagerDataSource dataSource = new DriverManagerDataSource();        dataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\");        dataSource.setUrl(\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC&amp;useSSL=false\");        dataSource.setUsername(\"root\");        dataSource.setPassword(\"LQ18851195070\");        return dataSource;    &#125;    @Bean(\"jdbcTemplate\")    public JdbcTemplate jdbcTemplate(@Qualifier(\"dataSource\") DataSource dataSource)&#123;        return new JdbcTemplate(dataSource);    &#125;    @Bean(\"transactionManager\")    public PlatformTransactionManager transactionManager(@Qualifier(\"dataSource\") DataSource dataSource)&#123;        return new DataSourceTransactionManager(dataSource);    &#125;&#125;\n\n@Import\n有时候我们希望将不同领域的注解放到不同的类中，这时候需要一个主配置类，并导入子配置类。\n123456789101112131415161718192021@Configurationpublic class JdbcConfig &#123;    @Bean(\"dataSource\")    public DataSource dataSource()&#123;        DriverManagerDataSource dataSource = new DriverManagerDataSource();        dataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\");        dataSource.setUrl(\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC&amp;useSSL=false\");        dataSource.setUsername(\"root\");        dataSource.setPassword(\"LQ18851195070\");        return dataSource;    &#125;    @Bean(\"jdbcTemplate\")    public JdbcTemplate jdbcTemplate(@Qualifier(\"dataSource\") DataSource dataSource)&#123;        return new JdbcTemplate(dataSource);    &#125;    @Bean(\"transactionManager\")    public PlatformTransactionManager transactionManager(@Qualifier(\"dataSource\") DataSource dataSource)&#123;        return new DataSourceTransactionManager(dataSource);    &#125;&#125;\n\n123456789101112@Configuration@ComponentScans(&#123;        @ComponentScan(\"dao\"),        @ComponentScan(\"service\"),        @ComponentScan(\"controller\"),        @ComponentScan(\"pojo\"),&#125;)@Import(JdbcConfig.class)public class Config &#123;&#125;\n\n@PropertyResources\n我们还希望将某些初始化参数，如JDBC的一些参数，放到配置文件中，从配置文件中读取，而不是写死在程序里，这时候需要导入相关的配置文件。\n1234jdbc.driver&#x3D;com.mysql.cj.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test1?serverTimezone&#x3D;UTC&amp;useSSL&#x3D;falsejdbc.username&#x3D;rootjdbc.password&#x3D;LQ18851195070\n\n\n123456789101112131415161718192021222324252627282930313233343536@Configuration@PropertySources(        @PropertySource(\"classpath:jdbc.properties\"))public class JdbcConfig &#123;    @Value(\"$&#123;jdbc.driver&#125;\")    private String driverClassName;    @Value(\"$&#123;jdbc.url&#125;\")    private String url;    @Value(\"$&#123;jdbc.username&#125;\")    private String username;    @Value(\"$&#123;jdbc.password&#125;\")    private String password;    @Bean(\"dataSource\")    public DataSource dataSource() &#123;        DriverManagerDataSource dataSource = new DriverManagerDataSource();        dataSource.setDriverClassName(\"\");        dataSource.setUrl(\"\");        dataSource.setUsername(\"\");        dataSource.setPassword(\"\");        return dataSource;    &#125;    @Bean(\"jdbcTemplate\")    public JdbcTemplate jdbcTemplate(@Qualifier(\"dataSource\") DataSource dataSource) &#123;        return new JdbcTemplate(dataSource);    &#125;    @Bean(\"transactionManager\")    public PlatformTransactionManager transactionManager(@Qualifier(\"dataSource\") DataSource dataSource) &#123;        return new DataSourceTransactionManager(dataSource);    &#125;&#125;\n\n@EnableAspectJAutoProxy\n开启这个才能支持注解AOP\n1234567891011121314@Configuration@ComponentScans(&#123;        @ComponentScan(\"dao\"),        @ComponentScan(\"service\"),        @ComponentScan(\"controller\"),        @ComponentScan(\"pojo\"),        @ComponentScan(\"aop\")&#125;)@Import(JdbcConfig.class)@EnableAspectJAutoProxypublic class Config &#123;&#125;\n\n@EnableTransactionManagement\n开启这个才能支持注解事务控制\n123456789101112131415@Configuration@ComponentScans(&#123;        @ComponentScan(\"dao\"),        @ComponentScan(\"service\"),        @ComponentScan(\"controller\"),        @ComponentScan(\"pojo\"),        @ComponentScan(\"aop\")&#125;)@Import(JdbcConfig.class)@EnableAspectJAutoProxy@EnableTransactionManagementpublic class Config &#123;&#125;","thumbnail":"post/Java/Spring/7-注解开发/cover.png","plink":"https://beginc.github.io/post/Java/Spring/7-注解开发/"},{"title":"6-事务管理","date":"2020-01-26T15:43:05.000Z","date_formatted":{"ll":"Jan 26, 2020","L":"01/26/2020","MM-DD":"01-26"},"updated":"2020-02-08T02:35:21.865Z","content":"事务逻辑上的一组操作，组成这组操作的各个单元要么全部成功，要么全部失败。\n事务的特性Atomicity原子性。事务里的一组操作要么全部成功，要么全部失败。\n转账事务：\n    1. A账户减少100块钱\n    2. B账户增加100块钱1和2要么全部成功，要么全部失败，不能是A账户减少了100块钱，而B账户却没有增加100块钱。\nConsistency一致性。事务执行后，数据保持完整性，符合逻辑。\nIsolation隔离性。两个事务的执行应该不会互相影响。\nDurability持久性。事务完成后，结果被持久化到数据库。\nACID的实现Atomicity事务成功commit\n事务失败rollback\nConsistency通过原子性 + 隔离性实现。\nIsolation使用事务的隔离级别来保证。\n事务之间的影响脏读\n一个事务读到了另一个事务未提交的数据。\n转账事务：\n    1. A账户减少100块钱\n    2. B账户增加100块钱\n\n读账户事务：\n    1. 读取A账户的余额若转账事务执行到1，此时数据被读账户事务读取，但转账事务失败，发生了回滚，此时读账户事务读到的数据不再与数据库一致。\n不可重复读\n一个事务读到了另一个事务更新的数据，导致一个事务中前后多次查询结果不一致。\n读账户事务：\n    1. 读取A账户的余额（此时为1000）\n\n转账事务：\n    1. A账户减少100块钱（变为900）\n    2. B账户增加100块钱\n\n读账户事务：\n    2. 读取A账户的余额（此时为900）幻读\n一个事务读到了另一个事务插入的数据，导致一个事务中前后多次查询结果不一致。\n读账户事务：\n    1. 读取当前账户数量（10）\n\n添加账户事务：\n    1. 添加一个账户（11）\n\n读账户事务：\n    2. 读取当前账户数量（11）事务的隔离级别为了消除事务间的影响，提出了事务的隔离级别。\nRead Uncommitted\n可读未提交的数据，不能解决任何问题。\nRead Committed\n只能读已提交的数据。可解决脏读。\nRepetable Read\n一个事务开始了读操作后，不允许其他事务再进行修改操作。可解决不可重复读。\nSerialiable\n所有事务必须串行执行，可解决所有问题，但效率很低。\nD(Durability)通过事务日志来实现。\nSpring声明式事务配置事务管理器PlatformTransactionManager有两个实现类\nDataSourceTransactionManager使用JDBC管理事务\nHibernateTransactionManager使用Hibernate管理事务\n1234&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;    &lt;!--注入数据源--&gt;    &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;\n\n配置事务通知需要引入tx约束\n需要注入事务管理器\ntx:method中name指定方法名\ntx:method中isolation指定隔离级别\ntx:method中propagation指定传播行为\ntx:method中read-only指定是否为只读事务\ntx:method中timeout指定事务超时时间，若超过该时间事务还未完成则事务自动回滚，单位为秒\ntx:method中rollback-for与no-rollback-for控制事务回滚\n123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC&amp;amp;useSSL=false\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"LQ18851195070\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;tx:advice id=\"transactionAdvice\" transaction-manager=\"transactionManager\"&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" timeout=\"-1\"/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;&lt;/beans&gt;\n\n配置事务AOP切面将通知应用到业务层方法上。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC&amp;amp;useSSL=false\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"LQ18851195070\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;tx:advice id=\"transactionAdvice\" transaction-manager=\"transactionManager\"&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" timeout=\"-1\"/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id=\"serviceImplPointcut\" expression=\"execution(public void service.impl.AccountServiceImpl.transfer(int, int, int))\"/&gt;        &lt;aop:advisor advice-ref=\"transactionAdvice\" pointcut-ref=\"serviceImplPointcut\"&gt;&lt;/aop:advisor&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\n事务的传播行为我们的事务目前加在Service中的方法上，但当业务逻辑特别复杂时，可能出现业务层方法互相调用的情况，这时候需要需要使用传播行为来管理两个方法间的事务关系。\n1234567891011public MockService&#123;  public void A()&#123;    doSomethingA();  &#125;  public void B()&#123;    A()    doSomethingB();  &#125;&#125;\n\n保证在同一事务中PROPOGATION_REQUIRED\n若A中有事务，则使用A中的事务将B方法全部包括起来\n若A中无事务，则创建一个新的事务，将B方法全部包括起来\nPROPOGATION_SUPPORTS\n若A中有事务，则使用A中的事务将B方法全部包括起来\n若A中无事务，则B方法不使用事务\nPROPOGATION_MANDATORY\n若A中有事务，则使用A中的事务将B方法全部包括起来\n若A中无事务，抛出异常\n保证不在同一事务中PROPOGATION_REQUIRE_NEW\n若A中有事务，将A的事务暂停，创建一个新事务，只包括B本身的操作doSomethingB()\n若A中无事务，创建一个新事务，只包括B本身的操作doSomethingB()\nPROPOGATION_NOT_SUPPORTS\n若A中有事务，将A的事务暂停，不使用事务管理。\nPROPOGATION_NEVER\n如果A中有事务，抛出异常。\n嵌套事务PROPOGATION_NESTED\n若A中有事务，按照A的事务执行，执行完后，设置一个保存点\n执行B中的操作doSomethingB()无异常，执行成功\n有异常，可以回滚到初始状态，也可以回滚到保存点\n\n事务回滚控制Spring中默认只有当事务执行时发生了RuntimeException或Error时会发生事务回滚，因此在发生了非运行期异常时，不会发生回滚。\n回滚控制使用rollback-for指定遇到什么类型的异常时发生回滚。\n123456&lt;tx:advice id=\"transactionAdvice\" transaction-manager=\"transactionManager\"&gt;    &lt;tx:attributes&gt;        &lt;!--发生所有异常时都回滚--&gt;        &lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" timeout=\"-1\" no-rollback-for=\"Exception\"/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;\n\n不回滚控制使用no-rollback-for指定遇到什么类型的异常时不发生回滚。\n12345&lt;tx:advice id=\"transactionAdvice\" transaction-manager=\"transactionManager\"&gt;    &lt;tx:attributes&gt;        &lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" timeout=\"-1\" no-rollback-for=\"ArithmeticException\"/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;","thumbnail":"post/Java/Spring/6-事务管理/cover.png","plink":"https://beginc.github.io/post/Java/Spring/6-事务管理/"},{"title":"5-JdbcTemplate","date":"2020-01-26T14:03:32.000Z","date_formatted":{"ll":"Jan 26, 2020","L":"01/26/2020","MM-DD":"01-26"},"updated":"2020-01-27T02:58:36.106Z","content":"引入依赖Spring Context\nSpring JDBC\nSpring TX\nAspectJ Weaver\nMySQL 驱动\nJunit\n12345678910111213141516171819202122232425262728&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.9.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n创建表1234CREATE TABLE account(  id INT PRIMARY KEY AUTO_INCREMENT,  money INT NOT NULL DEFAULT 0)\n\nJdbcTemplate配置配置数据源12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"LQ18851195070\"&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n配置JdbcTemplate注入DataSource\n1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"LQ18851195070\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n注入JdbcTemplate到DAO层1234567891011121314151617public class AccountDaoImpl implements AccountDao &#123;    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    @Override    public void in(int id, int num) &#123;        System.out.println(\"[Account\" + id + \"]: \" + \"收了\" + num + \"元钱\");    &#125;    @Override    public void out(int id, int num) &#123;        System.out.println(\"[Account\" + id + \"]: \" + \"花了\" + num + \"元钱\");    &#125;&#125;\n\n123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;        &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"LQ18851195070\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nJdbcTemplate使用建立Account类\n123456789101112131415161718192021222324252627282930313233343536public class Account &#123;    private Integer id;    private Integer money;    public Account(Integer id, Integer money) &#123;        this.id = id;        this.money = money;    &#125;    public Account() &#123;    &#125;    @Override    public String toString() &#123;        return \"Account&#123;\" +                \"id=\" + id +                \", money=\" + money +                '&#125;';    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public Integer getMoney() &#123;        return money;    &#125;    public void setMoney(Integer money) &#123;        this.money = money;    &#125;&#125;\n\n增增加一个账户\n使用`update`方法，带可变参数123456789101112public class AccountDaoImpl implements AccountDao &#123;    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    @Override    public void insert(Account account) &#123;        jdbcTemplate.update(\"insert into account (money) values (?)\", account.getMoney());    &#125;&#125;\n\n删删除一个账户\n使用`update`方法，带可变参数123456789101112public class AccountDaoImpl implements AccountDao &#123;    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    @Override    public void delete(int id) &#123;        jdbcTemplate.update(\"delete from account where id = ?\", id);    &#125;&#125;\n\n改账户收钱\n\n账户花钱\n  使用update方法，带可变参数\n\n123456789101112public class AccountDaoImpl implements AccountDao &#123;    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    @Override    public void out(int id, int num) &#123;        jdbcTemplate.update(\"update account set money = money - ? where id = ?\", id, num);    &#125;&#125;\n\n查查询一个账户\n查询所有账户\n查询用户数量\n对象封装方式一\n使用自带的BeanPropertyRowMapper对象，自动封装。\n对象封装方式二\n使用实现RowMapper接口的对象，手动封装。\n12345678910111213141516171819202122232425262728293031323334public class AccountDaoImpl implements AccountDao &#123;    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    @Override    public Account find(int id) &#123;        List&lt;Account&gt; account = jdbcTemplate.query(\"select * from account where id = ?\", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id);        return account.size() != 0 ? account.get(0) : null;    &#125;    @Override    public List&lt;Account&gt; findAll() &#123;        List&lt;Account&gt; account = jdbcTemplate.query(\"select * from account\", new RowMapper&lt;Account&gt;() &#123;            @Override            public Account mapRow(ResultSet resultSet, int i) throws SQLException &#123;                Account account = new Account();                account.setId(resultSet.getInt(1));                account.setMoney(resultSet.getInt(2));                return account;            &#125;        &#125;);        return account;    &#125;    @Override    public int findAccountNum() &#123;        int accountNum = jdbcTemplate.queryForObject(\"select count(1) from account\", Integer.class);        return accountNum;    &#125;&#125;\n\nJdbcDaoSupport若继承JdbcDaoSupport类，则只需注入dataSource对象，注入时会自动创建jdbcTemplate对象。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123;    @Override    public void insert(Account account) &#123;        getJdbcTemplate().update(\"insert into account (money) values (?)\", account.getMoney());    &#125;    @Override    public void delete(int id) &#123;        getJdbcTemplate().update(\"delete from account where id = ?\", id);    &#125;    @Override    public void in(int id, int num) &#123;        getJdbcTemplate().update(\"update account set money = money + ? where id = ?\", id, num);    &#125;    @Override    public void out(int id, int num) &#123;        getJdbcTemplate().update(\"update account set money = money - ? where id = ?\", id, num);    &#125;    @Override    public Account find(int id) &#123;        List&lt;Account&gt; account = getJdbcTemplate().query(\"select * from account where id = ?\", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id);        return account.size() != 0 ? account.get(0) : null;    &#125;    @Override    public List&lt;Account&gt; findAll() &#123;        List&lt;Account&gt; account = getJdbcTemplate().query(\"select * from account\", new RowMapper&lt;Account&gt;() &#123;            @Override            public Account mapRow(ResultSet resultSet, int i) throws SQLException &#123;                Account account = new Account();                account.setId(resultSet.getInt(1));                account.setMoney(resultSet.getInt(2));                return account;            &#125;        &#125;);        return account;    &#125;    @Override    public int findAccountNum() &#123;        int accountNum = getJdbcTemplate().queryForObject(\"select count(1) from account\", Integer.class);        return accountNum;    &#125;&#125;\n\n1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC&amp;amp;useSSL=false\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"LQ18851195070\"&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;","thumbnail":"post/Java/Spring/5-JdbcTemplate/cover.png","plink":"https://beginc.github.io/post/Java/Spring/5-JdbcTemplate/"},{"title":"4-AOP","date":"2020-01-26T12:35:27.000Z","date_formatted":{"ll":"Jan 26, 2020","L":"01/26/2020","MM-DD":"01-26"},"updated":"2020-02-08T02:35:13.773Z","content":"创建Maven项目编译设置12345678910111213141516171819202122232425&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;spring-02&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                    &lt;source&gt;11&lt;/source&gt;                    &lt;target&gt;11&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n引入依赖Spring Context\nAspectJ Weaver\nJunit\n123456789101112131415161718&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.9.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n创建applicationContext.xml要引入aop约束\n12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;/beans&gt;\n\n模拟Web MVC三层DAO1234567891011public class AccountDaoImpl implements AccountDao &#123;    @Override    public void in(int id, int num) &#123;        System.out.println(\"[Account\" + id + \"]: \" + \"收了\" + num + \"元钱\");    &#125;    @Override    public void out(int id, int num) &#123;        System.out.println(\"[Account\" + id + \"]: \" + \"花了\" + num + \"元钱\");    &#125;&#125;\n\nService12345678910111213public class AccountServiceImpl implements AccountService &#123;    private AccountDao accountDao;    public void setAccountDao(AccountDao accountDao) &#123;        this.accountDao = accountDao;    &#125;    @Override    public void transfer(int src, int dest, int num) &#123;        accountDao.in(dest, num);        accountDao.out(src, num);    &#125;&#125;\n\nController1234567891011public class AccountController &#123;    private AccountService accountService;    public void setAccountService(AccountService accountService) &#123;        this.accountService = accountService;    &#125;    public void transfer() &#123;        accountService.transfer(1, 2, 100);    &#125;&#125;\n\nAOP基本概念Joinpoint接入点可以被拦截的点，在Spring中指被增强类的方法。\nPointcut切入点Joinpoint中被增强的点，在Spring中指被增强的方法。\nAdvice通知即对切入点进行的增强。\n前置通知\n后置通知\n异常通知\n最终通知\n环绕通知\nIntroduction引介是一种特殊的通知，可以在不修改类的代码的前提下，动态地为其添加一些方法或属性。\nTarget目标对象代理的目标对象。\nWeaving织入把增强引用到目标对象，创建代理对象的过程。\nProxy代理目标对象织入增强后产生的代理对象。\nAspect切面多个切入点和多个通知的结合。\nAOP需求在transfer转账之前记录日志（前置通知）\n在transfer转账之后记录日志（后置通知）\n在transfer转账发生异常时记录日志（异常通知）\n在transfer转账不管正不正常执行都记录日志（最终通知）\n编写增强类12345678910111213141516171819public class Logger &#123;    void before() &#123;        System.out.println(\"[Before]: 记录日志\");    &#125;    void after() &#123;        System.out.println(\"[After]: 记录日志\");    &#125;    void afterReturning() &#123;        System.out.println(\"[AfterReturning]: 记录日志\");    &#125;    void afterThrowing() &#123;        System.out.println(\"[After-Throwing]: 记录日志\");    &#125;&#125;\n\n配置AOP增强类和被增强类交给Spring管理\n配置切入点\n配置切面\n12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--将增强类交给Spring管理--&gt;    &lt;bean id=\"logger\" class=\"aop.Logger\"&gt;    &lt;/bean&gt;    &lt;!--aop配置--&gt;    &lt;aop:config&gt;        &lt;!--切入点配置--&gt;        &lt;aop:pointcut id=\"accountServicePointcut\" expression=\"execution(public void service.impl.AccountServiceImpl.transfer(int, int, int))\"/&gt;        &lt;!--增强配置--&gt;        &lt;aop:aspect id=\"loggerAdvice\" ref=\"logger\"&gt;            &lt;aop:before method=\"before\" pointcut-ref=\"accountServicePointcut\"&gt;&lt;/aop:before&gt;            &lt;aop:after method=\"after\" pointcut-ref=\"accountServicePointcut\"&gt;&lt;/aop:after&gt;            &lt;aop:after-returning method=\"afterReturning\" pointcut-ref=\"accountServicePointcut\"&gt;&lt;/aop:after-returning&gt;            &lt;aop:after-throwing method=\"afterThrowing\" pointcut-ref=\"accountServicePointcut\"&gt;&lt;/aop:after-throwing&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\n切入点表达式格式\nexecution(访问修饰符 返回值类型 包名.包名.类名.方法名(参数类型，参数类型))访问修饰符\n可以省略\n返回值\n可使用通配符*\n包名\ncn.edu.njust.service.impl直接全写出来\ncn.edu.njust.*.*通配符\ncn.edu.njust..当前包及其子包\n类名\n可使用通配符*\n方法名\n可使用通配符*\n参数名\n(int, int)直接写出来\n(*, *)通配符匹配任意类型，但必须有参数\n(..)匹配任意参数，可以没有参数\n通知aop:before前置通知\naop:after最终通知\naop:after-returning后置通知\naop:after-throwing异常通知\naop:around环绕通知\n环绕通知使用环绕通知可编程式增强方法。现在使用环绕通知实现上述需求。\n环绕通知方法\n12345678910111213141516171819202122232425262728293031323334353637383940public class Logger &#123;    void before() &#123;        System.out.println(\"[Before]: 记录日志\");    &#125;    void after() &#123;        System.out.println(\"[After]: 记录日志\");    &#125;    void afterReturning() &#123;        System.out.println(\"[AfterReturning]: 记录日志\");    &#125;    void afterThrowing() &#123;        System.out.println(\"[After-Throwing]: 记录日志\");    &#125;    Object around(ProceedingJoinPoint proceedingJoinPoint)&#123;        try&#123;            // 前置            before();            Object[] args = proceedingJoinPoint.getArgs();            // 方法调用            Object returnVal = proceedingJoinPoint.proceed(args);            // 后置            afterReturning();            return returnVal;        &#125; catch (Throwable throwable) &#123;            // 异常            afterThrowing();            throwable.printStackTrace();        &#125; finally &#123;            // 最终            after();        &#125;        return null;    &#125;&#125;\n\n环绕通知配置\n12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--将增强类交给Spring管理--&gt;    &lt;bean id=\"logger\" class=\"aop.Logger\"&gt;    &lt;/bean&gt;    &lt;!--aop配置--&gt;    &lt;aop:config&gt;        &lt;!--切入点配置--&gt;        &lt;aop:pointcut id=\"accountServicePointcut\" expression=\"execution(public void service.impl.AccountServiceImpl.transfer(int, int, int))\"/&gt;        &lt;!--增强配置--&gt;        &lt;aop:aspect id=\"loggerAdvice\" ref=\"logger\"&gt;            &lt;aop:around method=\"around\" pointcut-ref=\"accountServicePointcut\"&gt;&lt;/aop:around&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;","thumbnail":"post/Java/Spring/4-AOP/cover.png","plink":"https://beginc.github.io/post/Java/Spring/4-AOP/"},{"title":"3-Bean依赖注入","date":"2020-01-25T14:21:56.000Z","date_formatted":{"ll":"Jan 25, 2020","L":"01/25/2020","MM-DD":"01-25"},"updated":"2020-01-25T15:14:46.175Z","content":"建立测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class DITest &#123;    private int basic;    private String string;    private Date ref;    private int[] array;    private List&lt;Integer&gt; list;    private Set&lt;Integer&gt; set;    private Map&lt;String, Integer&gt; map;    private Properties prop;    public DITest(int basic, String string, Date ref, int[] array, List&lt;Integer&gt; list, Set&lt;Integer&gt; set, Map&lt;String, Integer&gt; map, Properties prop) &#123;        this.basic = basic;        this.string = string;        this.ref = ref;        this.array = array;        this.list = list;        this.set = set;        this.map = map;        this.prop = prop;    &#125;    public DITest() &#123;    &#125;    @Override    public String toString() &#123;        return \"DITest&#123;\" +                \"basic=\" + basic +                \", string='\" + string + '\\'' +                \", ref=\" + ref +                \", array=\" + Arrays.toString(array) +                \", list=\" + list +                \", set=\" + set +                \", map=\" + map +                \", prop=\" + prop +                '&#125;';    &#125;    public void setBasic(int basic) &#123;        this.basic = basic;    &#125;    public void setString(String string) &#123;        this.string = string;    &#125;    public void setRef(Date ref) &#123;        this.ref = ref;    &#125;    public void setArray(int[] array) &#123;        this.array = array;    &#125;    public void setList(List&lt;Integer&gt; list) &#123;        this.list = list;    &#125;    public void setSet(Set&lt;Integer&gt; set) &#123;        this.set = set;    &#125;    public void setMap(Map&lt;String, Integer&gt; map) &#123;        this.map = map;    &#125;    public void setProp(Properties prop) &#123;        this.prop = prop;    &#125;&#125;\n\n注入方式构造函数注入Spring调用带参构造函数，传入参数来进行依赖注入。\n123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"t1\" class=\"pojo.DITest\"&gt;        &lt;constructor-arg index=\"0\" value=\"1\"/&gt;        &lt;constructor-arg type=\"java.lang.String\" value=\"String\"/&gt;        &lt;constructor-arg name=\"string\" value=\"0\"/&gt;        &lt;!--以下属性省略--&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nIndex注入按构造函数参数列表参数顺序注入（从0开始）。\nType注入按构造函数参数列表中参数的类型注入。\nName注入按构造函数参数列表中参数的名称注入。\nSetter注入Spring调用默认构造函数实例化对象，再通过属性的Setter方法来注入依赖。\n12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"t1\" class=\"pojo.DITest\"&gt;        &lt;property name=\"basic\" value=\"1\"/&gt;        &lt;!--以下属性省略--&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n注入类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"date\" class=\"java.util.Date\"&gt;&lt;/bean&gt;    &lt;bean id=\"testBean\" class=\"pojo.DITest\"&gt;        &lt;property name=\"basic\" value=\"1\"&gt;&lt;/property&gt;        &lt;property name=\"string\" value=\"str\"&gt;&lt;/property&gt;        &lt;property name=\"ref\" ref=\"date\"&gt;&lt;/property&gt;        &lt;property name=\"array\"&gt;            &lt;array&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;        &lt;property name=\"list\"&gt;            &lt;list&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;property name=\"set\"&gt;            &lt;set&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/set&gt;        &lt;/property&gt;        &lt;property name=\"map\"&gt;            &lt;map&gt;                &lt;entry key=\"1\" value=\"1\"/&gt;                &lt;entry key=\"2\"&gt;                    &lt;value&gt;2&lt;/value&gt;                &lt;/entry&gt;                &lt;entry key=\"3\" value=\"3\"/&gt;            &lt;/map&gt;        &lt;/property&gt;        &lt;property name=\"prop\"&gt;            &lt;props&gt;                &lt;prop key=\"1\"&gt;1&lt;/prop&gt;                &lt;prop key=\"2\"&gt;2&lt;/prop&gt;                &lt;prop key=\"3\"&gt;3&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n基本类型和String用value指定。\n对象类型用ref引用。\n集合类型Array1234567&lt;property name=\"array\"&gt;    &lt;array&gt;        &lt;value&gt;1&lt;/value&gt;        &lt;value&gt;2&lt;/value&gt;        &lt;value&gt;3&lt;/value&gt;    &lt;/array&gt;&lt;/property&gt;\nList1234567&lt;property name=\"list\"&gt;    &lt;list&gt;        &lt;value&gt;1&lt;/value&gt;        &lt;value&gt;2&lt;/value&gt;        &lt;value&gt;3&lt;/value&gt;    &lt;/list&gt;&lt;/property&gt;\nSet1234567&lt;property name=\"set\"&gt;    &lt;set&gt;        &lt;value&gt;1&lt;/value&gt;        &lt;value&gt;2&lt;/value&gt;        &lt;value&gt;3&lt;/value&gt;    &lt;/set&gt;&lt;/property&gt;\nMap123456789&lt;property name=\"map\"&gt;    &lt;map&gt;        &lt;entry key=\"1\" value=\"1\"/&gt;        &lt;entry key=\"2\"&gt;            &lt;value&gt;2&lt;/value&gt;        &lt;/entry&gt;        &lt;entry key=\"3\" value=\"3\"/&gt;    &lt;/map&gt;&lt;/property&gt;\n\nProperties1234567&lt;property name=\"prop\"&gt;    &lt;props&gt;        &lt;prop key=\"1\"&gt;1&lt;/prop&gt;        &lt;prop key=\"2\"&gt;2&lt;/prop&gt;        &lt;prop key=\"3\"&gt;3&lt;/prop&gt;    &lt;/props&gt;&lt;/property&gt;\n\n空123&lt;property name=\"prop\"&gt;    &lt;null/&gt;&gt;&lt;/property&gt;\n\nBean的继承Bean的继承可以复用配置，简化XML。\nabstract指定的Bean只能被继承，不能被实例化\nparent指定父Bean\nmerge集合属性配置中都可以设置merge为true来合并与父Bean的配置，而不是代替\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"date\" class=\"java.util.Date\"&gt;&lt;/bean&gt;    &lt;bean id=\"parent\" class=\"pojo.DITest\" abstract=\"true\"&gt;        &lt;property name=\"basic\" value=\"1\"&gt;&lt;/property&gt;        &lt;property name=\"string\" value=\"str\"&gt;&lt;/property&gt;        &lt;property name=\"ref\" ref=\"date\"&gt;&lt;/property&gt;        &lt;property name=\"array\"&gt;            &lt;array&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;        &lt;property name=\"list\"&gt;            &lt;list&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;property name=\"set\"&gt;            &lt;set&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/set&gt;        &lt;/property&gt;        &lt;property name=\"map\"&gt;            &lt;map&gt;                &lt;entry key=\"1\" value=\"1\"/&gt;                &lt;entry key=\"2\"&gt;                    &lt;value&gt;2&lt;/value&gt;                &lt;/entry&gt;                &lt;entry key=\"3\" value=\"3\"/&gt;            &lt;/map&gt;        &lt;/property&gt;        &lt;property name=\"prop\"&gt;            &lt;props&gt;                &lt;prop key=\"1\"&gt;1&lt;/prop&gt;                &lt;prop key=\"2\"&gt;2&lt;/prop&gt;                &lt;prop key=\"3\"&gt;3&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"child\" class=\"pojo.DITest\" parent=\"parent\"&gt;        &lt;property name=\"basic\" value=\"2\"&gt;&lt;/property&gt;        &lt;property name=\"array\"&gt;            &lt;array merge=\"true\"&gt;                &lt;value&gt;4&lt;/value&gt;                &lt;value&gt;5&lt;/value&gt;                &lt;value&gt;6&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;","thumbnail":"post/Java/Spring/3-Bean依赖注入/cover.png","plink":"https://beginc.github.io/post/Java/Spring/3-Bean依赖注入/"},{"title":"2-Bean管理","date":"2020-01-25T13:40:15.000Z","date_formatted":{"ll":"Jan 25, 2020","L":"01/25/2020","MM-DD":"01-25"},"updated":"2020-01-25T15:14:39.059Z","content":"Bean的创建直接创建下列三个Bean都是直接调用默认构造函数创建。\n1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"service.impl.UserServiceImpl\"&gt;        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\"&gt;        &lt;property name=\"userService\" ref=\"userService\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n实例工厂创建实例化一个工厂，然后通过该工厂来创建对象。\n建立工厂类123456public class UserDaoInstanceFactory &#123;    public UserDao getInstance()&#123;        return new UserDaoImpl();    &#125;&#125;\n\n配置applicationContext.xml配置示例工厂Bean\nfactory-bean指明实例工厂Bean\nfactory-method指明实例工厂Bean创建对象的方法\n1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"instanceFactory\" class=\"factory.UserDaoInstanceFactory\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\" factory-bean=\"instanceFactory\" factory-method=\"getInstance\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"service.impl.UserServiceImpl\"&gt;        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\"&gt;        &lt;property name=\"userService\" ref=\"userService\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n静态工厂创建工厂采用静态方法创建对象，无需实例化。\n建立工厂类123456public class UserServiceStaticFactory &#123;    public static UserService getInstance() &#123;        return new UserServiceImpl();    &#125;&#125;\n\n配置applicationContext.xmlclass填工厂类\nfactory-method指明静态工厂Bean创建对象的方法\n12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"instanceFactory\" class=\"factory.UserDaoInstanceFactory\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\" factory-bean=\"instanceFactory\" factory-method=\"getInstance\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"factory.UserServiceStaticFactory\" factory-method=\"getInstance\"&gt;        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\"&gt;        &lt;property name=\"userService\" ref=\"userService\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nBean的作用范围通过scope指定。\n1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"instanceFactory\" class=\"factory.UserDaoInstanceFactory\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\" factory-bean=\"instanceFactory\" factory-method=\"getInstance\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"factory.UserServiceStaticFactory\" factory-method=\"getInstance\"&gt;        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\" scope=\"prototype\"&gt;        &lt;property name=\"userService\" ref=\"userService\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nSingleton单例，一个Bean只会被创建一次，多次获取，为同一个对象。\nPrototype多例，每次获取都会重新创建一个对象。\nRequestTODO\nSessionTODO\nGlobalTODO\nBean的生命周期创建单例IoC容器创建时对象就被创建。\n多例获取Bean时才创建。\n生命周期方法init-method\n123456789101112131415public class UserController &#123;    private UserService userService;    public void save()&#123;        userService.save();    &#125;    public void setUserService(UserService userService) &#123;        this.userService = userService;    &#125;    public void init()&#123;        System.out.println(\"Init User Controller...\");    &#125;&#125;\n\n1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"instanceFactory\" class=\"factory.UserDaoInstanceFactory\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\" factory-bean=\"instanceFactory\" factory-method=\"getInstance\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"factory.UserServiceStaticFactory\" factory-method=\"getInstance\"&gt;        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\" scope=\"singleton\" init-method=\"init\"&gt;        &lt;property name=\"userService\" ref=\"userService\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n销毁单例IoC容器关闭时销毁。\n多例GC回收时销毁。\n生命周期方法destroy-method\n12345678910111213141516171819public class UserController &#123;    private UserService userService;    public void save()&#123;        userService.save();    &#125;    public void setUserService(UserService userService) &#123;        this.userService = userService;    &#125;    public void init()&#123;        System.out.println(\"Init User Controller...\");    &#125;    public void destroy()&#123;        System.out.println(\"Destroy User Controller...\");    &#125;&#125;\n\n1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"instanceFactory\" class=\"factory.UserDaoInstanceFactory\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\" factory-bean=\"instanceFactory\" factory-method=\"getInstance\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"factory.UserServiceStaticFactory\" factory-method=\"getInstance\"&gt;        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\" scope=\"singleton\" init-method=\"init\" destroy-method=\"destroy\"&gt;        &lt;property name=\"userService\" ref=\"userService\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;","thumbnail":"post/Java/Spring/2-Bean管理/cover.png","plink":"https://beginc.github.io/post/Java/Spring/2-Bean管理/"},{"title":"1-Spring入门","date":"2020-01-25T13:16:35.000Z","date_formatted":{"ll":"Jan 25, 2020","L":"01/25/2020","MM-DD":"01-25"},"updated":"2020-01-25T15:14:33.927Z","content":"创建Maven项目编译设置123456789101112131415161718192021&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;spring-01&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;11&lt;/source&gt;                    &lt;target&gt;11&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n引入依赖Spring Context\nJunit\n12345678910111213&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n创建applicationContext.xml123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;/beans&gt;\n\n模拟Web MVC三层DAO123456public class UserDaoImpl implements UserDao &#123;    @Override    public void save() &#123;        System.out.println(\"Save user...\");    &#125;&#125;\n\nService123456789101112public class UserServiceImpl implements UserService &#123;    private UserDao userDao;    @Override    public void save() &#123;        userDao.save();    &#125;    public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;    &#125;&#125;\n\nController1234567891011public class UserController &#123;    private UserService userService;    public void save()&#123;        userService.save();    &#125;    public void setUserService(UserService userService) &#123;        this.userService = userService;    &#125;&#125;\n\nIoC入门使用将UserDao，UserService，UserController交给IoC容器来管理，让Spring帮我们创建对象。\n123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"service.impl.UserServiceImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\"&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nDI入门使用将UserDao注入UserService，将UserService注入UserController。\n1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"service.impl.UserServiceImpl\"&gt;        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\"&gt;        &lt;property name=\"userService\" ref=\"userService\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n编写测试123456789public class Test01 &#123;    @Test    public void test01() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");        UserController userController = context.getBean(\"userController\", UserController.class);        userController.save();    &#125;&#125;","thumbnail":"post/Java/Spring/1-Spring入门/cover.png","plink":"https://beginc.github.io/post/Java/Spring/1-Spring入门/"},{"title":"Leetcode-80-删除排序数组中的重复项II","date":"2020-01-24T03:25:02.000Z","date_formatted":{"ll":"Jan 24, 2020","L":"01/24/2020","MM-DD":"01-24"},"updated":"2020-02-08T02:32:43.712Z","content":"题目给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n示例示例 1:\n    给定 nums = [1,1,1,2,2,3],\n函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。示例 2:\n    给定 nums = [0,0,1,1,1,1,2,3,3],\n函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。解法1：单指针 + slots + lastEl + num思路同Leetcode-26-删除排序数组中的重复项解法1，只不过我们增加一个num来记录元素重复出现的次数。\n当前元素nums[i]\nnums[i] == lastEl 出现重复元素num &gt;= 2 重复出现了2次及以上，slots++删除掉该元素\nnum &lt; 2 重复出现了不足2次，num++记录数量，并将该元素向前移动slots个位置\n\nnums[i] != lastEl 出现下一个非重复元素，将元素向前移动slots个位置，并将lastEl设为当前元素, num = 1重置计数器\n123456789101112131415161718192021222324252627public int removeDuplicates(int[] nums) &#123;    if(nums.length == 0 || nums.length == 1)        return nums.length;    int slots = 0;    int lastEl = nums[0];    // 记录上个元素出现的次数    int num = 1;    for (int i = 1; i &lt; nums.length; i++) &#123;        if(nums[i] == lastEl)&#123;            if(num &gt;= 2)                slots++;            else&#123;                num++;                nums[i - slots] = nums[i];            &#125;        &#125;        else&#123;            nums[i - slots] = nums[i];            lastEl = nums[i];            num = 1;        &#125;    &#125;    return nums.length - slots;&#125;\n复杂度分析时间线性扫描O(n)\n空间O(1)\n进一步分析当待删除元素出现在前半部分时，要移动的元素数量较多\n当待删除元素出现在后半部分时，要移动的元素数量较少\n当无待删除元素时，无需移动元素\n解法2：","thumbnail":"post/数据结构与算法/Leetcode-80-删除排序数组中的重复项II/cover.jpg","plink":"https://beginc.github.io/post/数据结构与算法/Leetcode-80-删除排序数组中的重复项II/"},{"title":"Leetcode-26-删除排序数组中的重复项","date":"2020-01-24T03:08:16.000Z","date_formatted":{"ll":"Jan 24, 2020","L":"01/24/2020","MM-DD":"01-24"},"updated":"2020-02-08T02:32:34.963Z","content":"题目给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n示例示例 1:\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n你不需要考虑数组中超出新长度后面的元素。示例 2:\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。解法1：单指针 + lastEl + slots思路同Leetcode-27-移除元素解法1，只不过我们增加一个lastEl来记录上次的元素是什么。\n当前元素nums[i]\nnums[i] == lastEl 出现重复元素，slots++，直接继续向前扫描\nnums[i] != lastEl 出现下一个非重复元素，将元素向前移动slots个位置，并将lastEl设为当前元素\n123456789101112131415161718public int removeDuplicates(int[] nums) &#123;    if(nums.length == 0 || nums.length == 1)        return nums.length;    int slots = 0;    int lastEl = nums[0];    for (int i = 1; i &lt; nums.length; i++) &#123;        if(nums[i] == lastEl)            slots++;        else&#123;            nums[i - slots] = nums[i];            lastEl = nums[i];        &#125;    &#125;    return nums.length - slots;&#125;\n\n复杂度分析时间线性扫描O(n)\n空间O(1)\n进一步分析当待删除元素出现在前半部分时，要移动的元素数量较多\n当待删除元素出现在后半部分时，要移动的元素数量较少\n当无待删除元素时，无需移动元素\n解法2：双前向指针思路同Leetcode-27-移除元素解法2\n当前元素nums[j]\nnums[j] == num[i] 出现重复元素，直接继续向前扫描\nnums[j] != num[i] 出现下一个非重复元素，将当前元素拷贝到nums[i + 1], 并将i++\n1234567891011public int removeDuplicates(int[] nums) &#123;    if (nums.length == 0) return 0;    int i = 0;    for (int j = 1; j &lt; nums.length; j++) &#123;        if (nums[j] != nums[i]) &#123;            i++;            nums[i] = nums[j];        &#125;    &#125;    return i + 1;&#125;\n\n复杂度分析时间线性扫描O(n)\n空间O(1)\n进一步分析只需移动非重复元素，效率高\n","thumbnail":"post/数据结构与算法/Leetcode-26-删除排序数组中的重复项/cover.jpg","plink":"https://beginc.github.io/post/数据结构与算法/Leetcode-26-删除排序数组中的重复项/"},{"title":"Leetcode-27-移除元素","date":"2020-01-24T02:14:26.000Z","date_formatted":{"ll":"Jan 24, 2020","L":"01/24/2020","MM-DD":"01-24"},"updated":"2020-02-08T02:32:39.476Z","content":"题目给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例示例 1:\n给定 nums = [3,2,2,3], val = 3,\n\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n\n你不需要考虑数组中超出新长度后面的元素。示例 2:\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n\n注意这五个元素可为任意顺序。\n\n你不需要考虑数组中超出新长度后面的元素。解法1：单指针 + slots单指针扫描数组\nslots用来记录当前已经删除掉的元素数量\n当nums[i] != val时，元素向前移动slots个位置，当nums[i] == val时，slots++，继续向前扫描。\n1234567891011public int removeElement(int[] nums, int val) &#123;    int slots = 0;    for (int i = 0; i &lt; nums.length; i++) &#123;        if (nums[i] == val)            slots++;        else            nums[i - slots] = nums[i];    &#125;    return nums.length - slots;&#125;\n复杂度分析时间线性扫描O(n)\n空间O(1)\n进一步分析当待删除元素出现在前半部分时，要移动的元素数量较多\n当待删除元素出现在后半部分时，要移动的元素数量较少\n当无待删除元素时，无需移动元素\n解法2：双前向指针指针i记录当前非目标元素的个数\n指针j负责持续前向扫描\n当前元素nums[j]:\nnums[j] == val，直接跳过，继续向前扫描\nnums[j] != val，将该元素拷贝到nums[i]\n12345678910public int removeElement(int[] nums, int val) &#123;    int i = 0;    for (int j = 0; j &lt; nums.length; j++) &#123;        if (nums[j] != val) &#123;            nums[i] = nums[j];            i++;        &#125;    &#125;    return i;&#125;\n\n复杂度分析时间线性扫描O(n)\n空间O(1)\n进一步分析所有非目标元素都需要移动，无效移动次数太多\n解法3：双指针(一正一反)指针i负责持续前向扫描\n指针n记录当前数组的有效长度\n当前元素nums[i]:\nnums[i] == val，互换nums[i] 与nums[n - 1]\nnums[i] != val，继续向前扫描\n1234567891011121314public int removeElement(int[] nums, int val) &#123;    int i = 0;    int n = nums.length;    while (i &lt; n) &#123;        if (nums[i] == val) &#123;            nums[i] = nums[n - 1];            // reduce array size by one            n--;        &#125; else &#123;            i++;        &#125;    &#125;    return n;&#125;\n\n复杂度分析时间线性扫描O(n)\n空间O(1)\n进一步分析移动的次数为目标元素的个数，避免了无效移动\n元素会乱序，但是题目不要求保持原有顺序\n","thumbnail":"post/数据结构与算法/Leetcode-27-移除元素/cover.jpg","plink":"https://beginc.github.io/post/数据结构与算法/Leetcode-27-移除元素/"},{"title":"Leetcode目录","date":"2020-01-24T02:10:48.000Z","date_formatted":{"ll":"Jan 24, 2020","L":"01/24/2020","MM-DD":"01-24"},"updated":"2020-02-08T02:32:46.680Z","content":"数组Leetcode-27-移除元素---双指针\nLeetcode-26-删除排序数组中的重复项---双指针\n","thumbnail":"post/数据结构与算法/Leetcode目录/cover.jpg","plink":"https://beginc.github.io/post/数据结构与算法/Leetcode目录/"},{"title":"6-MyBatis注解开发","date":"2020-01-23T14:37:40.000Z","date_formatted":{"ll":"Jan 23, 2020","L":"01/23/2020","MM-DD":"01-23"},"updated":"2020-01-23T16:05:58.975Z","content":"基本操作Select12@Select(\"select * from user\")List&lt;User&gt; findAll();\n\nInsert + SelectKey123@Insert(\"insert into user (username, address, sex, birthday) values (#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;)\")@SelectKey(statement = \"select LAST_INSERT_ID()\", keyColumn = \"id\", keyProperty = \"id\", before = false, resultType = Integer.class)void save(User user);\n\nUpdate12@Update(\"update user set username = #&#123;username&#125;, address = #&#123;address&#125;, sex = #&#123;sex&#125;, birthday = #&#123;birthday&#125; where id = #&#123;id&#125;\")void update(User user);\n\nDelete12@Delete(\"delete from user where id = #&#123;id&#125;\")void delete(Integer id);\n\nResultMap配置Resultsid标记该ResultMap\nvalue数组填充@Result\n1234567891011@Select(\"select * from user\")@Results(        id = \"userMap\",        value = &#123;                @Result(id = true, column = \"id\", property = \"id\"),                @Result(column = \"username\", property = \"username\"),                @Result(column = \"address\", property = \"address\"),                @Result(column = \"birthday\", property = \"birthday\"),        &#125;)List&lt;User&gt; findAll();\n\n使用ResultMap12345678910111213141516171819202122232425262728public interface UserMapper &#123;    @Select(\"select * from user\")    @Results(            id = \"userMap\",            value = &#123;                    @Result(id = true, column = \"id\", property = \"id\"),                    @Result(column = \"username\", property = \"username\"),                    @Result(column = \"address\", property = \"address\"),                    @Result(column = \"birthday\", property = \"birthday\"),            &#125;    )    List&lt;User&gt; findAll();    @Select(\"select * from user where id = #&#123;id&#125;\")    @ResultMap(\"userMap\")    User find(Integer id);    @Insert(\"insert into user (username, address, sex, birthday) values (#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;)\")    @SelectKey(statement = \"select LAST_INSERT_ID()\", keyColumn = \"id\", keyProperty = \"id\", before = false, resultType = Integer.class)    void save(User user);    @Update(\"update user set username = #&#123;username&#125;, address = #&#123;address&#125;, sex = #&#123;sex&#125;, birthday = #&#123;birthday&#125; where id = #&#123;id&#125;\")    void update(User user);    @Delete(\"delete from user where id = #&#123;id&#125;\")    void delete(Integer id);&#125;\n\n关联查询一对多Result里面用many进行指定\n12345678910111213141516@Select(\"select * from user\")@Results(        id = \"userMap\",        value = &#123;                @Result(id = true, column = \"id\", property = \"id\"),                @Result(column = \"username\", property = \"username\"),                @Result(column = \"address\", property = \"address\"),                @Result(column = \"birthday\", property = \"birthday\"),                @Result(                        column = \"id\",                        property = \"accounts\",                        many = @Many(select = \"mapper.AccountMapper.findByUID\", fetchType = FetchType.LAZY)                )        &#125;)List&lt;User&gt; findAll();\n\n一对一Result里面用one指定\n1234567891011121314@Select(\"select * from account\")@Results(        id = \"accountMap\",        value = &#123;                @Result(id = true, column = \"id\", property = \"id\"),                @Result(column = \"money\", property = \"money\"),                @Result(                        column = \"uid\",                        property = \"user\",                        one = @One(select = \"mapper.UserMapper.find\", fetchType = FetchType.EAGER)                )        &#125;)List&lt;Account&gt; findAll();\n\n动态SQL可使用SelectProvider, UpdateProvider, InsertProvider, DeleteProvider，通过定义一个Provider类，通过类中的方法动态进行SQL语句生成，从而实现动态SQL的效果。\n注解SelectProvider注解标识Provider\ntype指定Provider类\nmethod指定Provider中用于生成该SQL的方法\nParam注解用于指定参数名称（Provider用map接收参数，取参数时，若指定了参数名就用参数名取，若没有指定，则使用参数顺序的下标取）\n1234567@SelectProvider(type = UserProvider.class, method = \"findByUsernameOrSex\")@ResultMap(\"userMap\")List&lt;User&gt; findByUsernameOrSex(@Param(\"user\") User user);@SelectProvider(type = UserProvider.class, method = \"findInIDs\")@ResultMap(\"userMap\")List&lt;User&gt; findInIDs(@Param(\"ids\") List&lt;Integer&gt; ids);\n\n编写ProviderMap接收参数\nSQL类可用于辅助构造SQL语句\n12345678910111213141516171819202122232425262728293031public class UserProvider &#123;    public String findByUsernameOrSex(Map&lt;String, Object&gt; params) &#123;        User user = (User) params.get(\"user\");        SQL sql = new SQL().SELECT(\"username\", \"address\", \"sex\", \"birthday\").FROM(\"user\");        if(user.getUsername() != null)            sql.WHERE(\"username = #&#123;user.username&#125;\");        if(user.getSex() != null)            sql.WHERE(\"sex = #&#123;user.sex&#125;\");        return sql.toString();    &#125;    public String findInIDs(Map&lt;String, Object&gt; params)&#123;        List&lt;Integer&gt; ids = (List&lt;Integer&gt;) params.get(\"ids\");        StringBuilder sql = new StringBuilder();        sql.append(\"select * from user \");        if(ids != null &amp;&amp; ids.size() &gt; 0)&#123;            sql.append(\"where id in (\");            int i = 0;            for (i = 0; i &lt; ids.size() - 1; i++) &#123;                sql.append(ids.get(i)).append(\",\");            &#125;            sql.append(ids.get(i)).append(\")\");        &#125;        return sql.toString();    &#125;&#125;\n\n配置冲突一个Mapper要么使用注解配置，要么使用XML配置，不可混合使用。\n","thumbnail":"post/Java/MyBatis/6-MyBatis注解开发/cover.jpg","plink":"https://beginc.github.io/post/Java/MyBatis/6-MyBatis注解开发/"},{"title":"Java集合之List接口继承体系下的迭代器","date":"2020-01-12T11:57:03.000Z","date_formatted":{"ll":"Jan 12, 2020","L":"01/12/2020","MM-DD":"01-12"},"updated":"2020-01-12T12:01:49.831Z","content":"AbstractList提供的迭代器AbstractList提供了两种迭代器的实现。\nItr实现了Iterator接口\nListItr实现了ListIterator接口\nItr迭代器该迭代器为标准的Iterator的实现类，实现了所有的方法。\nConcurrentModification使用迭代器对集合进行遍历的时候不允许进行对集合有结构型改变的操作（使集合的长度发生变化），否则会使迭代器遍历行为异常。AbstractList中使用modCount来避免这种行为，modCount负责记录当前对集合的结构性修改的次数，在执行add、remove等方法时需要将modCount++。\n\n\n初始化迭代器时记录当前modCount\n\n\n若当前modCount不等于预期的expectedModCount，即发生了ConcurrentModification，则抛出异常\nhasNext\n\nnext\n\nremove想要移除当前元素可以使用迭代器提供的remove方法进行合法操作。\n\n\n\n\nListItr迭代器ListItr迭代器是专门为List实现了增强版的Itr迭代器，不仅支持前向遍历，还支持反向遍历，还支持替换元素和增加元素。操作逻辑和Itr相同：\n通过modCount避免ConcurrentModification\n使用cursor和lastRet来进行遍历\n\n\n\n\nArrayList提供的迭代器ArrayList提供了Itr和ListItr的优化实现。\nnext手动检查下标越界，不依赖try catch，其他方法也类似\n\n\n\n\n\n\nLinkedList提供的迭代器由于AbstractList中提供的Itr迭代器和ListItr在遍历时，维持下标cursor和lastRet，在获取元素时通过get(cursor)来获取元素，这对于ArrayList来说没有问题，因为它可随机访问，但是对于LinkedList来说，每一次get(cursor)都意味着必须将指针从首节点开始移动到目标节点，这意味着对于LinkedList若使用AbstractList提供的迭代器实现，遍历一次的时间复杂度为O(n^2)，多出了很多无意义的指针移动，因此必须进行重新实现。\nItrLinkedList的父类AbstractSequentialList重写了iterator方法，直接调用了listIterator方法。\n\n\n\n\nListItr使用指针来维护当前节点和上一个返回节点的位置。\n","thumbnail":"post/Java/Java语言/Java集合之List接口继承体系下的迭代器/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合之List接口继承体系下的迭代器/"},{"title":"Java集合之List","date":"2020-01-12T11:56:57.000Z","date_formatted":{"ll":"Jan 12, 2020","L":"01/12/2020","MM-DD":"01-12"},"updated":"2020-01-12T12:01:49.831Z","content":"继承体系\n\n特性有序集合，支持整数索引\n允许重复元素\n特性方法\n\n增加的方法主要都是支持整数索引的方法。\n增\n12void add(int index, E element);boolean addAll(int index, Collection&lt;? extends E&gt; c);\n\n删\n1E remove(int index);\n\n改\n1E set(int index, E element);\n\n查\n12int indexOf(Object o);int lastIndexOf(Object o);","thumbnail":"post/Java/Java语言/Java集合之List/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合之List/"},{"title":"Java集合之LinkedList","date":"2020-01-12T11:56:49.000Z","date_formatted":{"ll":"Jan 12, 2020","L":"01/12/2020","MM-DD":"01-12"},"updated":"2020-01-12T12:01:49.831Z","content":"继承体系\n\n不光实现了List接口，还实现了Queue接口。\n底层实现底层实现为双向链表，存储了指向首节点和尾节点的指针，操作均为链表的常规操作。\n\n\n多线程环境非同步实现，线程不安全。\n","thumbnail":"post/Java/Java语言/Java集合之LinkedList/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合之LinkedList/"},{"title":"Java集合之Collection","date":"2020-01-12T11:56:43.000Z","date_formatted":{"ll":"Jan 12, 2020","L":"01/12/2020","MM-DD":"01-12"},"updated":"2020-01-12T12:01:49.831Z","content":"继承体系\n\nCollection是一个借口，继承自Iterable接口。\nIterable接口Java中对于集合使用迭代器Iterator进行遍历，实现了Iterable接口说明了该集合支持通过调用iterator方法返回一个Iterator接口的实现类，从而对集合进行遍历。\n\n\n\n\nCollection接口所有集合都实现了该接口，该接口定义了所有集合共有的一些方法。\n\n\n增\n12boolean add(E e);boolean addAll(Collection&lt;? extends E&gt; c);\n\n删\n123boolean remove(Object o);boolean removeAll(Collection&lt;?&gt; c);void clear();\n\n改\n未定义\n查\n12boolean contains(Object o);boolean containsAll(Collection&lt;?&gt; c);\n\n属性\n12int size();boolean isEmpty();","thumbnail":"post/Java/Java语言/Java集合之Collection/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合之Collection/"},{"title":"Java集合之ArrayList","date":"2020-01-12T11:56:35.000Z","date_formatted":{"ll":"Jan 12, 2020","L":"01/12/2020","MM-DD":"01-12"},"updated":"2020-01-12T12:01:49.831Z","content":"继承体系\n\n\n\n底层实现底层实现为数组，可进行动态扩容，elementData.length就是当前最大容量，size保存了当前元素的个数。\n\n\n\n\n\n\n\n增检查索引范围\n检查容量\n存数据\n\n\n扩容策略\n默认扩容1.5倍\n限制无限制内存分配\n\n\n\n\n\n\n\n\n容量缩减\n缩减到实际大小\n\n\n\n\n多线程环境非同步实现，线程不安全。\n","thumbnail":"post/Java/Java语言/Java集合之ArrayList/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合之ArrayList/"},{"title":"Babel基本使用","date":"2020-01-08T11:56:00.000Z","date_formatted":{"ll":"Jan 8, 2020","L":"01/08/2020","MM-DD":"01-08"},"updated":"2020-02-11T13:42:35.932Z","content":"什么是BabelBabel是一个用来将高版本JS代码(ES6或以上)编译转化为向后兼容的低版本JS代码的编译器。\n基本介绍Babel所提供的基本功能代码转换（如将箭头函数转化成普通函数）\n添加缺失的特性（Async, Await, Promise, Iterator, Generator, Set, Map, Proxy, Reflect, Symbol等）\nBabel的基本流程解析\n转换\n生成\nBabel的插件化Babel构建在插件之上，可通过组合多个插件或使用preset构建一个Pipeline。\n语法插件：相当于编译器前端\n转译插件：相当于编译器后端(使用转译插件自动依赖语法插件)\nBabel工具链@babel/core提供了Babel的核心功能。\n@babel/cli提供了命令行方式来使用Babel。\n1.&#x2F;node_modules&#x2F;.bin&#x2F;babel src --out-dir lib\n\n@babel/polyfillBabel默认只转换JS语法，而不转换新的API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法(比如Object.assign)都不会转码。@babel/polyfill通过向全局对象和内置对象的prototype上添加方法来支持新API\n缺点\n打包体积非常大\n污染全局变量\n@babel/plugin-transform-runtime  @babel/runtime","thumbnail":"post/Web/前端工程化/Babel基本使用/cover.png","plink":"https://beginc.github.io/post/Web/前端工程化/Babel基本使用/"},{"title":"webpack基本使用","date":"2020-01-08T10:46:42.000Z","date_formatted":{"ll":"Jan 8, 2020","L":"01/08/2020","MM-DD":"01-08"},"updated":"2020-02-11T13:42:35.932Z","content":"为何要使用webpack前端模块化开发\n资源打包，减少请求次数\n基本概念入口(entry)webpack通过对各模块的依赖关系进行分析，构建出一个依赖关系图，然后将所有模块打包成一个(多个)bundle文件，入口指定了webpack从哪个文件开始构建依赖关系图。\n出口(outout)出口指定了webpack打包后如何输出。\nloaderloader可以将所有类型的文件转换成webpack能够处理的有效模块，从而让webpack能够处理非JavaScript文件。总之可将其理解为预处理器。\n图片\n字体\n样式（css、less、sass等）\nVue组件\nES6 JS文件（通过babel先进行转换）\n插件(plugin)待进一步理解\n基本配置123456789101112131415161718192021222324252627282930313233343536const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123;    mode: 'development',    entry: './src/index.js',    output: &#123;        path: path.resolve(__dirname, 'dist'),        filename: 'bundle.js'    &#125;,    module: &#123;        rules: [            &#123;                test: /\\.js$/,                exclude: /node_modules/,                use: 'babel-loader'            &#125;,            &#123;                test: /\\.less$/,                use: ['style-loader', 'css-loader', 'less-loader']            &#125;        ]    &#125;,    plugins: [        new HtmlWebpackPlugin(&#123;            filename: 'index.html',            template: 'template.html'        &#125;)    ],    devServer: &#123;        contentBase: path.resolve(__dirname, 'dist'),        port: 8000,        hot: true,        open: true    &#125;&#125;\n\n入口entry指定入口文件\noutputpath指定目录，filename指定文件名\nloader在module的rules中指定\n1234&#123;    test: 正则表达式,    use: [loader1, loader2...]&#125;\n\nJS语法转换\nbabel-loader\n1npm install -D babel-loader\n\nCSS\n[style-loader, css-loader, less-loader]\n1npm install -D css-loader style-loader less-loader\n\n图片与字体\nurl-loader\n1npm install -D url-loader\n\nVue组件\nvue-loader\n1npm install -D vue-loader vue-template-compiler\n\n配置(vue-loader V15 还需配置plugin和css!!)\n1234567891011121314151617181920212223242526272829303132const VueLoaderPlugin = require('vue-loader/lib/plugin')module.exports = &#123;  mode: 'development',  module: &#123;    rules: [      &#123;        test: /\\.vue$/,        loader: 'vue-loader'      &#125;,      // 它会应用到普通的 `.js` 文件      // 以及 `.vue` 文件中的 `&lt;script&gt;` 块      &#123;        test: /\\.js$/,        loader: 'babel-loader'      &#125;,      // 它会应用到普通的 `.css` 文件      // 以及 `.vue` 文件中的 `&lt;style&gt;` 块      &#123;        test: /\\.css$/,        use: [          'vue-style-loader',          'css-loader'        ]      &#125;    ]  &#125;,  plugins: [    // 请确保引入这个插件来施展魔法    new VueLoaderPlugin()  ]&#125;\n\n插件在module的plugins里面new出来。\nhtml-webpack-plugin\n用于自动将打包好的bundle文件注入到html中\nfilename 指定注入html的文件名（无需存在）\ntemplate 指定html模板文件（自己创建，可选）\ndevServer可用于热加载, 在module的devServer下配置。\ncontentBase 托管的目录（写dist目录）\nport 端口\nhot 热加载（默认为true)\nopen 是否自动打开页面\n","thumbnail":"post/Web/前端工程化/webpack基本使用/cover.png","plink":"https://beginc.github.io/post/Web/前端工程化/webpack基本使用/"},{"title":"npm基本使用","date":"2020-01-08T09:54:38.000Z","date_formatted":{"ll":"Jan 8, 2020","L":"01/08/2020","MM-DD":"01-08"},"updated":"2020-02-11T13:42:35.932Z","content":"npm介绍NPM是NodeJS下的包管理工具，可以解决包依赖问题。\n基本命令初始化1npm init\n\n执行之后当前目录下会生成一个package.json的配置文件。\npackage.json配置文件详解\nname 包名\nversion 版本号\ndescription 包描述信息\nmain 入口文件，require(&#39;moduleName&#39;)时会加载这个文件，默认为根目录下的index.js\nscripts 定义可执行脚本，可使用npm run执行\nauthor 作者\nlicense 许可\ndevDependencies 开发时所依赖的包，运行时不需要\ndependencies 运行时所依赖的包\n安装全局安装\n1npm install package-name -g\n\n本地安装\n安装包，不修改package.json\n1npm install package-name\n\n安装包，修改package.json的dependencies\n12npm install package-name --savenpm install package-name -S\n\n安装包，修改package.json的devDependencies\n12npm install package-name --save-devnpm install package-name -D\n\n卸载全局卸载\n1npm install package-name -g\n\n本地卸载\n卸载包，不修改package.json\n1npm uninstall package-name\n\n卸载包，修改package.json的dependencies\n12npm uninstall package-name --savenpm uninstall package-name -S\n\n卸载包，修改package.json的devDependencies\n12npm uninstall package-name --save-devnpm uninstall package-name -D\n\n淘宝镜像npm默认从国外服务器拉取资源，速度十分缓慢，因此可将其替换成淘宝镜像cnpm.\n1npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org\n\n使用\n1cnpm install package-name","thumbnail":"post/Web/前端工程化/npm基本使用/cover.jpg","plink":"https://beginc.github.io/post/Web/前端工程化/npm基本使用/"},{"title":"七大原则","date":"2019-12-23T11:02:51.000Z","date_formatted":{"ll":"Dec 23, 2019","L":"12/23/2019","MM-DD":"12-23"},"updated":"2020-01-08T08:34:37.678Z","content":"单一职责原则每一个类只负责一项职责\n","thumbnail":"post/设计模式/七大原则/cover.jpg","plink":"https://beginc.github.io/post/设计模式/七大原则/"},{"title":"Leetcode-53 Maximun Array","date":"2019-09-11T13:19:59.000Z","date_formatted":{"ll":"Sep 11, 2019","L":"09/11/2019","MM-DD":"09-11"},"updated":"2020-01-08T08:34:39.599Z","content":"题目Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\nExample:\n123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.\n\n动态规划状态转移方程\n定义dp[i]为子序列seq[:i]的最大连续子列和\n1dp[i] &#x3D; max(dp[i - 1] + seq[i], seq[i])\n\n实现\n12345678910111213141516public class Solution &#123;    public int maxSubArray(int[] nums) &#123;        // 记录最大和        int max = nums[0];        int[] dp = new int[nums.length];        dp[0] = nums[0];        for (int i = 1; i &lt; nums.length; i++) &#123;            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);            max = Math.max(dp[i], max);        &#125;        return max;    &#125;&#125;","thumbnail":"post/数据结构与算法/Leetcode-53/cover.jpg","plink":"https://beginc.github.io/post/数据结构与算法/Leetcode-53/"},{"title":"MIPS-Like单周期16位CPU设计","date":"2019-09-09T15:48:42.000Z","date_formatted":{"ll":"Sep 9, 2019","L":"09/09/2019","MM-DD":"09-09"},"updated":"2020-01-08T09:46:30.603Z","content":"由于课程设计的需要，利用Verilog实现了一个类MIPS的单周期CPU。\n指令集R型寄存器操作型指令，三个操作数都为寄存器。\n指令格式\nOpType(2位) FuncType(5位) R1(3位) R2(3位) R3(3位)\n实现指令\n123456789ADDR  r1, r2, r3(r1 + r2   ---&gt; r3) 加法SUBR  r1, r2, r3(r1 - r2   ---&gt; r3) 减法LSLR  r1, r2, r3(r1 &lt;&lt; r2  ---&gt; r3) 逻辑左移LSRR  r1, r2, r3(r1 &gt;&gt; r2  ---&gt; r3) 逻辑右移ASLR  r1, r2, r3(r1 &lt;&lt;&lt; r2 ---&gt; r3) 算术左移ASRR  r1, r2, r3(r1 &gt;&gt;&gt; r2 ---&gt; r3) 算术右移ANDR  r1, r2, r3(r1 and r2 ---&gt; r3) 按位与ORR   r1, r2, r3(r1 or r2  ---&gt; r3) 按位或MOVR  r1, .., r3(r1 ---&gt; r3)        转存\n\nI型寄存器与立即数混合运算。\n指令格式\nOpType(2位) FuncType(5位) R1(3位) IConst(3位) R3(3位)\n实现指令\n1234567891011ADDI  r1, const, r3(r1 + r2   ---&gt; r3)    加法SUBI  r1, const, r3(r1 - r2   ---&gt; r3)    减法LSLI  r1, const, r3(r1 &lt;&lt; r2  ---&gt; r3)    逻辑左移LSRI  r1, const, r3(r1 &gt;&gt; r2  ---&gt; r3)    逻辑右移ASLI  r1, const, r3(r1 &lt;&lt;&lt; r2 ---&gt; r3)    算术左移ASRI  r1, const, r3(r1 &gt;&gt;&gt; r2 ---&gt; r3)    算术右移ANDI  r1, const, r3(r1 and r2 ---&gt; r3)    按位与ORI   r1, const, r3(r1 or r2  ---&gt; r3)    按位或MOVI  .., const, r3(const ---&gt; r3)        转存LOAD  r1, const, r3(M[r1 + const] ---&gt; r3)读数据内存STORE r1, const, r3(r3 ---&gt; M[r1 + const])写数据内存\n\nJ型执行跳转指令。\n指令格式\nOpType(2位) FuncType(5位) JConst(9位)\n实现指令\n1234JMP constJE  constJL  constJG  const\n\n寄存器设置R1-R8八个16位寄存器\nPSW程序状态字(Z.S)\n配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// 字长`define WORD_WIDTH 15:0// PSW宽度`define PSW_WIDTH 1:0// PSW位选择`define PSW_Z_SEL 0`define PSW_S_SEL 1// S标志正负`define PSW_S_NEG 1`define PSW_S_POS 0// 复位`define ChipResetEnable  1`define ChipResetDisable 0// 寄存器数量`define REG_MAX_NUM    8`define REG_ADDR_WIDTH 7:0// 寄存器宽度`define REG_WIDTH      15:0// 读写信号`define READ  0`define WRITE 1// 数据存储器数量`define DATA_MAX_NUM    8`define DATA_ADDR_WIDTH 7:0// 数据存储器宽度`define DATA_WIDTH      15:0// 指令存储器数量`define INST_MAX_NUM    16`define INST_ADDR_WIDTH 15:0// 指令存储器宽度`define INST_WIDTH      15:0// 指令格式`define OP_TYPE_WIDTH   1:0`define FUNC_TYPE_WIDTH 4:0`define I_CONST_WIDTH   2:0`define J_CONST_WIDTH   8:0`define OP_TYPE_SEL   15:14`define FUNC_TYPE_SEL 13:9`define R1_SEL         8:6`define R2_SEL         5:3`define R3_SEL         2:0`define I_CONST_SEL    5:3`define J_CONST_SEL    8:0// 操作码`define OP_R 2'b00`define OP_I 2'b01`define OP_J 2'b10// 功能码`define FUNC_ADDR 5'b00000`define FUNC_SUBR 5'b00001`define FUNC_LSLR 5'b00010`define FUNC_LSRR 5'b00011`define FUNC_ASLR 5'b00100`define FUNC_ASRR 5'b00101`define FUNC_ANDR 5'b00110`define FUNC_ORR  5'b00111`define FUNC_MOVR 5'b01000`define FUNC_ADDI  5'b00000`define FUNC_SUBI  5'b00001`define FUNC_LSLI  5'b00010`define FUNC_LSRI  5'b00011`define FUNC_ASLI  5'b00100`define FUNC_ASRI  5'b00101`define FUNC_ANDI  5'b00110`define FUNC_ORI   5'b00111`define FUNC_MOVI  5'b01000`define FUNC_LOAD  5'b01001`define FUNC_STORE 5'b01010`define FUNC_JMP 5'b00000`define FUNC_JE  5'b00001`define FUNC_JL  5'b00010`define FUNC_JG  5'b00011// 位扩展模式`define ZERO_EXTEND   0`define SIGN_EXTEND   1// 控制器控制信号// ALU OP2 Selection`define ALU_OP2_ICONST 1`define ALU_OP2_R2 0// Register Write Data Selection`define REG_WRITE_ALU_OUT 0`define REG_WRITE_R1 1`define REG_WRITE_ICONST 2`define REG_WRITE_MEM 3// Register Read Port2 Address Selection`define REG_PORT2_ADDR_R2 0`define REG_PORT2_ADDR_R3 1// Write Enable`define WRITE_ENABLE 1`define WRITE_DISABLE 0// PC Delta Selection`define PC_DELTA_1 0`define PC_DELTA_J 1\n\n基础部件实现存储器实现由于采用数据存储器、指令存储器分离，因此需分别实现两种存储器。\n指令寄存器指令存储器为只读存储器。\n端口定义\nreset复位信号\ninstAddr即PC取指令地址\ninst为取出的指令\n12345678910111213141516171819202122232425262728`include \"config.v\"module InstMemory(    input reset,    input[`INST_ADDR_WIDTH] instAddr,    output reg[`INST_WIDTH] inst);reg[`INST_WIDTH] data[`INST_ADDR_WIDTH];integer index;// Resetalways@(*) begin    if(reset == `ChipResetEnable) begin        for(index=0;index&lt;`INST_MAX_NUM;index=index+1)            data[index] &lt;= 0;            endendalways@(*) begin    if(reset == `ChipResetEnable)        inst = 0;    else        inst = data[instAddr];endendmodule\n\n数据存储器端口定义\nclk为时钟信号\nreset复位信号\ndataMemWR控制写入还是读出\ndataMemWriteEnable写使能\ndataMemAddr相当于MAR\ndataMemIn要写入的数据\ndataMemOut读出的数据\n123456789101112131415161718192021222324252627282930313233343536373839`include \"config.v\"module DataMemory(    input clk,    input reset,    input dataMemWR,    input dataMemWriteEnable,    input[`DATA_ADDR_WIDTH] dataMemAddr,    input[`DATA_WIDTH] dataMemIn,    output reg[`DATA_WIDTH] dataMemOut);reg[`DATA_WIDTH] data[`DATA_ADDR_WIDTH];integer index;// Resetalways@(*) begin    if(reset == `ChipResetEnable) begin        for(index=0;index&lt;`DATA_MAX_NUM;index=index+1)            data[index] &lt;= 0;    endend// Readalways@(*) begin    if(reset == `ChipResetEnable)        dataMemOut &lt;= 0;    else begin        if(dataMemWR == `READ)            dataMemOut &lt;= data[dataMemAddr];    endend// Writealways@(posedge clk) begin    if(reset == `ChipResetDisable) begin        if((dataMemWR == `WRITE) &amp;&amp; (dataMemWriteEnable == `WRITE_ENABLE))            data[dataMemAddr] = dataMemIn;    endendendmodule\n\n寄存器组实现clk时钟信号\nreset复位信号\nregisterWR寄存器读写模式\nregisterWriteEnable寄存器写使能\nr1Addr读端口1地址\nr2Addr读端口2地址\nr1Data读端口1输出数据\nr2Data读端口2输出数据\nwRegAddr写端口地址\nwRegData待写数据\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546`include \"config.v\"module Register(    input clk,    input reset,    input registerWR,    input registerWriteEnable,    input[`REG_ADDR_WIDTH] r1Addr,    input[`REG_ADDR_WIDTH] r2Addr,    output reg [`REG_WIDTH] r1Data,    output reg [`REG_WIDTH] r2Data,    input[`REG_ADDR_WIDTH] wRegAddr,    input[`REG_WIDTH] wRegData);reg[`REG_WIDTH] regs[`REG_ADDR_WIDTH];integer index;// 初始复位清空数据always@(*) begin    if(reset == `ChipResetEnable) begin        for(index=0;index&lt;`REG_MAX_NUM;index=index+1)            regs[index]=0;    endend// 读端口1always@(*) begin    if((reset == `ChipResetEnable))        r1Data &lt;= 0;    else begin        r1Data &lt;= regs[r1Addr];    endend// 读端口2always@(*) begin    if((reset == `ChipResetEnable))        r2Data &lt;= 0;    else begin        r2Data &lt;= regs[r2Addr];    endend// 写端口always@(posedge clk) begin    if((reset == `ChipResetDisable) &amp;&amp; (registerWR == `WRITE) &amp;&amp; (registerWriteEnable == `WRITE_ENABLE))        regs[wRegAddr] &lt;= wRegData;endendmodule\n\n二路选择器实现在输入的两路信号中选择一路输出。\nsel选择信号\nmuxIn1输入1\nmuxIn2输入2\nmuxOut输出\n1234567891011121314151617`include \"config.v\"module Mux2(    input sel,    input[`WORD_WIDTH] muxIn1,    input[`WORD_WIDTH] muxIn2,    output reg[`WORD_WIDTH] muxOut);always@(*) begin    if(sel == 0) begin        muxOut &lt;= muxIn1;    end    else        muxOut &lt;= muxIn2;endendmodule\n\n四路选择器实现在输入的四路信号中选择一路输出\nsel选择信号\nmuxIn1输入1\nmuxIn2输入2\nmuxIn3输入3\nmuxIn4输入4\nmuxOut输出\n1234567891011121314151617181920`include \"config.v\"module Mux4(    input[1:0] sel,    input[`WORD_WIDTH] muxIn1,    input[`WORD_WIDTH] muxIn2,    input[`WORD_WIDTH] muxIn3,    input[`WORD_WIDTH] muxIn4,    output reg[`WORD_WIDTH] muxOut);always@(*) begin    case(sel)        0: muxOut &lt;= muxIn1;        1: muxOut &lt;= muxIn2;        2: muxOut &lt;= muxIn3;        3: muxOut &lt;= muxIn4;    endcaseendendmodule\n\n数据通路实现实现完一些基础部件后，开始对数据通路进行实现。\n最全数据通路\n先列出最全的数据通路，而对于不同的指令，其数据通路将为下面数据通路的子集，需要使用控制器进行相应的信号控制。\n依据PC取指令\n对指令译码，得出指令的各个组成部分OPType\nFuncType\nR1Addr\nR2Addr\nR3Addr\nIConst(I型指令的立即数，需要进行位扩展到寄存器宽度)\nJConst(J型指令的立即数，需要进行位扩展到寄存器宽度)\n\n读寄存器(R型和I型指令需要读寄存器)\nALU运算(R型和I型指令需要ALU运算)\n数据存储器访问写内存(STORE指令)\n读内存(LOAD指令)\n\n写寄存器(R型指令和I型指令需要写寄存器)\n改变PC+1(对于R型指令和I型指令，PC加1，继续顺序执行)\nJConst + PC + 1(J型指令跳转，修改PC)\n\n数据通路分析R型指令除MOVR指令外\n依据PC取指令\n对指令译码，得出指令的各个组成部分OPType\nFuncType\nR1Addr\nR2Addr\nR3Addr\n\n读寄存器registerWR读模式\nregisterWriteEnable禁止\n用R1Addr地址读出数据到R1Data\n用R2Addr地址读出数据到R2Data\n\nALU运算ALUOp1为R1Data\nALUOp2为R2Data\n\n写寄存器registerWR写模式\nregisterWriteEnable允许\n用R3Addr作为写地址，将ALUOut写入寄存器\n\nPC + 1\nMOVR指令\nMOVR指令不同于其他R型指令，它无需进行ALU运算。\n依据PC取指令\n对指令译码，得出指令的各个组成部分OPType\nFuncType\nR1Addr\n......(无作用)\nR3Addr\n\n读寄存器registerWR读模式\nregisterWriteEnable禁止\n用R1Addr地址读出数据到R1Data\n\n写寄存器registerWR写模式\nregisterWriteEnable允许\n用R3Addr作为写地址，将R1Data写入寄存器\n\nPC + 1\n冲突分析\nMOVR指令无需进行ALU运算，因此在设计ALU时，当见到MOVR指令时，无需进行计算\nMOVR指令使用R1Data写入寄存器地址R3Data处，而其他指令使用ALUOut写入寄存器地址R3Data处，因此需添加一个多路选择器，用控制信号wRegDataSel来选择写入寄存器的数据来源\nI型指令除MOVI, LOAD, STORE外\n依据PC取指令\n对指令译码，得出指令的各个组成部分OPType\nFuncType\nR1Addr\nIConst(I型指令的立即数，需要进行位扩展到寄存器宽度)\nR3Addr\n\n位扩展(将IConst进行位扩展)移位指令需要零扩展\n其他运算指令需要符号扩展\n\n读寄存器registerWR读模式\nregisterWriteEnable禁止\n用R1Addr地址读出数据到R1Data\n\nALU运算ALUOp1为R1Data\nALUOp2为位扩展后的IConst\n\n写寄存器registerWR写模式\nregisterWriteEnable允许\n用R3Addr作为写地址，将ALUOut写入寄存器\n\nPC + 1\nMOVI指令\n依据PC取指令\n对指令译码，得出指令的各个组成部分OPType\nFuncType\nIConst(I型指令的立即数，需要进行位扩展到寄存器宽度)\nR3Addr\n\n位扩展(将IConst进行位扩展)符号扩展\n\n写寄存器registerWR写模式\nregisterWriteEnable允许\n用R3Addr作为写地址，将位扩展后的IConst写入寄存器\n\nPC + 1\nLOAD指令\n依据PC取指令\n对指令译码，得出指令的各个组成部分OPType\nFuncType\nR1Addr\nIConst(I型指令的立即数，需要进行位扩展到寄存器宽度)\nR3Addr\n\n位扩展(将IConst进行位扩展)符号扩展\n\nALU运算ALUOp1为R1Data\nALUOp2为位扩展后的IConst\n\n数据存储器访问\n\nSTORE指令\n","thumbnail":"post/Hardware/MIPS-Like单周期CPU设计/cover.jpg","plink":"https://beginc.github.io/post/Hardware/MIPS-Like单周期CPU设计/"},{"title":"VirtualBox下CentOS克隆","date":"2019-09-09T14:44:38.000Z","date_formatted":{"ll":"Sep 9, 2019","L":"09/09/2019","MM-DD":"09-09"},"updated":"2020-01-08T08:31:06.569Z","content":"CentOS-Minimal安装配置先用Minimal镜像安装好一台虚拟机，进行配置。\n安装wget1sudo yum install wget\n\n源配置详见\n安装ifconfig1sudo yum install net-tools\n\n桥接网络设置详见\n设置开机菜单选择时间缩短选择时间，快速开机。\nCentOS7\n1sudo vi /etc/grub2.cfg\n\n\n\nCentOS克隆准备由于克隆后两台虚拟机会有相同的MAC地址，发生冲突，需要提前先进行一些配置。\n删除MAC和UUID\n1sudo vi /etc/sysconfig/network-scripts/ifcfg-enp0s3\n将HWADDR和UUID注释掉，解除其与网卡名称的绑定。\n删除文件\n该文件将网卡名和MAC地址进行了绑定，克隆后的虚拟机会使用新的MAC地址，将会出错。\n1sudo rm /etc/udev/rules.d/70-persistent-ipoib.rules\n\n重启网络服务\n1service network restart\n\n生成快照安装完后，在VirtualBox中生成快照，之后可用于克隆。\n\n\n\n\n克隆虚拟机\n\n更新克隆机的MAC地址\n\n修改静态IP克隆后的虚拟机和其父本有一样的IP，需要修改。\n12# 打开后对IPADDR进行更改sudo vi /etc/sysconfig/network-scripts/ifcfg-enp0s3\n主机名修改这一步不是必要的。\nCentOS7\n1sudo vi /etc/hostname\n设置hostname,重启生效。\n1node01\n\nCentOS6\n1sudo vi /etc/sysconfig/network\n设置hostname,重启生效。\n1HOSTNAME=node01\n\n设置hostname映射\n将hostname映射到IP\n1sudo vi /etc/hosts\n设置映射\n1234# 本机可以不设置192.168.1.101 node01# 设置别的机器的映射192.168.1.102 node02","thumbnail":"post/Linux/VirtualBox下CentOS克隆/cover.jpg","plink":"https://beginc.github.io/post/Linux/VirtualBox下CentOS克隆/"},{"title":"各种源配置","date":"2019-09-09T13:51:07.000Z","date_formatted":{"ll":"Sep 9, 2019","L":"09/09/2019","MM-DD":"09-09"},"updated":"2020-01-08T08:31:06.570Z","content":"CentOS源备份repo文件\n123cd /etc/yum.repos.d/sudo mkdir bakmv ./*.repo ./bak/\n\n下载repo文件\n阿里源\n1wget http://mirrors.aliyun.com/repo/Centos-7.repo\n\n网易源\n1wget http://mirrors.163.com/.help/CentOS7-Base-163.repo\n\n重建yum缓存\n12sudo yum clean allsudo yum makecache\n\nPip源1pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n","thumbnail":"post/其他/各种源配置/cover.jpg","plink":"https://beginc.github.io/post/其他/各种源配置/"},{"title":"CentOS网络配置","date":"2019-09-09T13:34:39.000Z","date_formatted":{"ll":"Sep 9, 2019","L":"09/09/2019","MM-DD":"09-09"},"updated":"2020-01-08T08:31:06.569Z","content":"虚拟机三种网络模式NAT虚拟机借助NAT的功能，通过宿主机所在的网络来访问公网。在这种模式下宿主机成为双网卡主机，同时参与现有的宿主局域网和新建的虚拟局域网，但由于加设了一个虚拟的NAT服务器，使得虚拟局域网内的虚拟机在对外访问时，使用的则是宿主机的IP地址，这样从外部网络来看，只能看到宿主机，完全看不到新建的虚拟局域网。\n桥接虚拟机就像是局域网中的一台独立的主机，需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。\nHost-Only在这种模式下宿主机上的所有虚拟机是可以相互通信的，但虚拟机和真实的网络是被隔离开的。\n在这种模式下新建了一个由所有虚拟机与宿主机所构成的局域网，但该局域网与宿主机本身所处的现有局域网是相互独立的，如果不做额外路由设置，这两个局域网之间不会连通，因此新建的局域网可以认为是一个单独从属于当前宿主机的私有网络，其成员为当前宿主机和相关的所有虚拟机。\nCentOS7网络配置桥接配置手工为虚拟系统配置IP地址、子网掩码。\n查看当前网卡\n\n\n可知当前使用的为enp0s3\n修改配置文件\n12cd /etc/sysconfig/network-scripts/sudo vi ./ifcfg-enp0s3\n\n主要参数\nBOOTPROTO获取的ip地址类型，static和none为静态地址，dhcp为动态获取ip地址\nONBOOT设置网卡是否在Linux系统启动时激活\nIPADDRIP地址\nNETMASK子网掩码\nGATEWAY网关地址\nDNS1首选DNS服务器\nDNS2辅助选DNS服务器\n123456789101112# 静态IPBOOTPROTO=static# 设置IPIPADDR=192.168.1.101# 网络掩码NETMASK=255.255.255.0# 和本机网关保持一致GATEWAY=192.168.1.1# DNS1DNS1=114.114.114.114# DNS2DNS2=8.8.8.8\n\n重启网络服务\n1service network restart\n","thumbnail":"post/Linux/CentOS网络配置/cover.jpg","plink":"https://beginc.github.io/post/Linux/CentOS网络配置/"},{"title":"Java集合","date":"2019-09-07T14:57:07.000Z","date_formatted":{"ll":"Sep 7, 2019","L":"09/07/2019","MM-DD":"09-07"},"updated":"2020-01-08T08:31:06.570Z","content":"Java集合体系简介Collection接口所有集合类的根接口。\nList接口一种有序列表的集合。\nSet接口一种保证没有重复元素的集合。\nMap接口一种通过键值查找的映射表集合。\nIteratorJava统一访问集合的方式。\nList创建\nList.of(...)\n1234List&lt;Integer&gt; list = List.of(1, 2, 3, 4);for (Integer item : list) &#123;    System.out.println(item);&#125;\n\n访问\nvoid add(E e)在末尾添加一个元素：\nvoid add(int index, E e)在指定索引添加一个元素\nint remove(int index)删除指定索引的元素\nint remove(Object e)删除某个元素\nE get(int index)获取指定索引的元素\nint size()获取链表大小（包含元素的个数）\n12345678910111213141516171819202122232425262728List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"1\");list.add(\"2\");// 1// 2for (String item : list) &#123;    System.out.println(item);&#125;list.remove(0);// 2for (String item : list) &#123;    System.out.println(item);&#125;// 2System.out.println(list.get(0));list.add(\"Hello\");// HelloSystem.out.println(list.get(1));list.remove(\"Hello\");// 2for (String item : list) &#123;    System.out.println(item);&#125;// 1System.out.println(list.size());\n\n与数组的相互转换\nObject[] toArray()\n缺点是丢失了类型信息\n1Object[] array = list.toArray();\n\nObject[] toArray(T[])\n传入一个类型相同的数组，List内部自动把元素复制到传入的Array中。\n如果传入的数组不够大，那么List内部会创建一个新的刚好够大的数组，填充后返回。\n如果传入的数组比List元素还要多，那么填充完元素后，剩下的数组元素一律填充null。\n1Integer[] array = list.toArray(new Integer[4]);\n\n\n\n实现类ArrayList底层实现为数组。\nLinkedList底层实现为链表。\n","thumbnail":"post/Java/Java语言/Java集合/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/"},{"title":"Pipeline框架设计---Registry","date":"2019-09-06T03:36:45.000Z","date_formatted":{"ll":"Sep 6, 2019","L":"09/06/2019","MM-DD":"09-06"},"updated":"2020-01-08T08:31:06.569Z","content":"设计目的要使得框架能够实现全配置文件化，必须提供某种机制，使得我们能够实例化任何在配置文件中所指定的类，并传递配置文件中的相关参数。\nmmdet的实现Registry类实现一个注册工厂类，用来存储和检索注册的类\n12345678910111213141516171819202122232425262728293031323334353637383940class Registry(object):    def __init__(self, name):        self._name = name        self._module_dict = dict()    def __repr__(self):        format_str = self.__class__.__name__ + '(name=&#123;&#125;, items=&#123;&#125;)'.format(            self._name, list(self._module_dict.keys()))        return format_str    @property    def name(self):        return self._name    @property    def module_dict(self):        return self._module_dict    def get(self, key):        return self._module_dict.get(key, None)    def _register_module(self, module_class):        \"\"\"Register a module.        Args:            module (:obj:`nn.Module`): Module to be registered.        \"\"\"        if not inspect.isclass(module_class):            raise TypeError('module must be a class, but got &#123;&#125;'.format(                type(module_class)))        module_name = module_class.__name__        if module_name in self._module_dict:            raise KeyError('&#123;&#125; is already registered in &#123;&#125;'.format(                module_name, self.name))        self._module_dict[module_name] = module_class    def register_module(self, cls):        self._register_module(cls)        return cls\n\n实例化工厂为每个类别的模块实例化一个注册工厂\n123456789from mmdet.utils import RegistryBACKBONES = Registry('backbone')NECKS = Registry('neck')ROI_EXTRACTORS = Registry('roi_extractor')SHARED_HEADS = Registry('shared_head')HEADS = Registry('head')LOSSES = Registry('loss')DETECTORS = Registry('detector')\n\n注册使用注解的形式进行注册\n123@DETECTORS.register_moduleclass SingleStageDetector(BaseDetector):    ...\n\nPipeline框架Registry设计Registry使用全称限定名进行注册\n在检索的时候才进行模块的导入(lazy-import)\n12345678910111213141516171819202122232425262728293031from importlib import import_moduleclass Registry():    def __init__(self):        self._catelog = dict()    def register(self, name, fullname):        assert name not in self._catelog        self._catelog[name] = fullname    def register_package(self, package, *modules):        for module in modules:            self.register(module, package + '.' + module)    def get(self, name):        assert name in self._catelog, \"&#123;&#125; hasn't been registered yet!\".format(            name)        fullname = self._catelog[name]        path = fullname.split(\".\")        module_name = \".\".join(path[:-1])        cls_name = path[-1]        module = import_module(module_name)        cls = getattr(module, cls_name)        return cls    @property    def catelog(self):        return self._catelog\n\n注册1234567891011REGISTRY = Registry()# TransformREGISTRY.register_package('mxnet.gluon.data.vision.transforms',                          'ToTensor', 'Normalize', 'RandomResizedCrop',                          'CenterCrop', 'Resize', 'RandomFlipLeftRight',                          'RandomColorJitter', 'RandomLighting')# DatasetREGISTRY.register_package('mxnet.gluon.data.vision', 'CIFAR10', 'MNIST')# ModelREGISTRY.register_package('pipeline.model.resnet', 'ResNetV1', 'ResNetV2')\n\n实现用配置文件实例化类cfg中需包含type字段指明类名（需要注册过）\ncfg中可嵌套包含其他类（builder进行递归实例化）\n12345model_config = dict(    type='ResNetV1',    num_layers=18,    classes=10)\n\nbuilder\n12345678910111213from .registry import REGISTRYdef build(cfg):    if isinstance(cfg, dict) and \"type\" in cfg:        name = cfg.get(\"type\")        cls = REGISTRY.get(name)        params = &#123;&#125;        for key, val in cfg.items():            if key != 'type':                params[key] = build(val)        return cls(**params)    return cfg","thumbnail":"post/Python/Pipeline框架设计-Registry/cover.jpg","plink":"https://beginc.github.io/post/Python/Pipeline框架设计-Registry/"},{"title":"SSM整合","date":"2019-09-06T02:57:06.000Z","date_formatted":{"ll":"Sep 6, 2019","L":"09/06/2019","MM-DD":"09-06"},"updated":"2020-01-28T14:55:26.141Z","content":"创建Maven项目packaging为war\n编译设置123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;org.example&lt;/groupId&gt;  &lt;artifactId&gt;ssm&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;ssm Maven Webapp&lt;/name&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;  &lt;/properties&gt;&lt;/project&gt;\n配置maven-tomcat7-plugin插件可通过tomcat7:run运行项目\n1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;groupId&gt;cn.edu.njust&lt;/groupId&gt;    &lt;artifactId&gt;Reading&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;    &lt;/properties&gt;        &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;contextReloadable&gt;true&lt;/contextReloadable&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n引入依赖Servlet + JSP + JSTL + Annotationscope设置为provided（因为在tomcat容器中有依赖，不设置为provided会发生冲突）\n1234567891011121314151617181920212223&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;    &lt;version&gt;2.2.1&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.annotation&lt;/groupId&gt;    &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;    &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;\n\nMyBatismybatis\nmybatis-spring整合包\n12345678910&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;2.0.3&lt;/version&gt;&lt;/dependency&gt;\n\n数据库mysql驱动\ndruid数据库连接池\n12345678910&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;\n\nSpringMVCspring-webmvc已经包含了：spring-context\nspring-bean\nspring-core\nspring-expression\nspring-aop\nspring-web\n\n12345&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\nSpringMVC JSON绑定（Jackson）jackson-databind已经依赖了jackson-core和jackson-annotation\n12345&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt;\n\nAspectj Weaver12345&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;    &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;\n\nSpring事务管理12345678910&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;    &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n\nSpring测试spring-test + junit\n123456789101112&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;\n\n日志logback-classic为日志框架\nspring-core在这个包里面把commons-logging依赖剔除掉\njcl-over-slf4j将commons-logging日志API转发到slf4j，做一个桥接\nlogback-ext-spring支持web环境下的日志\n1234567891011121314151617181920212223242526&lt;dependency&gt;    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;    &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;    &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;exclusions&gt;    &lt;exclusion&gt;        &lt;groupId&gt;commons-logging&lt;/groupId&gt;        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;    &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;    &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.logback-extensions&lt;/groupId&gt;    &lt;artifactId&gt;logback-ext-spring&lt;/artifactId&gt;    &lt;version&gt;0.1.4&lt;/version&gt;&lt;/dependency&gt;\n\n配置文件spring-context.xml开启注解扫描\n配置数据源\n整合MyBatis\n配置事务控制\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;    &lt;!--引入JDBC配置文件--&gt;    &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;    &lt;!--开启注解扫描--&gt;    &lt;context:component-scan base-package=\"cn.edu.njust\"&gt;        &lt;!--不扫描Contoller，让SpringMVC扫描--&gt;        &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;    &lt;/context:component-scan&gt;    &lt;!--整合MyBatis--&gt;    &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt;        &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt;        &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;        &lt;property name=\"configLocation\" value=\"classpath:mybatis.xml\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;        &lt;property name=\"basePackage\" value=\"cn.edu.njust.dao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--事务控制--&gt;    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;tx:advice id=\"generalTransactionAdvice\" transaction-manager=\"transactionManager\"&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=\"find*\" read-only=\"true\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"insert*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"update*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"delete*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"save*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;aop:config&gt;        &lt;!--业务层所有方法加上事务--&gt;        &lt;aop:pointcut id=\"generalPointcut\" expression=\"execution(* cn.edu.njust.service.impl.*(..))\"/&gt;        &lt;aop:advisor advice-ref=\"generalTransactionAdvice\" pointcut-ref=\"generalPointcut\"&gt;&lt;/aop:advisor&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\nmybatis.xml指定日志框架\n开启延迟加载\n1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"        \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;!--指定日志框架为slf4j--&gt;        &lt;setting name=\"logImpl\" value=\"slf4j\"/&gt;        &lt;!--开启延迟加载--&gt;        &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt;        &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;    &lt;/settings&gt;        &lt;typeAliases&gt;        &lt;package name=\"cn.edu.njust.pojo\"/&gt;    &lt;/typeAliases&gt;&lt;/configuration&gt;\n\nspring-mvc.xml开启注解扫描\n开启注解驱动(自动配置HandlerMapping和HandlerAdapter)\n静态资源交给default-servlet-handler\n123456789101112131415161718&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;!--开启注解--&gt;    &lt;context:component-scan base-package=\"cn.edu.njust.controller\"/&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!--配置视图解析器--&gt;    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"/&gt;    &lt;!--处理静态资源--&gt;    &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt;\n\nlogback.xml12345678910&lt;configuration&gt;    &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;        &lt;encoder&gt;            &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%thread][%-5level][%logger&#123;36&#125;]: %msg%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;root level=\"INFO\"&gt;        &lt;appender-ref ref=\"STDOUT\"/&gt;    &lt;/root&gt;&lt;/configuration&gt;\n\nweb.xmlSpring配置文件路径启动参数\nLogback配置文件路径启动参数\nCharacterEncodingFilter编码过滤器\nContextLoaderListener为Spring配置文件加载监听器\nLogbackConfigListener为Logback加载监听器\nDispatcherServlet前端控制器\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!--Spring配置文件位置--&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring-context.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--Logback配置文件位置--&gt;  &lt;context-param&gt;    &lt;param-name&gt;logbackConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:logback.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--SpringWeb编码过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;!--Spring配置文件加载监听器--&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!--Logback加载监听器--&gt;  &lt;listener&gt;    &lt;listener-class&gt;ch.qos.logback.ext.spring.web.LogbackConfigListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!--SpringMVC前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n测试Pojo1234567891011121314151617181920212223242526272829303132public class TestAccount &#123;    private Integer id;    private Integer money;    public TestAccount() &#123;    &#125;    @Override    public String toString() &#123;        return \"TestAccount&#123;\" +                \"id=\" + id +                \", money=\" + money +                '&#125;';    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public Integer getMoney() &#123;        return money;    &#125;    public void setMoney(Integer money) &#123;        this.money = money;    &#125;&#125;\n\nDao1234567@Repository(\"testDao\")@Mapperpublic interface TestDao &#123;    @Select(\"select * from account\")    List&lt;TestAccount&gt; findAll();&#125;\n\nService1234567891011121314@Service(\"testService\")public class TestServiceImpl implements TestService &#123;    @Resource(name = \"testDao\")    private TestDao testDao;    public void setTestDao(TestDao testDao) &#123;        this.testDao = testDao;    &#125;    @Override    public List&lt;TestAccount&gt; findAll() &#123;        return testDao.findAll();    &#125;&#125;\n\nController12345678910111213141516171819202122@Controller@RequestMapping(\"/test\")public class TestController &#123;    @Resource(name = \"testService\")    private TestService testService;    public void setTestService(TestServiceImpl testService) &#123;        this.testService = testService;    &#125;    @RequestMapping(\"/findall\")    public String testFindAll()&#123;        System.out.println(123);        List&lt;TestAccount&gt; accounts = testService.findAll();        for (TestAccount account : accounts) &#123;            System.out.println(account);        &#125;        return \"/index.jsp\";    &#125;&#125;\n\n\n启动1mvn tomcat7:run","thumbnail":"post/Java/SSM/SSM整合/cover.jpg","plink":"https://beginc.github.io/post/Java/SSM/SSM整合/"},{"title":"Java泛型","date":"2019-09-04T11:32:04.000Z","date_formatted":{"ll":"Sep 4, 2019","L":"09/04/2019","MM-DD":"09-04"},"updated":"2020-01-08T08:31:06.570Z","content":"使用泛型泛型类123class Container&lt;T&gt;&#123;    private T data;&#125;\n\n泛型方法123456789101112131415class Container&lt;T&gt;&#123;    private T data;    public Container(T data) &#123;        this.data = data;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;&#125;\n\n静态方法泛型类型&lt;T&gt;不能用于静态方法\n1234567891011121314151617181920class Container&lt;T&gt;&#123;    private T data;    public Container(T data) &#123;        this.data = data;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;    // 报错    public static void staticMethod(T data)&#123;    &#125;&#125;\n\n在static修饰符后面加一个，编译就能通过, 这个&lt;T&gt;和Container&lt;T&gt;类型的&lt;T&gt;已经没有任何关系了，可换一个泛型类型\n123456789101112131415161718192021222324252627282930313233343536373839404142class Container&lt;T&gt;&#123;    private T data;        public Container(T data) &#123;        this.data = data;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;    // 报错    public static void staticMethod(T data)&#123;    &#125;&#125;class Container&lt;T&gt;&#123;    private T data;        public Container(T data) &#123;        this.data = data;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;    // 不报错    public static &lt;K&gt; void staticMethod(K data)&#123;    &#125;&#125;\n\n多个泛型类型1234class Container&lt;T, K&gt;&#123;    private T dataT;    private T dataK;&#125;\n\n擦拭法Java语言的泛型实现方式是擦拭法（Type Erasure）。\n所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的，编译器把类型&lt;T&gt;一律改成Object，并且根据&lt;T&gt;实现安全的强制类型转换。\n123456789101112131415161718192021222324252627282930313233// 编写的代码class Container&lt;T&gt;&#123;    private T data;        public Container(T data) &#123;        this.data = data;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;&#125;// JVM执行的代码class Container&#123;    private Object data;        public Container(Object data) &#123;        this.data = data;    &#125;    public Object getData() &#123;        return data;    &#125;    public void setData(Object data) &#123;        this.data = data;    &#125;&#125;\n\n缺点\n无法使用基本类型作为泛型，因为基本类型无法转换为Object\n\n无法取得带泛型的Class\n1234Container&lt;String&gt; c1 = new Container&lt;String&gt;(\"123\");Container&lt;Integer&gt; c2 = new Container&lt;String&gt;(123);// trueSystem.out.println(c1.getClass() == c2.getClass());\n\n无法判断带泛型的Class\n123Container&lt;String&gt; c1 = new Container&lt;String&gt;(\"123\");// trueSystem.out.println(c1 isinstance of Container&lt;Integer&gt;.class);\n\n不能实例化T类型\n12// 错误T data = new T();\n\n导致不恰当的覆写方法\n1234// 与equals(Object t)冲突public boolean equals(T t)&#123;    return this == t;&#125;\n\n\n泛型继承TODO\n通配符extends通配符","thumbnail":"post/Java/Java语言/Java泛型/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java泛型/"},{"title":"Java注解","date":"2019-08-29T14:02:41.000Z","date_formatted":{"ll":"Aug 29, 2019","L":"08/29/2019","MM-DD":"08-29"},"updated":"2020-01-08T08:31:06.570Z","content":"注解简介注解只是一种特殊的注释，不对代码逻辑产生任何影响，具体的作用取决于程序如何使用这个注释信息。\n注解的作用编译器使用的注解\n编译后即被丢弃，不会进入.class文件\n@Override编译器检查方法是否正确实现了重载\n@SupressWarnings告诉编译器忽略此处的警告\n工具处理\n有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。\n运行期可读取\n此类注解在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。\n注解的参数注解可配置一些基本参数。大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。\n所有基本类型\nString\n枚举类型\n定义注解基本定义@interface定义注解\n类型 名字() default 值定义参数\n12345public @interface Report &#123;    int type() default 0;    String level() default \"info\";    String value() default \"\";&#125;\n\n元注解元注解负责修饰注解，对注解进行一些配置\n@Target\n指定注解可以放的位置(必配置)\nElementType.TYPE类或接口\nElementType.FIELD字段\nElementType.METHOD方法\nElementType.CONSTRUCTOR构造方法\nElementType.PARAMETER方法参数\n12345678910111213141516// 只能加在方法上@Target(ElementType.METHOD)public @interface Report &#123;    int type() default 0;    String level() default \"info\";    String value() default \"\";&#125;// 加在多个位置上@Target(&#123;    ElementType.METHOD,    ElementType.FIELD&#125;)public @interface Report &#123;    ...&#125;\n\n@Retention\n定义注解的生命周期(必配置)\nRetentionPolicy.SOURCE注解在编译期就被丢掉了\nRetentionPolicy.CLASS注解仅保存在class文件中，它们不会被加载进JVM(默认)\nRetentionPolicy.RUNTIME注解会被加载进JVM，并且在运行期可以被程序读取\n@Repeatable\n定义注解是否可重复进行注解\n123456789101112@Repeatable@Target(ElementType.TYPE)public @interface Report &#123;    int type() default 0;    String level() default \"info\";    String value() default \"\";&#125;@Report(type=1, level=\"debug\")@Report(type=2, level=\"warning\")public class Hello &#123;&#125;\n\n@Inherited\n定义子类是否可以继承父类的注解，仅针对@Target(ElementType.TYPE)有效\n使用注解RetentionPolicy.SOURCE(暂不讨论)RetentionPolicy.CLASS(暂不讨论)RetentionPolicy.RUNTIME获取注解\n详见\n使用注解\n如何使用注解完全取决于程序的目的\n12345678910111213141516171819202122232425262728293031@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface OptimizerConfig&#123;    String type() default \"SGD\";    double lr() default 0.02;    int epoch() default 12;&#125;@OptimizerConfig(type=\"SGD\", lr=0.01, epoch=20)class Model&#123;    private String type = \"SGD\";    private double lr = 0.02;    private int epoch = 12;    public Model()&#123;        Class cls = getClass();        if(cls.isAnnotationPresent(OptimizerConfig.class))&#123;            OptimizerConfig config = (OptimizerConfig) cls.getAnnotation(OptimizerConfig.class);            this.type =  config.type();            this.lr = config.lr();            this.epoch = config.epoch();        &#125;    &#125;    public void run()&#123;        System.out.println(\"Running with config:\");        System.out.println(\"Type:\" + type);        System.out.println(\"Lr:\" + lr);        System.out.println(\"Epoch:\" + epoch);    &#125;&#125;\n\n\n","thumbnail":"post/Java/Java语言/Java注解/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java注解/"},{"title":"SpringIoC容器","date":"2019-08-29T06:50:15.000Z","date_formatted":{"ll":"Aug 29, 2019","L":"08/29/2019","MM-DD":"08-29"},"updated":"2020-01-25T15:14:50.198Z","content":"Spring IoC容器Spring IoC容器简介IoC容器提供了控制反转(IoC)和依赖注入(DI)功能，程序将bean的创建过程交由IoC容器完成，并为其完成依赖属性的注入。\n两种IoC容器的实现ClassPathXmlApplicationContext读取classpath下的配置文件建立IoC容器\nFileSystemXmlApplicationContext读取文件系统下的配置文件建立IoC容器\n基本配置12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"student\" class=\"bean.Student\"&gt;       &lt;/bean&gt;&lt;/beans&gt;\n\n导入其他容器配置文件路径都是相对于当前配置文件\n12345&lt;beans&gt;    &lt;import resource=\"spring-services.xml\"/&gt;    &lt;bean id=\"studentService\" class=\"service.StudentService\"/&gt;&lt;/beans&gt;\n\n使用IoC容器getBean()\n可一次读取多个配置文件\n12ApplicationContext context = new ClassPathXmlApplicationContext(\"spring-context.xml\", \"spring-tx.xml\");Student student = context.getBean(\"student\", Student.class);\n\nBean命名id唯一，不可有特殊符号\nname唯一，可有特殊符号\n12&lt;bean id=\"student\" class=\"bean.Student\"/&gt;&lt;bean name=\"student1\" class=\"bean.Student\"/&gt;\n别名1&lt;alias name=\"student\" alias=\"johnStudent\"/&gt;\n\n初始化Bean无参构造器调用无参构造器\n使用setter注入依赖\n123&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;property name=\"name\" value=\"John\"/&gt;&lt;/bean&gt;\n\n静态工厂class此时指定工厂类\nfactory-method指定生产该对象的工厂方法\n123456public class StudentFactory &#123;    public static Student buildStudentStatic() &#123;        return new Student();    &#125;&#125;\n\n123&lt;bean id=\"bean\" class=\"factory.StudentFactory\" factory-method=\"buildStudentStatic\"&gt;    &lt;property name=\"name\" value=\"John\"/&gt;&lt;/bean&gt;\n\n实例工厂先实例化工厂，再生产Bean\nfactory-bean指定工厂实例\nfactory-method指定工厂方法\n1234567public class StudentFactory &#123;    public Student buildStudent() &#123;        return new Student();    &#125;&#125;\n\n12345&lt;bean id=\"studentFactory\" class=\"factory.StudentFactory\"&gt;&lt;/bean&gt;&lt;bean id=\"student\" factory-bean=\"studentFactory\" factory-method=\"buildStudent\"&gt;&lt;/bean&gt;\n\n依赖注入方式使用构造函数注入constructor-arg\n按名字注入\n必须在编译时开启debug flag, 或者在构造器上写上@ConstructorProperties({&quot;id&quot;, &quot;name&quot;, &quot;age&quot;})\n123456// @ConstructorProperties(&#123;\"id\", \"name\", \"age\"&#125;)public Student(Integer id, String name, Integer age) &#123;    this.id = id;    this.name = name;    this.age = age;&#125;\n\n12345&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;constructor-arg name=\"id\" value=\"1\"/&gt;    &lt;constructor-arg name=\"name\" value=\"John\"/&gt;    &lt;constructor-arg name=\"age\" value=\"18\"/&gt;&lt;/bean&gt;\n\n按类型注入\n1234public Student(Integer id, String name) &#123;    this.id = id;    this.name = name;&#125;\n\n1234&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;constructor-arg type=\"java.lang.Integer\" value=\"1\"/&gt;    &lt;constructor-arg type=\"java.lang.String\" value=\"John\"/&gt;&lt;/bean&gt;\n\n按索引注入\n12345public Student(Integer id, String name, Integer age) &#123;    this.id = id;    this.name = name;    this.age = age;&#125;\n\n12345&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;constructor-arg index=\"0\" value=\"1\"/&gt;    &lt;constructor-arg index=\"1\" value=\"John\"/&gt;    &lt;constructor-arg index=\"2\" value=\"18\"/&gt;&lt;/bean&gt;\n\n构造器注入循环依赖\n若beanA依赖beanB，beanB依赖beanA，则使用构造器注入会引起不可解决的循环依赖，解决方法为换为使用setter注入（先建立对象，再进行注入）\n使用setter注入必须要有无参构造器\n1234567891011public void setId(Integer id) &#123;    this.id = id;&#125;public void setName(String name) &#123;    this.name = name;&#125;public void setAge(Integer age) &#123;    this.age = age;&#125;\n\n12345&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;property name=\"id\" value=\"1\"/&gt;    &lt;property name=\"name\" value=\"John\"/&gt;    &lt;property name=\"age\" value=\"18\"/&gt;&lt;/bean&gt;\n\n依赖注入具体配置普通类型value\n&lt;idref&gt;\nvalue\n12345&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;property name=\"id\" value=\"1\"/&gt;    &lt;property name=\"name\" value=\"John\"/&gt;    &lt;property name=\"age\" value=\"18\"/&gt;&lt;/bean&gt;\n\n&lt;idref&gt;\n用来引用另外一个bean的id(String)，并进行检查，确保其存在\n1234567&lt;bean id=\"John\" class=\"bean.Student\"&gt;&lt;/bean&gt;&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;property name=\"name\"&gt;        &lt;idref bean=\"John\"/&gt;    &lt;property/&gt;&lt;/bean&gt;\n\n等价于name值为John + 检查引用的John这个bean是否存在\n12345&lt;bean id=\"John\" class=\"bean.Student\"&gt;&lt;/bean&gt;&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;property name=\"name\" value=\"referencedBean\"/&gt;&lt;/bean&gt;\n\n引用ref\n12345&lt;bean id=\"bean1\" class=\"bean.Bean1\"&gt;&lt;/bean&gt;&lt;bean id=\"bean2\" class=\"bean.Bean2\"&gt;    &lt;property name=\"Bean1\" ref=\"bean1\"/&gt; &lt;/bean&gt;\n\nparent\n在基于spring框架开发的项目中，如果有多个bean都是一个类的实例，如配置多个数据源时，大部分配置的属性都一样，只有少部分不一样，经常是copy上一个的定义，然后修改不一样的地方。其实spring bean定义也可以和对象一样进行继承。\n123456789&lt;bean id=\"student1\" class=\"bean.Student\"&gt;    &lt;property name=\"id\" value=\"1\"/&gt;    &lt;property name=\"name\" value=\"John\"/&gt;    &lt;property name=\"age\" value=\"18\"/&gt;&lt;/bean&gt;&lt;!-- name和age与student1一致--&gt;&lt;bean id=\"student2\" class=\"bean.Student\" parent=\"student1\"&gt;    &lt;property name=\"id\" value=\"2\"/&gt;&lt;/bean&gt;\n\n内部Bean类似于匿名对象，内部Bean不需要id\n内部类的scope属性被忽略，因为总是和外部Bean一起创建\n1234567&lt;bean id=\"bean2\" class=\"bean.Bean2\"&gt;    &lt;property name=\"Bean1\"&gt;        &lt;bean class=\"bean.Bean1\"&gt;            &lt;property name=\"name\" value=\"John\"/&gt;        &lt;/bean&gt;    &lt;/property&gt; &lt;/bean&gt;\n\n集合list对应List\nmap对应Map\nset对应Set\nprops对应Properties\nProperty\nkey-type指定键类型\nvalue-type指定值类型\n也可以不指定类型，由Spring来自动转换\n12345678&lt;bean id=\"bean\" class=\"bean.Bean\"&gt;    &lt;property name=\"prop\"&gt;        &lt;props key-type=\"java.lang.String\" value-type=\"java.lang.String\"&gt;            &lt;prop key=\"name\"&gt;John&lt;/prop&gt;            &lt;prop key=\"age\"&gt;18&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\n\nList\nvalue-type指定值类型\n也可以不指定类型，由Spring来自动转换\n12345678&lt;bean id=\"bean\" class=\"bean.Bean\"&gt;    &lt;property name=\"prop\"&gt;        &lt;list value-type=\"java.lang.String\"&gt;            &lt;value&gt;John&lt;/value&gt;            &lt;ref bean=\"anotherBean\"/&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;\n\nMap\nkey-type指定键类型\nvalue-type指定值类型\n也可以不指定类型，由Spring来自动转换\n12345678&lt;bean id=\"bean\" class=\"bean.Bean\"&gt;    &lt;property name=\"prop\"&gt;        &lt;map key-type=\"java.lang.String\" value-type=\"java.lang.String\"&gt;            &lt;entry key=\"name\" value=\"John\"/&gt;            &lt;entry key=\"anotherBean\" value-ref=\"anotherBean\"/&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;\n\nSet\nvalue-type指定值类型\n也可以不指定类型，由Spring来自动转换\n12345678&lt;bean id=\"bean\" class=\"bean.Bean\"&gt;    &lt;property name=\"prop\"&gt;        &lt;set value-type=\"java.lang.String\"&gt;            &lt;value&gt;John&lt;/value&gt;            &lt;ref bean=\"anotherBean\"/&gt;        &lt;/set&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n使用parent和merge进行集合的合并\n在使用parent进行继承时，可指定集合属性的merge为true，即可将集合与parent的集合进行合并（相同的属性会被child替换）\n不能合并类型不同的集合\n123456789101112131415&lt;bean id=\"bean1\" class=\"bean.Bean\"&gt;    &lt;property name=\"prop\"&gt;        &lt;map&gt;            &lt;entry key=\"name\" value=\"John\"/&gt;            &lt;entry key=\"anotherBean\" value-ref=\"anotherBean\"/&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"bean2\" class=\"bean.Bean\"&gt;    &lt;property name=\"prop\"&gt;        &lt;map merge=\"true\"&gt;            &lt;entry key=\"name\" value=\"Bob\"/&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n空值&lt;null/&gt;用以区分空值和空字符串\n空串\n123&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;property name=\"name\" value=\"\"/&gt;&lt;/bean&gt;\n\n空值\n12345&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;property name=\"name\"&gt;        &lt;null/&gt;&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n复合属性路径上的最后一个属性可为null，前面的不能为null\n注入fred属性中bob属性中的sammy属性值123\n123&lt;bean id=\"something\" class=\"things.ThingOne\"&gt;    &lt;property name=\"fred.bob.sammy\" value=\"123\" /&gt;&lt;/bean&gt;","thumbnail":"post/Java/Spring/Spring IoC容器/cover.png","plink":"https://beginc.github.io/post/Java/Spring/Spring IoC容器/"},{"title":"配置文件整合","date":"2019-08-28T14:27:01.000Z","date_formatted":{"ll":"Aug 28, 2019","L":"08/28/2019","MM-DD":"08-28"},"updated":"2020-01-28T14:55:52.302Z","content":"SpringapplicationContext.xml\n12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"        xmlns:context=\"http://www.springframework.org/schema/context\"        xmlns:aop=\"http://www.springframework.org/schema/aop\"        xmlns:tx=\"http://www.springframework.org/schema/tx\"        xmlns:mvc=\"http://www.springframework.org/schema/mvc\"        xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;&lt;/beans&gt;\n\nSpringMVCspring-mvc.xml\n123456789101112&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txmlns:context=\"http://www.springframework.org/schema/context\"\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\txsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;\t &lt;/beans&gt;\n\nMyBatisSqlMapConfig.xml\n1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;/configuration&gt;\n\nmapper.xml\n1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"\"&gt;&lt;/mapper&gt;\n\nJDBCjdbc.properties\n1234jdbc.driver&#x3D;com.mysql.cj.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;easypay?serverTimezone&#x3D;UTCjdbc.username&#x3D;rootjdbc.password&#x3D;Hgld521125\n\nLogbacklogback.xml\n12345678910&lt;configuration&gt;    &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;        &lt;encoder&gt;            &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%thread][%-5level][%logger&#123;36&#125;]: %msg%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;root level=\"WARN\"&gt;        &lt;appender-ref ref=\"STDOUT\"/&gt;    &lt;/root&gt;&lt;/configuration&gt;\n\nSSM整合pom.xml\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;org.example&lt;/groupId&gt;  &lt;artifactId&gt;ssm&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;ssm Maven Webapp&lt;/name&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;!--JaveEE API--&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;      &lt;version&gt;3.1.0&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;      &lt;version&gt;2.2.1&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;jstl&lt;/artifactId&gt;      &lt;version&gt;1.2&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!--注解API--&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.annotation&lt;/groupId&gt;      &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;      &lt;version&gt;1.3.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Mybatis--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;      &lt;version&gt;3.4.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;      &lt;version&gt;2.0.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Database--&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;8.0.15&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;      &lt;artifactId&gt;druid&lt;/artifactId&gt;      &lt;version&gt;1.1.10&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Spring--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.aspectj&lt;/groupId&gt;      &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;      &lt;version&gt;1.9.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;      &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;      &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Spring MVC JSON Biding--&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;      &lt;version&gt;2.9.8&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Testing--&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.12&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;      &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!--Logging--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;      &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;      &lt;exclusions&gt;        &lt;exclusion&gt;          &lt;groupId&gt;commons-logging&lt;/groupId&gt;          &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;      &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;      &lt;version&gt;1.2.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;      &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;      &lt;version&gt;1.7.25&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.logback-extensions&lt;/groupId&gt;      &lt;artifactId&gt;logback-ext-spring&lt;/artifactId&gt;      &lt;version&gt;0.1.4&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;plugins&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;2.2&lt;/version&gt;        &lt;configuration&gt;          &lt;contextReloadable&gt;true&lt;/contextReloadable&gt;          &lt;port&gt;8080&lt;/port&gt;          &lt;path&gt;/ssm&lt;/path&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;    &lt;/plugins&gt;  &lt;/build&gt;&lt;/project&gt;\n\nspring-context.xml\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;    &lt;!--引入JDBC配置文件--&gt;    &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;    &lt;!--开启注解扫描--&gt;    &lt;context:component-scan base-package=\"cn.edu.njust\"&gt;        &lt;!--不扫描Contoller，让SpringMVC扫描--&gt;        &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;    &lt;/context:component-scan&gt;    &lt;!--整合MyBatis--&gt;    &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt;        &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt;        &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;        &lt;property name=\"configLocation\" value=\"classpath:mybatis.xml\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;        &lt;property name=\"basePackage\" value=\"cn.edu.njust.dao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--事务控制--&gt;    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;tx:advice id=\"generalTransactionAdvice\" transaction-manager=\"transactionManager\"&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=\"find*\" read-only=\"true\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"insert*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"update*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"delete*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"save*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;aop:config&gt;        &lt;!--业务层所有方法加上事务--&gt;        &lt;aop:pointcut id=\"generalPointcut\" expression=\"execution(* cn.edu.njust.service.impl.*.*(..))\"/&gt;        &lt;aop:advisor advice-ref=\"generalTransactionAdvice\" pointcut-ref=\"generalPointcut\"&gt;&lt;/aop:advisor&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\nspring-mvc.xml\n123456789101112131415161718&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;!--开启注解--&gt;    &lt;context:component-scan base-package=\"cn.edu.njust.controller\"/&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!--配置视图解析器--&gt;    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"/&gt;    &lt;!--处理静态资源--&gt;    &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt;\n\nweb.xml\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!--Spring配置文件位置--&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring-context.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--Logback配置文件位置--&gt;  &lt;context-param&gt;    &lt;param-name&gt;logbackConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:logback.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--SpringWeb编码过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;!--Spring配置文件加载监听器--&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!--Logback加载监听器--&gt;  &lt;listener&gt;    &lt;listener-class&gt;ch.qos.logback.ext.spring.web.LogbackConfigListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!--SpringMVC前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;","thumbnail":"post/其他/配置文件整合/cover.jpg","plink":"https://beginc.github.io/post/其他/配置文件整合/"},{"title":"Java日志框架概况","date":"2019-08-28T14:26:52.000Z","date_formatted":{"ll":"Aug 28, 2019","L":"08/28/2019","MM-DD":"08-28"},"updated":"2020-02-08T02:39:09.488Z","content":"Java日志框架分类日志门面框架主要用于适配各种不同的底层日志实现框架，提供统一访问的API，充当门面\nslf4j\ncommons-logging\n日志实现框架实现具体的记录日志的操作的框架\nlog4j\nlog4j2\nlogback\njava.util.logging\n共性组件Logger提供日志输出的API，但往往不做任何事，实际的操作都通过其他组件实现。\nLoggerManager组织管理所有Logger。\nLevel日志级别。可通过设置日志级别，让高于高级别的日志进行输出，低于该级别的日志无法输出。\nAppender日志输出目的地。通常可输出到Console, File, Socket等地方。\nFilter日志过滤器。用于在日志输出前对其进行过滤。\nFormatter日志格式化。\n层次Logger往往被组织成一个树状层次结构，每个Logger(除了RootLogger)都有一个Parent Logger。\nLogger一般是通过名字来进行层次划分(使用.)。\ncn.edu.njust.dao.UserDao的Parent Logger为cn.edu.njust.dao(若不存在，则继续上溯，直到RootLogger)\n\n\n继承性未经配置的Child Logger往往继承或加性继承（合并）了Parent Logger的一些配置，如Level，Appender，Hierachy等。\n","thumbnail":"post/Java/日志/Java日志框架概况/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/Java日志框架概况/"},{"title":"5-MyBatis缓存","date":"2019-08-28T13:04:25.000Z","date_formatted":{"ll":"Aug 28, 2019","L":"08/28/2019","MM-DD":"08-28"},"updated":"2020-01-23T14:17:58.458Z","content":"一级缓存一级缓存介绍在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。在每个SqlSession中持有Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户。\n一级缓存配置在SqlMapConfig.xml的settings中进行配置，默认值为SESSION\nSESSION缓存作用一次SqlSession\nSTATEMENT只对当前执行的这一个Statement有效\n1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt;    &lt;/settings&gt;&lt;/configuration&gt;\n\n1234student = mapper.findById(1); //不走缓存student = mapper.findById(1); //缓存student = mapper.findById(1); //缓存student = mapper.findById(1); //缓存\n\n调试分析\n进入invoke方法????\n\n调用cachedMapperMethod，methodCache为ConcurrentHashMap，在其中获取存储的方法对象\n\n没有找到该method对象，说明没有进行过调用，为其新建一个MapperMethod对象，存储到methodCache中\n\n执行方法\n\n\n一级缓存特点SESSION Scope缓存只在一个session内有效\n一个session内多次使用同一个查询，除第一次查询外，其他走缓存\n使用修改（增，删，改）操作后一级缓存会被清空失效\n无法适应分布式下多个session的缓解，一级缓存会导致读脏数据\n一级缓存导致脏读123456789101112131415161718192021SqlSession session1 = factory.openSession(true);SqlSession session2 = factory.openSession(true);StudentMapper mapper1 = session1.getMapper(StudentMapper.class);StudentMapper mapper2 = session2.getMapper(StudentMapper.class);// Student(name=\"Bob\")student = mapper1.findById(1); //不走缓存，建立缓存// Student(name=\"Bob\")student = mapper1.findById(1); //session1缓存// Student(name=\"Bob\")student = mapper2.findById(1); //不走缓存，建立缓存// Student(name=\"Bob\")student = mapper2.findById(1); //session2缓存student.setName(\"John\"); mapper1.updateName(student); //更新名字，session1清空缓存session1.commit()// Student(name=\"John\")student = mapper1.findById(1); //不走缓存，建立缓存// Student(name=\"Bob\")student = mapper2.findById(1); //继续走缓存，脏读!!\n\n解决方法\n将localSessionScope设置为STATEMENT\n","thumbnail":"post/Java/MyBatis/5-MyBatis缓存/cover.jpg","plink":"https://beginc.github.io/post/Java/MyBatis/5-MyBatis缓存/"},{"title":"Java反射","date":"2019-08-28T12:32:12.000Z","date_formatted":{"ll":"Aug 28, 2019","L":"08/28/2019","MM-DD":"08-28"},"updated":"2020-01-08T08:31:06.570Z","content":"Class与反射 Java除了基本类型外都是class，class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。该Class包含了该类型的所有信息。通过Class实例获取类信息的方式叫做反射\n类动态加载JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。利用这个特性我们可以在运行时动态加载类。\n获取Class实例类型.class\n1Class cls = String.class;\n\n类的实例.getClass()\n12String s = \"123\";Class cls = s.getClass();\n\nClass.forName(&quot;java.lang.String&quot;)\n\n类的信息cls.getName()获取全称\ncls.getSimpleName()获取类名\ncls.getPackage().getName()获取包名\ncls.isInterface()\ncls.isEnum()\ncls.isArray()\ncls.isPrimitive()\n字段信息获取Field对象Field getField(name)根据字段名获取某个public的field（包括父类）\nField getDeclaredField(name)根据字段名获取当前类的某个field（不包括父类)\nField[] getFields()获取所有public的field（包括父类）\nField[] getDeclaredFields()获取当前类的所有field（不包括父类）\n获取Field对象的信息getName()返回字段名称，例如，&quot;name&quot;；\ngetType()返回字段类型，也是一个Class实例，例如，String.class；\ngetModifiers()返回字段的修饰符，它是一个int，不同的bit表示不同的含义。\n可用Modifier类的一些静态方法来判断\n123456789Field f = String.class.getDeclaredField(\"value\");f.getName(); // \"value\"f.getType(); // class [B 表示byte[]类型int m = f.getModifiers();Modifier.isFinal(m); // trueModifier.isPublic(m); // falseModifier.isProtected(m); // falseModifier.isPrivate(m); // trueModifier.isStatic(m); // false\n\n\n获取Field的值字段.get(类的实例对象)访问实例对象的该字段值\n字段.setAccessible(true)设置实例对象该字段值的可访问性\n123456789101112131415161718public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Object p = new Person(\"Xiao Ming\");        Class c = p.getClass();        Field f = c.getDeclaredField(\"name\");        Object value = f.get(p);        System.out.println(value); // \"Xiao Ming\"    &#125;&#125;class Person &#123;    private String name;    public Person(String name) &#123;        this.name = name;    &#125;&#125;\n\n设置字段的值字段.set(类的实例对象, 值)访问实例对象的该字段值\n字段.setAccessible(true)设置实例对象该字段值的可访问性\n123456789101112131415161718192021222324public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Person p = new Person(\"Xiao Ming\");        System.out.println(p.getName()); // \"Xiao Ming\"        Class c = p.getClass();        Field f = c.getDeclaredField(\"name\");        f.setAccessible(true);        f.set(p, \"Xiao Hong\");        System.out.println(p.getName()); // \"Xiao Hong\"    &#125;&#125;class Person &#123;    private String name;    public Person(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return this.name;    &#125;&#125;\n\n方法信息获取Method对象Method getMethod(name, Class...)获取某个public的Method（包括父类）(第二个参数parameterTypes是按声明顺序标识该方法形参类型，可用于重载的情况)\nMethod getDeclaredMethod(name, Class...)获取当前类的某个Method（不包括父类）(第二个参数parameterTypes是按声明顺序标识该方法形参类型，可用于重载的情况)\nMethod[] getMethods()获取所有public的Method（包括父类）\nMethod[] getDeclaredMethods()获取当前类的所有Method（不包括父类）\n获取Method信息getName()返回方法名称，例如：&quot;getScore&quot;；\ngetReturnType()返回方法返回值类型，也是一个Class实例，例如：String.class；\ngetParameterTypes()返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}；\ngetModifiers()返回方法的修饰符，它是一个int，不同的bit表示不同的含义。\n调用MethodMethod.invoke(对象实例，...)传入对象实例和参数(静态方法第一个参数为null)\nMethod.setAccessible(true)调用非public方法时需要设置允许调用\n构造方法信息直接使用无参构造方法创建实例newInstance()\n1Persons p = Persons.class.newInstance();\n\n获取Constructor对象getConstructor(Class...)获取某个public的Constructor。\ngetDeclaredConstructor(Class...)获取某个Constructor。\ngetConstructors()获取所有public的Constructor。\ngetDeclaredConstructors()获取所有Constructor。\n调用ConstructornewInstance()\nsetAccessable(true)获取访问权限\n12Constructor cons1 = Integer.class.getConstructor(int.class);Integer n1 = (Integer) cons1.newInstance(123);\n\n注解信息判断注解是否存在Class.isAnnotationPresent(Class)\nField.isAnnotationPresent(Class)\nMethod.isAnnotationPresent(Class)\nConstructor.isAnnotationPresent(Class)\n获取Annotation对象获取指定的注解(需要手动转型)\nClass.getAnnotation(Class)\nField.getAnnotation(Class)\nMethod.getAnnotation(Class)\nConstructor.getAnnotation(Class)\n获取所有的注解\nClass.getAnnotations()\nField.getAnnotations()\nMethod.getAnnotations()\nConstructor.getAnnotations()\n12345678910111213141516171819202122232425262728293031@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface OptimizerConfig&#123;    String type() default \"SGD\";    double lr() default 0.02;    int epoch() default 12;&#125;@OptimizerConfig(type=\"SGD\", lr=0.01, epoch=20)class Model&#123;    private String type = \"SGD\";    private double lr = 0.02;    private int epoch = 12;    public Model()&#123;        Class cls = getClass();        if(cls.isAnnotationPresent(OptimizerConfig.class))&#123;            OptimizerConfig config = (OptimizerConfig) cls.getAnnotation(OptimizerConfig.class);            this.type =  config.type();            this.lr = config.lr();            this.epoch = config.epoch();        &#125;    &#125;    public void run()&#123;        System.out.println(\"Running with config:\");        System.out.println(\"Type:\" + type);        System.out.println(\"Lr:\" + lr);        System.out.println(\"Epoch:\" + epoch);    &#125;&#125;\n\n获取方法参数的注解\n方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。\n12345678910111213141516public void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) &#123;&#125;// 获取Method实例:Method m = ...// 获取所有参数的Annotation:Annotation[][] annos = m.getParameterAnnotations();// 第一个参数（索引为0）的所有Annotation:Annotation[] annosOfName = annos[0];for (Annotation anno : annosOfName) &#123;    if (anno instanceof Range) &#123; // @Range注解        Range r = (Range) anno;    &#125;    if (anno instanceof NotNull) &#123; // @NotNull注解        NotNull n = (NotNull) anno;    &#125;&#125;\n\n获取继承关系获取父类的ClassgetSuperClass()\n12Class cls = Integer.class;Class superCls = cls.getSuperClass();\n\n获取Interface用来查询类实现的接口(只返回直接实现的接口，不返回父类实现的)\ngetInterfaces()\n123Class cls = Integer.class;// Interface也是ClassClass[] interfaces = cls.getInterfaces();\n\n判断继承关系isinstanceof, A isinstancesof B当A为B类或者B类的子类时，返回true(向下判断)\nisAssignableFrom, A.isAssignableFrom(B)当B能向上转型为A时返回true(向上判断)\n动态代理动态代理技术即可实现在运行时动态创建实现某个Interface的实例。动态代理实际上是JDK在运行期动态创建class字节码并加载的过程。\nInvocationHandler负责进行具体方法的实现或者增强\nProxy.newProxyInstance()创建代理对象\n1234567891011121314151617181920212223242526272829interface Flyable&#123;    public void fly();&#125;public class Main &#123;    public static void main(String[] args) &#123;        InvocationHandler handler = new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                if(method.getName().equals(\"fly\"))&#123;                    System.out.println(\"判断该方法为目标方法，下面开始实现\");                    System.out.println(\"Flying.....\");                    System.out.println(\"方法实现结束\");                &#125;                System.out.println(\"下面返回参数\");                return null;            &#125;        &#125;;        Flyable flyable = (Flyable) Proxy.newProxyInstance(                Flyable.class.getClassLoader(), // 传入ClassLoader                new Class[]&#123;Flyable.class&#125;, // 传入要实现的接口                handler // 传入InvocationHandler        );        flyable.fly();    &#125;&#125;\n\n\n\n","thumbnail":"post/Java/Java语言/Java反射/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java反射/"},{"title":"1-SpringMVC入门","date":"2019-08-24T13:42:43.000Z","date_formatted":{"ll":"Aug 24, 2019","L":"08/24/2019","MM-DD":"08-24"},"updated":"2020-02-08T02:43:10.258Z","content":"创建Maven项目创建时使用maven-archetype-webapp\n编译设置123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;org.example&lt;/groupId&gt;  &lt;artifactId&gt;springmvc-01&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;springmvc-01 Maven Webapp&lt;/name&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;  &lt;/properties&gt;&lt;/project&gt;\n\n引入依赖Spring WebMVC\nJavaWeb包(由于tomcat中有这些包, 所以scope需要设置为provided)Servlet\nJSP\n\n12345678910111213141516171819&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;        &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;        &lt;version&gt;2.2.1&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;        &lt;version&gt;3.1.0&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n配置核心组件配置核心配置文件springmvc.xml开启包扫描\n开启Spring MVC注解支持\n1234567891011121314&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txmlns:context=\"http://www.springframework.org/schema/context\"\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\txsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;\t&lt;context:component-scan base-package=\"controller\"/&gt;\t&lt;mvc:annotation-driven/&gt;&lt;/beans&gt;\n\n前端控制器DispatcherServlet前端控制器DispatcherServlet拦截路径\n*.action\n/  拦截所有(包括静态资源不包括JSP)\n/* 拦截所有(包括静态资源和JSP, 会导致跳转到JSP页面被拦截导致出错)\n1234567891011121314151617181920&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;    &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n配置CharacterEncodingFilter解决POST乱码12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;    &lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;    &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;    &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n处理器映射器和处理器适配器方式一: 分别配置123456789101112131415161718&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;context:component-scan base-package=\"controller\"/&gt;    &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"&gt;    &lt;/bean&gt;    &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n方式二: 开启annotation-driven默认都进行了配置1234567891011121314&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;context:component-scan base-package=\"controller\"/&gt;    &lt;mvc:annotation-driven/&gt;&lt;/beans&gt;\n\n\n视图解析器prefix指定视图名称的前缀\nsuffix指定视图名称的后缀\n路径示意图\n\n\n12345678910111213141516171819&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;context:component-scan base-package=\"controller\"/&gt;    &lt;mvc:annotation-driven/&gt;    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;        &lt;property name=\"prefix\" value=\"/\"&gt;&lt;/property&gt;        &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\nController编写123456789@Controller@RequestMapping(\"/account\")public class AccountController &#123;    @RequestMapping(path = \"\")    public String index()&#123;        return \"index\";    &#125;&#125;","thumbnail":"post/Java/SpringMVC/1-SpringMVC入门/cover.png","plink":"https://beginc.github.io/post/Java/SpringMVC/1-SpringMVC入门/"},{"title":"MyBatis整合Spring","date":"2019-08-24T04:38:49.000Z","date_formatted":{"ll":"Aug 24, 2019","L":"08/24/2019","MM-DD":"08-24"},"updated":"2020-01-08T08:31:06.570Z","content":"创建Maven项目编译设置12345678910111213141516&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\t&lt;groupId&gt;cn.edu.njust&lt;/groupId&gt;\t&lt;artifactId&gt;mybatis01&lt;/artifactId&gt;\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\t&lt;name&gt;mybatis01&lt;/name&gt;\t&lt;description&gt;mybatis01&lt;/description&gt;\t&lt;properties&gt;\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\t\t&lt;maven.compiler.source&gt;12&lt;/maven.compiler.source&gt;\t\t&lt;maven.compiler.target&gt;12&lt;/maven.compiler.target&gt;\t&lt;/properties&gt;&lt;/project&gt;\n\n引入依赖MySQL驱动\nJUnit\nMyBatis\nSpring\nmybatis-spring整合包\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.17&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.10&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.2.7&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.annotation&lt;/groupId&gt;        &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;        &lt;version&gt;1.3.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;version&gt;1.2.2&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n建立pojo对象Student\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package pojo;public class Student &#123;\tprivate int id;\tprivate String name;\tprivate CClass cclass;\tpublic Student() &#123;\t&#125;\tpublic Student(int id, String name, CClass cclass) &#123;\t\tsuper();\t\tthis.id = id;\t\tthis.name = name;\t\tthis.cclass = cclass;\t&#125;\t/**\t * @return the name\t */\tpublic String getName() &#123;\t\treturn name;\t&#125;\t/**\t * @param name the name to set\t */\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t/**\t * @return the cclass\t */\tpublic CClass getCclass() &#123;\t\treturn cclass;\t&#125;\t/**\t * @param cclass the cclass to set\t */\tpublic void setCclass(CClass cclass) &#123;\t\tthis.cclass = cclass;\t&#125;\t/**\t * \t * @return\t */\t@Override\tpublic String toString() &#123;\t\treturn \"Student [id=\" + id + \", name=\" + name + \", cclass=\" + cclass + \"]\";\t&#125;&#125;\n\nCClass\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package pojo;import java.util.List;public class CClass &#123;\tprivate int id;\tprivate String name;\tprivate List&lt;Student&gt; students;\tpublic CClass() &#123;\t&#125;\tpublic CClass(int id, String name, List&lt;Student&gt; students) &#123;\t\tsuper();\t\tthis.id = id;\t\tthis.name = name;\t\tthis.students = students;\t&#125;\t/**\t * @return the id\t */\tpublic int getId() &#123;\t\treturn id;\t&#125;\t/**\t * @param id the id to set\t */\tpublic void setId(int id) &#123;\t\tthis.id = id;\t&#125;\t/**\t * @return the name\t */\tpublic String getName() &#123;\t\treturn name;\t&#125;\t/**\t * @param name the name to set\t */\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t/**\t * @return the students\t */\tpublic List&lt;Student&gt; getStudents() &#123;\t\treturn students;\t&#125;\t/**\t * @param students the students to set\t */\tpublic void setStudents(List&lt;Student&gt; students) &#123;\t\tthis.students = students;\t&#125;\t/**\t * \t * @return\t */\t@Override\tpublic String toString() &#123;\t\treturn \"CClass [id=\" + id + \", name=\" + name + \", students=\" + students + \"]\";\t&#125;&#125;\n\n为pojo对象建立SqlMap配置文件Student.xml\n123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"mapper.StudentMapper\"&gt;\t&lt;resultMap type=\"Student\" id=\"studentResultMap\"&gt;\t\t&lt;id column=\"sid\" property=\"id\"/&gt;\t\t&lt;result column=\"sname\" property=\"name\"/&gt;\t\t\t\t&lt;association property=\"cclass\" javaType=\"CClass\"&gt;\t\t\t&lt;id column=\"cid\" property=\"id\"/&gt;\t\t\t&lt;result column=\"cname\" property=\"name\"/&gt;\t\t&lt;/association&gt;\t&lt;/resultMap&gt;\t&lt;select id=\"findStudentById\" parameterType=\"Integer\" resultMap=\"studentResultMap\"&gt;\t\tselect student.id as sid, student.name as sname, age, class.id as cid, class.name as cname\t\tfrom student join class\t\ton student.classId = class.id\t\twhere student.id = #&#123;value&#125;\t&lt;/select&gt;&lt;/mapper&gt;\n\nCClass\n123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"mapper.CClassMapper\"&gt;\t&lt;resultMap type=\"CClass\" id=\"cclassResultMap\"&gt;\t\t&lt;id column=\"cid\" property=\"id\"/&gt;\t\t&lt;result column=\"cname\" property=\"name\"/&gt;\t\t\t\t&lt;collection property=\"students\" ofType=\"Student\"&gt;\t\t\t&lt;id column=\"sid\" property=\"id\"/&gt;\t\t\t&lt;result column=\"sname\" property=\"name\"/&gt;\t\t&lt;/collection&gt;\t&lt;/resultMap&gt;\t&lt;select id=\"findCClassById\" parameterType=\"Integer\" resultMap=\"cclassResultMap\"&gt;\t\tselect class.id as cid, class.name as cname, student.id as sid, student.name as sname, age\t\tfrom student join class\t\ton student.classId = class.id\t\twhere class.id = #&#123;value&#125;\t&lt;/select&gt;&lt;/mapper&gt;\n\n配置SqlMapConfig.xml只需配置mappers\n1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;\t&lt;typeAliases&gt;\t\t&lt;package name=\"pojo\"/&gt;\t&lt;/typeAliases&gt;\t\t&lt;mappers&gt;\t\t&lt;mapper resource=\"sqlmap/Student.xml\"/&gt;\t\t&lt;mapper resource=\"sqlmap/CClass.xml\"/&gt;\t&lt;/mappers&gt;&lt;/configuration&gt;\n\nDAO开发配置applicationContext.xmldataSource\nSqlSessionFactory注入dataSource\n注入SqlMapConfig.xml的位置\n\n123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txmlns:context=\"http://www.springframework.org/schema/context\"\txmlns:aop=\"http://www.springframework.org/schema/aop\"\txmlns:tx=\"http://www.springframework.org/schema/tx\"\txsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;\t\t&lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;\t\t&lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimezone=UTC\"/&gt;\t\t&lt;property name=\"username\" value=\"root\"/&gt;\t\t&lt;property name=\"password\" value=\"Hgld521125\"/&gt;\t&lt;/bean&gt;\t\t&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;\t\t&lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\t\t&lt;property name=\"configLocation\" value=\"classpath:SqlMapConfig.xml\"/&gt;\t&lt;/bean&gt;&lt;/beans&gt;\n\nDAO + DAOImplStudentDAO\n1234567package dao;import pojo.Student;public interface StudentDAO &#123;\tpublic Student findStudentById(Integer id);&#125;\n\nStudentDAOImpl\n继承SqlSessionDaoSupport\n通过this.getSqlSession来获取SqlSession\nSpring管理SqlSessionFactory的时候不允许手动关闭session\n1234567891011121314151617package dao.impl;import org.apache.ibatis.session.SqlSession;import org.mybatis.spring.support.SqlSessionDaoSupport;import dao.StudentDAO;import pojo.Student;public class StudentDAOImpl extends SqlSessionDaoSupport implements StudentDAO &#123;\tpublic Student findStudentById(Integer id) &#123;\t\tSqlSession session = this.getSqlSession();\t\tStudent student = session.selectOne(\"findStudentById\", 1);\t\t// session.close();\t\treturn student;\t&#125;&#125;\n\n为StudentDAOImpl注入SqlSessionFacotry\n123&lt;bean id=\"studentDAO\" class=\"dao.impl.StudentDAOImpl\"&gt;    &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt;&lt;/bean&gt;\n\n编写测试123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Test01 &#123;\t@Resource(name = \"studentDAO\")\tprivate StudentDAO studentDAO;\t@Test\tpublic void test01() &#123;\t\tStudent student = this.studentDAO.findStudentById(1);\t\tSystem.out.println(student);\t&#125;&#125;\n\nMapper动态代理开发建立mapper1234567package mapper;import pojo.CClass;public interface CClassMapper &#123;\tpublic CClass findCClassById(Integer id);&#125;\n\n配置applicationContext.xml同\n方式一: MapperFactoryBean该工厂负责生产动态代理产生的mapper\n注入sqlSessionFactory\n注入mapperInterface\n1234&lt;bean id=\"cclassMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt;    &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt;    &lt;property name=\"mapperInterface\" value=\"mapper.CClassMapper\"/&gt;&lt;/bean&gt;\n\n编写测试\n1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Test01 &#123;\t@Resource(name = \"cclassMapper\")\tprivate CClassMapper mapper;\t@Test\tpublic void test02() &#123;\t\tSystem.out.println(mapper.findCClassById(1));\t&#125;&#125;\n\n方式二: MapperScannerConfigurer自动注入sqlSessionFactory\n自动扫描包(及其子包)管理mapper(无需手动为每个mapper配置MapperFactoryBean)\n无需设置id, 直接用mapper名.class在context中获取mapper\n123&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;\t&lt;property name=\"basePackage\" value=\"mapper\" /&gt;&lt;/bean&gt;\n\n\n编写测试\n开启自动扫描, 无法通过name注入mapper, 必须通过context.getBean(CClassMapper.class)获取mapper或者使用@Autowired按类型注入mapper\n1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Test01 &#123;\t@Autowired\tprivate CClassMapper mapper;\t@Test\tpublic void test02() &#123;\t\tSystem.out.println(mapper.findCClassById(1));\t&#125;&#125;\n\n","thumbnail":"post/Java/MyBatis/MyBatis整合Spring/cover.jpg","plink":"https://beginc.github.io/post/Java/MyBatis/MyBatis整合Spring/"},{"title":"4-MyBatis关联查询","date":"2019-08-24T01:58:29.000Z","date_formatted":{"ll":"Aug 24, 2019","L":"08/24/2019","MM-DD":"08-24"},"updated":"2020-01-23T15:52:34.471Z","content":"一对一查询需求查询出账户的同时，将其对应的用户信息也查询出来。\nAccount关联User一个账户对应一个用户，用一个User对象表示。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Account &#123;    private Integer id;    private User user;    private Double money;    public Account(Integer id, User user, Double money) &#123;        this.id = id;        this.user = user;        this.money = money;    &#125;    public Account() &#123;    &#125;    @Override    public String toString() &#123;        return \"Account&#123;\" +                \"id=\" + id +                \", user=\" + user.getId() +                \", money=\" + money +                '&#125;';    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public User getUser() &#123;        return user;    &#125;    public void setUser(User user) &#123;        this.user = user;    &#125;    public Double getMoney() &#123;        return money;    &#125;    public void setMoney(Double money) &#123;        this.money = money;    &#125;&#125;\n\n关联查询编写ResultMapassociation表示一对一关联\ncolumn为用于查询对应用户信息的参数\nproperty为Account对象中User对象的属性名称\njavaType为关联对象的类型\nselect为用column查询用户信息的方法\nfetchTypeeager查询出账户时会马上查询出对应的用户\nlazy延迟加载，使用用户信息时才会查询\n\n123456789&lt;mapper namespace=\"mapper.AccountMapper\"&gt;    &lt;resultMap id=\"accountMap\" type=\"pojo.Account\"&gt;        &lt;id column=\"id\" property=\"id\"/&gt;        &lt;result column=\"money\" property=\"money\"/&gt;        &lt;association column=\"uid\" property=\"user\" javaType=\"pojo.User\" select=\"mapper.UserMapper.find\" fetchType=\"eager\"&gt;        &lt;/association&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;\n\nResultType换成ResultMap1234567&lt;select id=\"findAll\" resultMap=\"accountMap\"&gt;\t&lt;include refid=\"selectAllAttr\"/&gt;&lt;/select&gt;&lt;select id=\"find\" resultMap=\"accountMap\"&gt;\tselect * from account where id = #&#123;id&#125;&lt;/select&gt;\n\n一对多查询需求查询出用户的同时，将其对应的账户信息也查询出来。\nUser关联Account一个用户可有多个账户，用一个List&lt;Account&gt;表示。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class User &#123;    private Integer id;    private String username;    private Date birthday;    private String sex;    private String address;    private List&lt;Account&gt; accounts;    public User(Integer id, String username, Date birthday, String sex, String address, List&lt;Account&gt; accounts) &#123;        this.id = id;        this.username = username;        this.birthday = birthday;        this.sex = sex;        this.address = address;        this.accounts = accounts;    &#125;    public User() &#123;    &#125;    @Override    public String toString() &#123;        return \"User&#123;\" +                \"id=\" + id +                \", username='\" + username + '\\'' +                \", birthday=\" + birthday +                \", sex='\" + sex + '\\'' +                \", address='\" + address + '\\'' +                \", accounts=\" + accounts +                '&#125;';    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public Date getBirthday() &#123;        return birthday;    &#125;    public void setBirthday(Date birthday) &#123;        this.birthday = birthday;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;&#125;\n\n关联查询编写ResultMapcollection表示一对多关联\ncolumn为用于查询对应账户信息的参数\nproperty为User对象中List&lt;Account&gt;的属性名称\nofType为关联对象的类型\nselect为用column查询账户信息的方法\nfetchType\n123456789101112&lt;mapper namespace=\"mapper.UserMapper\"&gt;    &lt;resultMap id=\"userMap\" type=\"pojo.User\"&gt;        &lt;id column=\"id\" property=\"id\"/&gt;        &lt;id column=\"username\" property=\"username\"/&gt;        &lt;id column=\"address\" property=\"address\"/&gt;        &lt;id column=\"sex\" property=\"sex\"/&gt;        &lt;id column=\"birthday\" property=\"birthday\"/&gt;        &lt;collection property=\"accounts\" column=\"uid\" ofType=\"pojo.Account\" select=\"mapper.AccountMapper.findByUID\" fetchType=\"lazy\"&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;\n\nResultType换成ResultMap123456789101112131415161718192021222324252627&lt;select id=\"findAll\" resultMap=\"userMap\"&gt;    &lt;include refid=\"selectAllAttr\"/&gt;&lt;/select&gt;&lt;select id=\"find\" resultMap=\"userMap\"&gt;    select * from user where id = #&#123;id&#125;&lt;/select&gt;&lt;select id=\"findByUsernameOrSex\" parameterType=\"pojo.User\" resultMap=\"userMap\"&gt;    select * from user    &lt;where&gt;        &lt;if test=\"username != null\"&gt;            username = #&#123;username&#125;        &lt;/if&gt;        &lt;if test=\"sex != null\"&gt;            and sex = #&#123;sex&#125;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;&lt;select id=\"findInIDs\" parameterType=\"list\" resultMap=\"userMap\"&gt;    select * from user    &lt;where&gt;        &lt;foreach collection=\"list\" open=\"id in (\" close=\")\" separator=\",\" item=\"id\"&gt;            #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n双向关联中的死递归问题问题我们先看User类和Account类自动生成的toString方法。若我们调用User的toString方法，则会调用Account的toString方法，而Account的toString方法又会调用User的toString方法，如此往复，形成死递归。\nUser\n1234567891011@Overridepublic String toString() &#123;    return \"User&#123;\" +            \"id=\" + id +            \", username='\" + username + '\\'' +            \", birthday=\" + birthday +            \", sex='\" + sex + '\\'' +            \", address='\" + address + '\\'' +            \", accounts=\" + accounts +            '&#125;';&#125;\n\nAccount\n12345678@Overridepublic String toString() &#123;    return \"Account&#123;\" +            \"id=\" + id +            \", user=\" + user +            \", money=\" + money +            '&#125;';&#125;\n\n解决办法\n将Account类中调用User对象toString方法的地方改成user.getId()\n12345678@Overridepublic String toString() &#123;    return \"Account&#123;\" +            \"id=\" + id +            \", user=\" + (user != null ? String.valueOf(user.getId()) : \"null\") +            \", money=\" + money +            '&#125;';&#125;\n\n关联查询中的延迟加载在查询用户时，假若一个用户有10个账户，我们并不想查询用户时同时将用户的10个账户马上查询出来，而是希望在用到某个账户时，对该账户再进行查询，即延迟加载。\n全局开关lazyLoadingEnabled全局开关\naggressiveLazyLoading积极加载\n12345678910111213141516171819202122&lt;configuration&gt;    &lt;settings&gt;        &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt;        &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;    &lt;/settings&gt;    &lt;environments default=\"mysql\"&gt;        &lt;environment id=\"mysql\"&gt;            &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt;            &lt;dataSource type=\"POOLED\"&gt;                &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimezone=UTC\"/&gt;                &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;                &lt;property name=\"username\" value=\"root\"/&gt;                &lt;property name=\"password\" value=\"LQ18851195070\"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=\"SqlMap/User.xml\"/&gt;        &lt;mapper resource=\"SqlMap/Account.xml\"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n局部开关在配置关联时用fetchType指定\n123456789&lt;mapper namespace=\"mapper.AccountMapper\"&gt;    &lt;resultMap id=\"accountMap\" type=\"pojo.Account\"&gt;        &lt;id column=\"id\" property=\"id\"/&gt;        &lt;result column=\"money\" property=\"money\"/&gt;        &lt;association column=\"uid\" property=\"user\" javaType=\"pojo.User\" select=\"mapper.UserMapper.find\" fetchType=\"eager\"&gt;        &lt;/association&gt;    &lt;/resultMap&gt;&lt;/maper&gt;\n\n延迟加载的触发aggressiveLazyLoading为false只有调用getUser()获取用户对象时会触发延迟加载。\n12Account account = accountMapper.find(1);account.getUser();\n\naggressiveLazyLoading为true调用Account对象任何方法都会触发延迟加载。\n12Account account = accountMapper.find(1);account.getId();\n","thumbnail":"post/Java/MyBatis/4-MyBatis关联查询/cover.jpg","plink":"https://beginc.github.io/post/Java/MyBatis/4-MyBatis关联查询/"},{"title":"3-MyBatis动态SQL","date":"2019-08-24T01:12:43.000Z","date_formatted":{"ll":"Aug 24, 2019","L":"08/24/2019","MM-DD":"08-24"},"updated":"2020-01-23T13:37:22.700Z","content":"If-Where标签需求根据名字或性别查询用户(有名字就用名字，有性别就用性别，两者都有就都用)\n编写SqlMap文件用If来判断name和age是否存在, 仅当存在时才作为查询条件\nWhere可用于处理条件语句, 还可以去掉前导and(当只有sex做条件时, 需要去掉前面的and)\n1234567891011&lt;select id=\"findByUsernameOrSex\" parameterType=\"pojo.User\" resultType=\"pojo.User\"&gt;    select * from user    &lt;where&gt;        &lt;if test=\"username != null\"&gt;            username = #&#123;username&#125;        &lt;/if&gt;        &lt;if test=\"sex != null\"&gt;            and sex = #&#123;sex&#125;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;\n\n编写测试123456789101112131415161718192021222324252627282930@Testpublic void testUserFindByUsernameOrSex()&#123;    User user = new User();    List&lt;User&gt; users;    // 根据username查询    user.setUsername(\"罗浩文\");    users = userMapper.findByUsernameOrSex(user);    for (User user1 : users) &#123;        System.out.println(user1);    &#125;    System.out.println(\"-------------------------------------------------------------\");    // 根据sex查询    user.setUsername(null);    user.setSex(\"男\");    users = userMapper.findByUsernameOrSex(user);    for (User user1 : users) &#123;        System.out.println(user1);    &#125;    System.out.println(\"-------------------------------------------------------------\");    // 根据username和sex查询    user.setUsername(\"罗浩文\");    user.setSex(\"男\");    users = userMapper.findByUsernameOrSex(user);    for (User user1 : users) &#123;        System.out.println(user1);    &#125;&#125;\n\nForEach标签需求给定一串id, 查找id在其中的用户(不定数量的id)\n编写SqlMap文件collection指定要遍历的数组或集合\nitem指定取出的元素名\nopen指定前缀\nclose指定后缀\nseperator指定分隔符\n数组数组类型可写为iterator或list\n传数组时, collection名字必须为array\n12345678&lt;select id=\"findInIDs\" parameterType=\"list\" resultType=\"pojo.User\"&gt;    select * from user    &lt;where&gt;        &lt;foreach collection=\"array\" open=\"id in (\" close=\")\" separator=\",\" item=\"id\"&gt;            #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\nListList类型可写成list\n传List时, collection名字必须为list\n12345678&lt;select id=\"findInIDs\" parameterType=\"list\" resultType=\"pojo.User\"&gt;    select * from user    &lt;where&gt;        &lt;foreach collection=\"list\" open=\"id in (\" close=\")\" separator=\",\" item=\"id\"&gt;            #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n编写测试12345678@Testpublic void testUserFindInIDs()&#123;    List&lt;Integer&gt; ids = List.of(41, 42, 43);    List&lt;User&gt; users = userMapper.findInIDs(ids);    for (User user : users) &#123;        System.out.println(user);    &#125;&#125;\n\nSQL片段可用于提取常用的一些SQL片段\n123456&lt;sql id=\"selectAllAttr\"&gt;    select * from user&lt;/sql&gt;&lt;select id=\"findAll\" resultType=\"pojo.User\"&gt;    &lt;include refid=\"selectAllAttr\"/&gt;&lt;/select&gt;","thumbnail":"post/Java/MyBatis/3-MyBatis动态SQL/cover.jpg","plink":"https://beginc.github.io/post/Java/MyBatis/3-MyBatis动态SQL/"},{"title":"2-MyBatis动态代理开发","date":"2019-08-23T15:52:46.000Z","date_formatted":{"ll":"Aug 23, 2019","L":"08/23/2019","MM-DD":"08-23"},"updated":"2020-01-23T12:43:13.219Z","content":"动态代理开发简介使用动态代理开发，我们只需要负责定义查询相关的接口规范(Mapper)以及编写相应SQL语句，无需对接口进行实现，MyBatis借助动态代理技术为我们生成增强对象，实现相应的查询方法。\nMyBatis动态代理开发规范mapper方法名与SqlMap文件中对应statement的id一致\nmapper返回值类型与SqlMap文件中对应statement的返回类型一致\nmapper参数类型与SqlMap文件中对应statement的参数类型一致\nSqlMap中namespace必须为Mapper接口的全称\n建立UserMapper新建包mapper, 建立UserMapper接口\n123456789101112public interface UserMapper &#123;    List&lt;User&gt; findAll();    User find(Integer id);    void save(User user);    void update(User user);    void delete(Integer id);&#125;\n\n修改User.xml中的namespace123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"mapper.UserMapper\"&gt;    &lt;select id=\"findAll\" resultType=\"pojo.User\"&gt;        select * from user    &lt;/select&gt;    &lt;select id=\"find\" resultType=\"pojo.User\"&gt;        select * from user where id = #&#123;id&#125;    &lt;/select&gt;    &lt;delete id=\"delete\"&gt;        delete from user where id = #&#123;id&#125;    &lt;/delete&gt;    &lt;update id=\"update\"&gt;        update user set        username = #&#123;username&#125;, address = #&#123;address&#125;, sex = #&#123;sex&#125;, birthday = #&#123;birthday&#125;        where id = #&#123;id&#125;    &lt;/update&gt;    &lt;insert id=\"save\"&gt;        insert into user        (username, address, sex, birthday) values        (#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;)        &lt;selectKey keyProperty=\"id\" keyColumn=\"id\" resultType=\"Integer\"&gt;            select LAST_INSERT_ID()        &lt;/selectKey&gt;    &lt;/insert&gt;&lt;/mapper&gt;\n\n编写测试通过SqlSession获取Mapper\n调用Mapper的方法\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Test01 &#123;    private static final Logger logger = LoggerFactory.getLogger(Test01.class);    private static SqlSessionFactory factory;    private SqlSession session;    private UserMapper userMapper;    @BeforeClass    public static void setUpClass() throws IOException &#123;        factory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(\"SqlMapConfig.xml\"));    &#125;    @Before    public void setUp() throws IOException &#123;        session = factory.openSession();        userMapper = session.getMapper(UserMapper.class);    &#125;    @After    public void tearDown() &#123;        session.commit();        session.close();    &#125;    @Test    public void testUserFindAll() &#123;        List&lt;User&gt; users = userMapper.findAll();        for (User user : users) &#123;            System.out.println(user);        &#125;    &#125;    @Test    public void testUserSave() &#123;        User user = new User();        user.setAddress(\"耒阳\");        user.setUsername(\"罗浩文\");        user.setBirthday(new Date());        user.setSex(\"男\");        userMapper.save(user);        System.out.println(user);    &#125;    @Test    public void testUserDelete() &#123;        userMapper.delete(57);    &#125;    @Test    public void testUserFind() &#123;        User user = userMapper.find(41);        System.out.println(user);    &#125;&#125;\n\n\n","thumbnail":"post/Java/MyBatis/2-MyBatis动态代理开发/cover.jpg","plink":"https://beginc.github.io/post/Java/MyBatis/2-MyBatis动态代理开发/"},{"title":"1-MyBatis入门","date":"2019-08-23T13:49:25.000Z","date_formatted":{"ll":"Aug 23, 2019","L":"08/23/2019","MM-DD":"08-23"},"updated":"2020-01-23T12:30:54.684Z","content":"创建Maven项目编译设置12345678910111213141516171819202122&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-01&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\t&lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;11&lt;/source&gt;                    &lt;target&gt;11&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n引入依赖MySQL驱动\nJUnit\nMyBatis\nLogback\n12345678910111213141516171819202122232425262728&lt;dependencies&gt;\t&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;\t&lt;dependency&gt;\t\t&lt;groupId&gt;org.mybatis&lt;/groupId&gt;\t\t&lt;artifactId&gt;mybatis&lt;/artifactId&gt;\t\t&lt;version&gt;3.5.1&lt;/version&gt;\t&lt;/dependency&gt;\t&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;\t&lt;dependency&gt;\t\t&lt;groupId&gt;junit&lt;/groupId&gt;\t\t&lt;artifactId&gt;junit&lt;/artifactId&gt;\t\t&lt;version&gt;4.12&lt;/version&gt;\t\t&lt;scope&gt;test&lt;/scope&gt;\t&lt;/dependency&gt;\t&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;\t&lt;dependency&gt;\t\t&lt;groupId&gt;mysql&lt;/groupId&gt;\t\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\t\t&lt;version&gt;8.0.15&lt;/version&gt;\t&lt;/dependency&gt;\t&lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;\t&lt;dependency&gt;\t\t&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\t\t&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;\t\t&lt;version&gt;1.2.3&lt;/version&gt;\t\t&lt;scope&gt;test&lt;/scope&gt;\t&lt;/dependency&gt;&lt;/dependencies&gt;\n\n配置SqlMapConfig.xml在src/main/resource下建立SqlMapConfig.xml配置文件, 配置数据源和事务管理器。\n123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"        \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;environments default=\"mysql\"&gt;        &lt;environment id=\"mysql\"&gt;            &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt;            &lt;dataSource type=\"POOLED\"&gt;                &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimezone=UTC\"/&gt;                &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;                &lt;property name=\"username\" value=\"root\"/&gt;                &lt;property name=\"password\" value=\"LQ18851195070\"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;&lt;/configuration&gt;\n\n建立pojo对象必须提供一个无参数的构造方法\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class User &#123;    private Integer id;    private String username;    private Date birthday;    private String sex;    private String address;    public User(Integer id, String username, Date birthday, String sex, String address) &#123;        this.id = id;        this.username = username;        this.birthday = birthday;        this.sex = sex;        this.address = address;    &#125;    public User() &#123;    &#125;    @Override    public String toString() &#123;        return \"User&#123;\" +                \"id=\" + id +                \", username='\" + username + '\\'' +                \", birthday=\" + birthday +                \", sex='\" + sex + '\\'' +                \", address='\" + address + '\\'' +                '&#125;';    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public Date getBirthday() &#123;        return birthday;    &#125;    public void setBirthday(Date birthday) &#123;        this.birthday = birthday;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;&#125;\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Account &#123;    private Integer id;    private Integer uid;    private Double money;    public Account(Integer id, Integer uid, Double money) &#123;        this.id = id;        this.uid = uid;        this.money = money;    &#125;    public Account() &#123;    &#125;    @Override    public String toString() &#123;        return \"Account&#123;\" +                \"id=\" + id +                \", uid=\" + uid +                \", money=\" + money +                '&#125;';    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public Integer getUid() &#123;        return uid;    &#125;    public void setUid(Integer uid) &#123;        this.uid = uid;    &#125;    public Double getMoney() &#123;        return money;    &#125;    public void setMoney(Double money) &#123;        this.money = money;    &#125;&#125;\n\n为pojo对象建立SqlMap配置文件在src/main/resource下建立一个SqlMap文件夹, 建立User.xml(对于Account类下面操作相同)\n1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"User\"&gt;&lt;/mapper&gt;\n\n在SqlMapConfig.xml中引用该SqlMap文件\n12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;environments default=\"mysql\"&gt;        &lt;environment id=\"mysql\"&gt;            &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt;            &lt;dataSource type=\"POOLED\"&gt;                &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimezone=UTC\"/&gt;                &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;                &lt;property name=\"username\" value=\"root\"/&gt;                &lt;property name=\"password\" value=\"LQ18851195070\"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=\"SqlMap/User.xml\"/&gt;        &lt;mapper resource=\"SqlMap/Account.xml\"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n\n实现User基本需求List&lt;User&gt; findAll()\nUser find(Integer id)\nvoid update(User user)\nvoid save(User user)\nvoid delete(Integer id)\n查询单个User123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"User\"&gt;\t&lt;select id=\"find\" resultType=\"pojo.User\"&gt;        select * from user where id = #&#123;id&#125;    &lt;/select&gt;&lt;/mapper&gt;\n\n\n添加User123456789&lt;insert id=\"save\"&gt;\tinsert into user\t(username, address, sex, birthday) values\t(#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;)\t&lt;selectKey keyProperty=\"id\" keyColumn=\"id\" resultType=\"Integer\"&gt;\t\tselect LAST_INSERT_ID()\t&lt;/selectKey&gt;&lt;/insert&gt;\n\n\n更新User12345&lt;update id=\"update\"&gt;\tupdate user set\tusername = #&#123;username&#125;, address = #&#123;address&#125;, sex = #&#123;sex&#125;, birthday = #&#123;birthday&#125;\twhere id = #&#123;id&#125;&lt;/update&gt;\n\n\n删除User123&lt;delete id=\"delete\"&gt;\tdelete from user where id = #&#123;id&#125;&lt;/delete&gt;\n\n编写测试默认需要手动提交事务session.commit()\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Test01 &#123;    private static final Logger logger = LoggerFactory.getLogger(Test01.class);    private static SqlSessionFactory factory;    private SqlSession session;    @BeforeClass    public static void setUpClass() throws IOException &#123;        factory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(\"SqlMapConfig.xml\"));    &#125;    @Before    public void setUp() throws IOException &#123;        session = factory.openSession();    &#125;    @After    public void tearDown() &#123;        session.commit();        session.close();    &#125;    @Test    public void testUserFindAll() &#123;        List&lt;User&gt; users = session.selectList(\"User.findAll\");        for (User user : users) &#123;            System.out.println(user);        &#125;    &#125;    @Test    public void testUserSave() &#123;        User user = new User();        user.setAddress(\"耒阳\");        user.setUsername(\"罗浩文\");        user.setBirthday(new Date());        user.setSex(\"男\");        session.insert(\"User.save\", user);        System.out.println(user);    &#125;    @Test    public void testUserDelete() &#123;        session.delete(\"User.delete\", 55);    &#125;    @Test    public void testUserFind() &#123;        User user = session.selectOne(\"User.find\", 41);        System.out.println(user);    &#125;&#125;\n","thumbnail":"post/Java/MyBatis/1-MyBatis入门/cover.jpg","plink":"https://beginc.github.io/post/Java/MyBatis/1-MyBatis入门/"}]