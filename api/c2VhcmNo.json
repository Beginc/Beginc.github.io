[{"title":"Java集合之Vector","date":"2020-03-15T16:36:40.000Z","date_formatted":{"ll":"Mar 16, 2020","L":"03/16/2020","MM-DD":"03-16"},"updated":"2020-03-16T15:30:48.412Z","content":"继承体系实现了List接口。\n\n\n底层实现底层实现为数组。\n\n\n扩容策略可创建时指定capacityIncrement作为扩容的增量\n未指定时默认扩容为2倍\n\n\n序列化我们观察到elementData并未使用transient修饰。\n将elementData数组全部序列化了（未使用的空位也序列化了）\n\n\n线程安全Vector的方法都是用synchronized修饰的，为线程安全集合，但是效率低。\n\n\n与ArrayList的区别\n功能VectorArrayList\n\n底层实现数组数组\n\n扩容策略可指定扩容增量；默认扩容2倍不可指定扩容增量；默认扩容1.5倍\n\n线程安全线程安全线程不安全\n\n序列化序列化整个数组序列化数组中有效的数据\n","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之Vector/"},{"title":"Java并发之ThreadLocal","date":"2020-03-15T16:35:30.000Z","date_formatted":{"ll":"Mar 16, 2020","L":"03/16/2020","MM-DD":"03-16"},"updated":"2020-03-16T15:31:48.078Z","content":"ThreadLocal简介ThreadLocal用于为每个线程创建线程私有的存储空间，其他线程无法访问。\nThreadLocal使用创建不带默认值\n1ThreadLocal&lt;Integer&gt; local = new ThreadLocal&lt;&gt;();\n\n带默认值\n重写initialValue方法，返回一个默认值。\n当ThreadLocal对象没有赋值时就进行get，若设置了initialValue，则会返回initialValue\n123456ThreadLocal&lt;Integer&gt; local = new ThreadLocal&lt;&gt;() &#123;    @Override    protected Integer initialValue() &#123;        return 123;    &#125;&#125;;\n\n赋值一个ThreadLocal只能存储一个值。\n12ThreadLocal&lt;Integer&gt; local = new ThreadLocal&lt;&gt;();local.set(123);\n\n获取123ThreadLocal&lt;Integer&gt; local = new ThreadLocal&lt;&gt;();local.set(123);local.get();\n\n删除123ThreadLocal&lt;Integer&gt; local = new ThreadLocal&lt;&gt;();local.set(123);local.remove();\n\nThreadLocal原理ThreadLocal实际上存储在一个ThreadLocalMap的结构中，而这个结构存放在Thread对象中，保证每个线程私有。\nThreadLocal对象为Key\n存储的值为Value\n\n\nThreadLocal源码Get其实就是从ThreadLocalMap中获取以当前ThreadLocal对象为Key的Entry，返回其值。\n1234567891011121314151617public T get() &#123;    // 获取当前线程对象    Thread t = Thread.currentThread();    // 获取线程的ThreadLocalMap    ThreadLocalMap map = getMap(t);    // 获取线程的ThreadLocalMap已经创建了    if (map != null) &#123;        // 获取Entry        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null) &#123;            @SuppressWarnings(\"unchecked\")            T result = (T)e.value;            return result;        &#125;    &#125;    return setInitialValue();&#125;\n\n获取ThreadLocalMap\n123ThreadLocalMap getMap(Thread t) &#123;    return t.threadLocals;&#125;\n\nSet以当前ThreadLocal对象为Key，将value放入ThreadLocalMap对应的Entry中。\n12345678910111213public void set(T value) &#123;    // 获取当前线程对象    Thread t = Thread.currentThread();    // 获取线程的ThreadLocalMap    ThreadLocalMap map = getMap(t);    // 创建过了ThreadLocalMap直接放值    if (map != null) &#123;        map.set(this, value);    // 没创建过，创建一个    &#125; else &#123;        createMap(t, value);    &#125;&#125;\n\n创建ThreadLocalMap放在线程对象的threadLocals成员里。\n123void createMap(Thread t, T firstValue) &#123;    t.threadLocals = new ThreadLocalMap(this, firstValue);&#125;\n\nRemove从ThreadLocalMap中删除以当前ThreadLocal对象为Key的Entry。\n1234567public void remove() &#123;    // 获取线程的ThreadLocalMap    ThreadLocalMap m = getMap(Thread.currentThread());    if (m != null) &#123;        m.remove(this);    &#125;&#125;\n\nThreadLocalMap介绍ThreadLocalMap和HashMap一样也是一个哈希表，但是与HashMap有着很多不同。\n哈希算法ThreadLocalMap使用的哈希算法比较特别，它实现了完美散列，即可以无冲突的填满整个哈希表。\nHASH_INCREMENT为16405315279（有符号整数的黄金分割）\ni为第几个Entry\ncapacity为哈希表容量\n1index = (i + 1) * HASH_INCREMENT &amp; (capacity - 1);\n\n实验\n测试容量为32时该哈希算法的哈希分布情况。\n123456int capacity = 32;for (int i = 0; i &lt; capacity; i++) &#123;    System.out.print((i + 1) * HASH_INCREMENT &amp; (capacity - 1));    System.out.print(\" \");&#125;\n\n可看到，它实现了无冲突填满整个哈希表。\n17 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25 0\n\n扩容策略和HashMap相同，扩容为原来的一倍，哈希表的大小总是2的n次方。\n扩容时机\nloadFactor为 2 / 3\n冲突解决与HashMap不同的是，ThreadLocalMap使用开放定址法中的线性探测法来解决哈希冲突，即进行哈希后发现产生了冲突，则线性顺序向后查找，找到空闲的位置放下。\nThreadLocalMap源码解析Entry继承自WeakReference，并且在构造函数里把ThreadLocal对象包装进了WeakReference。\n123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;    /** The value associated with this ThreadLocal. */    Object value;    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;        super(k);        value = v;    &#125;&#125;\n\nThreadLocalMap内存泄露在Entry中，作为Key的ThreadLocal对象被包装进了WeakReference，引用关系如下图。\n实线箭头为强引用\n虚线箭头为弱引用\n\n\n假如我们使用完ThreadLocal后不再对其进行引用了，而线程依旧活跃，此时引用关系如下。\n此时Entry中的Key没有强引用进行引用，只有虚引用对其进行引用\n在GC时即使内存充足也会把Key给回收\nKey回收后，Value由于还有Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; Value的引用链，而且活跃线程对象为GC Root，这会导致Value占用的内存得不到释放\n\n\n解决方法\n使用完ThreadLocal对象后使用remove方法将其移除，断开引用链。\nThreadLocalMap脏Entry由于虚引用的关系，在ThreadLocalMap中可能会产生有Entry但是Key为null的脏Entry，一直占用着哈希表的位置，因此我们需要使用某种方法将脏Entry给清除。\nSetThreadLocal.threadLocalHashCode产生\n在实例化ThreadLocal对象时调用nextHashCode方法产生\n\n\nThreadLocal类有一个静态的原子整数，每产生一个ThreadLocal对象，其值就增加HASH_INCREMENT\n\n\n设置\n进行线性探测\n找到自己对应Key的Entry就放进去\n找到一个空位，跳出循环，新建一个Entry放进去\n找到一个脏Entry，替换该脏Entry，并进行一些脏Entry清理工作\n12345678910111213141516171819202122232425262728293031323334353637private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;    // We don't use a fast path as with get() because it is at    // least as common to use set() to create new entries as    // it is to replace existing ones, in which case, a fast    // path would fail more often than not.    Entry[] tab = table;    int len = tab.length;    // 进行散列    int i = key.threadLocalHashCode &amp; (len-1);\t// 进行线性探测    // 1. 找到自己对应Key的Entry就放进去    // 2. 找到一个空位，跳出循环，新建一个Entry放进去    // 3. 找到一个脏Entry，替换该脏Entry，并进行一些脏Entry清理工作    for (Entry e = tab[i];         e != null;         e = tab[i = nextIndex(i, len)]) &#123;        ThreadLocal&lt;?&gt; k = e.get();\t\t// 1.        if (k == key) &#123;            e.value = value;            return;        &#125;\t\t// 3.        if (k == null) &#123;            replaceStaleEntry(key, value, i);            return;        &#125;    &#125;\t// 2.    tab[i] = new Entry(key, value);    int sz = ++size;    // 先清理脏Entry，若清理不出空间来并且超过了扩容阈值，则进行扩容    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)        rehash();&#125;\n\nGet1234567891011private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;    // 散列    int i = key.threadLocalHashCode &amp; (table.length - 1);    Entry e = table[i];    // 获取到了    if (e != null &amp;&amp; e.get() == key)        return e;    // 没获取到，进行线性探测查找    else        return getEntryAfterMiss(key, i, e);&#125;\n\n线性探测查找\n12345678910111213141516171819private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;    Entry[] tab = table;    int len = tab.length;    while (e != null) &#123;        ThreadLocal&lt;?&gt; k = e.get();        // 找到了就返回        if (k == key)            return e;        // 遇见了脏Entry，进行清理        if (k == null)            expungeStaleEntry(i);        else            // 循环向后查找            i = nextIndex(i, len);        e = tab[i];    &#125;    return null;&#125;\n\n参考并发容器之ThreadLocal\n一篇文章，从源码深入详解ThreadLocal内存泄漏问题\n","plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之ThreadLocal/"},{"title":"Java并发之自旋锁","date":"2020-03-15T16:34:38.000Z","date_formatted":{"ll":"Mar 16, 2020","L":"03/16/2020","MM-DD":"03-16"},"updated":"2020-03-16T15:30:48.408Z","content":"自旋锁自旋锁即在获取锁失败时，不会马上阻塞，而是会持续重复尝试，直到获取锁成功。\n优点\n避免阻塞休眠和唤醒所带来的CPU上下文切换的开销\n缺点\n如果某个线程长时间持有锁不释放，则会导致其他线程一直空轮询而带来无用的CPU消耗\n自旋锁实现以下都是基于CAS来实现自旋锁。\n简单CAS自旋锁使用owner来指示当前锁的拥有者\n加锁\n若未被加锁：将owner设置为当前线程\n若已被加锁：自旋对owner进行CAS\n解锁\n将owner设置为null\n1234567891011121314151617181920class SpinLock &#123;    private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;();    public void lock() &#123;        Thread currentThread = Thread.currentThread();        if(currentThread == owner.get())            throw new IllegalMonitorStateException();        // 自旋获取锁        while (!owner.compareAndSet(null, currentThread)) &#123;        &#125;    &#125;    public void unlock() &#123;        Thread currentThread = Thread.currentThread();        if (currentThread != owner.get())            throw new IllegalMonitorStateException();        owner.compareAndSet(currentThread, null);    &#125;&#125;\n\n缺点\n不可重入\n不公平，不能让等待时间最长的线程先获取锁\n可重入简单CAS自旋锁增加count来记录重入数量。\n重入时count++\n释放锁时count--count为0释放锁\ncount不为0不释放\n\n123456789101112131415161718192021222324252627class ReentrantSpinLock &#123;    private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;();    private int count;    public void lock() &#123;        Thread currentThread = Thread.currentThread();        if (currentThread == owner.get()) &#123;            count++;            return;        &#125;        // 自旋获取锁        while (!owner.compareAndSet(null, currentThread)) &#123;        &#125;        count++;    &#125;    public void unlock() &#123;        Thread currentThread = Thread.currentThread();        if (currentThread != owner.get())            throw new IllegalMonitorStateException();        else&#123;            count--;            if(count == 0)                owner.compareAndSet(currentThread, null);        &#125;    &#125;&#125;\n\nTicketLockTicketLock用来解决自旋锁的公平性问题。\n原理场景解析\n想象我们在银行柜台排队，柜台会给每个人发一张票，上面记录着一个号码，然后柜台自己会维护一个 当前服务客户的号码，每次结束服务后，就会叫下一个号，只有在叫到自己的号码时，才可以去柜台办理业务。\nServiceNumber\n当前服务编号，记录当前获取到锁的线程的编号。\nTicketNumber\n排队线程的编号，只有当ServiceNumber等于自己的TicketNumber时才获取到锁。\n实现使用ThreadLocal存储每个线程自己的TicketNumber。\n12345678910111213141516171819202122232425class TicketLock &#123;    private static final ThreadLocal&lt;Integer&gt; LOCAL = new ThreadLocal&lt;&gt;();    private AtomicInteger serviceNumber = new AtomicInteger();    private AtomicInteger ticketNumber = new AtomicInteger();    public void lock() &#123;        Thread currentThread = Thread.currentThread();        Integer threadTicketNumber = ticketNumber.getAndIncrement();        LOCAL.set(threadTicketNumber);        while (threadTicketNumber != serviceNumber.get()) &#123; &#125;    &#125;    public void unlock() &#123;        Integer threadTicketNumber = LOCAL.get();        if (threadTicketNumber != serviceNumber.get())            throw new IllegalMonitorStateException();        serviceNumber.compareAndSet(threadTicketNumber, threadTicketNumber + 1);        // 防止ThreadLocal内存泄露        LOCAL.remove();    &#125;&#125;\n\n优点\n公平\n缺点\n不可重入\n每个线程都频繁读取和修改ServiceNumber变量，该变量需要在不同的CPU缓存之间进行缓存同步，导致系统总线繁忙，降低系统的性能\nCLHLockCLHLock维护一个隐式链表，申请锁的线程只需不断自旋轮询其前驱节点的状态，当发现前驱节点解锁时，即可获取锁。\n12345678910111213141516171819202122232425262728293031323334class CLHLock &#123;    private static final ThreadLocal&lt;CLHNode&gt; LOCAL = new ThreadLocal&lt;&gt;();    private AtomicReference&lt;CLHNode&gt; tail = new AtomicReference&lt;&gt;();    public void lock() &#123;        Thread currentThread = Thread.currentThread();        CLHNode node = new CLHNode();        LOCAL.set(node);        CLHNode pre = tail.getAndSet(node);\t\t// 存在前驱节点，等待其解锁        if (pre != null)            while (pre.isLocked) &#123;            &#125;    &#125;    public void unlock() &#123;        Thread currentThread = Thread.currentThread();        CLHNode node = LOCAL.get();        if (!tail.compareAndSet(node, null)) &#123;            // CAS设置尾节点失败，说明尾节点被其他线程替换掉了，即有线程正在等待获取锁            node.isLocked = false;        &#125;        // 防止ThreadLocal内存泄露        LOCAL.remove();    &#125;    class CLHNode &#123;        private volatile boolean isLocked = true;    &#125;&#125;\n\n优点\n公平\n只需轮询前驱节点的状态，避免大量CPU缓存同步（SMP架构下）\n缺点\n不可重入\n在NUMA（每个CPU有自己的本地内存，处理器访问它自己的本地存储器的速度比非本地存储器快一些）结构下，若前驱节点较远，则轮询前驱节点的状态效率较低\nMCSLockMCSLock维护一个显式链表，申请锁的线程只需不断自旋轮询自己节点的状态，当发现前驱节点解锁时，由前驱节点来更改后继节点的状态，通知其获取锁。\n123456789101112131415161718192021222324252627282930313233343536373839404142class MCSLock &#123;    private AtomicReference&lt;MCSNode&gt; tail = new AtomicReference&lt;&gt;();    private static final ThreadLocal&lt;MCSNode&gt; LOCAL = new ThreadLocal&lt;&gt;();    public void lock()&#123;        Thread currentThread = Thread.currentThread();        MCSNode node = new MCSNode();        LOCAL.set(node);        MCSNode pre = tail.getAndSet(node);        if(pre != null)&#123;            // pre不为null说明有线程已经获取到锁了            // 设置pre的后继节点为自己            pre.next = node;            // 自旋，等待前驱节点解锁，并将当前节点的isLocked设置为false            while(node.isLocked)&#123;&#125;        &#125;    &#125;    public void unlock()&#123;        Thread currentThread = Thread.currentThread();        MCSNode node = LOCAL.get();        if(!tail.compareAndSet(node, null))&#123;            // 尾结点不是自己说明有线程在等待获取锁            // 等待其他线程将其节点绑定到当前线程节点的后继            while(node.next == null)&#123;&#125;            // 通知其获取锁            node.next.isLocked = false;        &#125;        // 防止ThreadLocal内存泄露        LOCAL.remove();    &#125;    class MCSNode &#123;        private volatile boolean isLocked = true;        private volatile MCSNode next;    &#125;&#125;\n\n优点\n公平\n只需轮询线程自己的节点的状态，访问本地内存\n缺点\n不可重入\n参考面试必备之深入理解自旋锁\n","plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之自旋锁/"},{"title":"Java并发之顺序控制模式","date":"2020-03-15T16:33:54.000Z","date_formatted":{"ll":"Mar 16, 2020","L":"03/16/2020","MM-DD":"03-16"},"updated":"2020-03-16T15:30:48.408Z","content":"并发顺序控制在有时候我们希望线程的运行顺序是得到控制的，而不是无序的执行，比如说希望线程轮流打印1， 2， 3。\n并发顺序控制实现Synchronized实现count指示当前状态\nlock用来加锁以及线程等待\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Main &#123;    private static Object lock = new Object();    private static int count = 0;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                synchronized (lock) &#123;                    while (count != 0) &#123;                        try &#123;                            lock.wait();                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                    count = (count + 1) % 3;                    System.out.println(1);                    lock.notifyAll();                &#125;            &#125;        &#125;).start();        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                synchronized (lock) &#123;                    while (count != 1) &#123;                        try &#123;                            lock.wait();                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                    count = (count + 1) % 3;                    System.out.println(2);                    lock.notifyAll();                &#125;            &#125;        &#125;).start();        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                synchronized (lock) &#123;                    while (count != 2) &#123;                        try &#123;                            lock.wait();                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                    count = (count + 1) % 3;                    System.out.println(3);                    lock.notifyAll();                &#125;            &#125;        &#125;).start();    &#125;&#125;\n\nReentrantLock实现count记录当前状态\nlock用于加锁和解锁\ncondition条件变量用于线程阻塞等待\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Main &#123;    private static ReentrantLock lock = new ReentrantLock();    private static Condition condition = lock.newCondition();    private static int count = 0;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                lock.lock();                while(count != 0)&#123;                    try &#123;                        condition.await();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                count = (count + 1) % 3;                System.out.println(1);                condition.signalAll();                lock.unlock();            &#125;        &#125;).start();        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                lock.lock();                while(count != 1)&#123;                    try &#123;                        condition.await();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                count = (count + 1) % 3;                System.out.println(2);                condition.signalAll();                lock.unlock();            &#125;        &#125;).start();        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                lock.lock();                while(count != 2)&#123;                    try &#123;                        condition.await();                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                count = (count + 1) % 3;                System.out.println(3);                condition.signalAll();                lock.unlock();            &#125;        &#125;).start();    &#125;&#125;\n\nPark/Unpark实现每个线程都等待unpark\n每个线程运行完后unpark后续要执行的线程\n12345678910111213141516171819202122232425262728293031323334353637public class Main &#123;        public static void main(String[] args) throws InterruptedException &#123;        Thread t3 = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                LockSupport.park();                System.out.println(3);            &#125;        &#125;);        Thread t2 = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                LockSupport.park();                System.out.println(2);                LockSupport.unpark(t3);            &#125;        &#125;);        Thread t1 = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                LockSupport.park();                System.out.println(1);                LockSupport.unpark(t2);            &#125;        &#125;);        t1.start();        t2.start();        t3.start();        LockSupport.unpark(t1);    &#125;&#125;","plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之顺序控制模式/"},{"title":"二叉树的非递归遍历","date":"2020-03-15T05:22:34.000Z","date_formatted":{"ll":"Mar 15, 2020","L":"03/15/2020","MM-DD":"03-15"},"updated":"2020-03-15T05:53:47.636Z","content":"先序遍历123456789101112131415161718public void preOrder(TreeNode root) &#123;    Stack&lt;TreeNode&gt; path = new Stack&lt;&gt;();    TreeNode p = root;    while (!path.empty() || p != null) &#123;        while(p != null)&#123;            System.out.println(p.val);            path.push(p);            p = p.left;        &#125;        if(!path.empty())&#123;            p = path.pop();            p = p.right;        &#125;    &#125;&#125;\n中序遍历123456789101112131415161718public void inOrder(TreeNode root) &#123;    Stack&lt;TreeNode&gt; path = new Stack&lt;&gt;();    TreeNode p = root;    while (!path.empty() || p != null) &#123;        while(p != null)&#123;            path.push(p);            p = p.left;        &#125;        if(!path.empty())&#123;            p = path.pop();            System.out.println(p.val);            p = p.right;        &#125;    &#125;&#125;\n后序遍历使用pre记录上一次访问的节点1234567891011121314151617181920212223242526272829public void postOrder(TreeNode root) &#123;    Stack&lt;TreeNode&gt; path = new Stack&lt;&gt;();    TreeNode p = root;    TreeNode pre = null;    while (!path.empty() || p != null) &#123;        while (p != null) &#123;            path.push(p);            p = p.left;        &#125;        if (!path.empty()) &#123;        \t// 先不出栈            p = path.peek();\t\t\t// 1. 若右子树为空，则无需访问\t\t\t// 2. 若右子树上一次被访问了，则无需访问            if (p.right != null &amp;&amp; p.right != pre) &#123;                p = p.right;            &#125; else &#123;                System.out.println(p.val);                pre = p;                p = null;                // 后序访问完了，出栈                path.pop();            &#125;        &#125;    &#125;&#125;\n","thumbnail":"post/数据结构与算法/二叉树的非递归遍历/cover.jpg","plink":"https://beginc.github.io/post/数据结构与算法/二叉树的非递归遍历/"},{"title":"ICMP协议","date":"2020-03-13T14:51:07.000Z","date_formatted":{"ll":"Mar 13, 2020","L":"03/13/2020","MM-DD":"03-13"},"updated":"2020-03-13T14:53:15.299Z","content":"ICMP位于网络层，使用IP协议进行封装。\n用途IP传输差错报告\nIP传输拥塞控制\nIP传输路径控制\nIP传输时间信息获取\nIP传输掩码信息获取\n协议格式\n\n类型指示是哪一种控制报文。\n\n\n\n类型号类型\n\n3信宿不可达报告\n\n4拥塞控制\n\n5路径控制\n\n8和0回答请求与响应\n\n11数据报超时报告\n\n12数据报参数错误报告\n代码对控制报文的进一步细分。\nICMP差错报告报文丢弃出错的IP数据报\n向信源机报告差错\n数据区包含出错IP数据报的首部和前64比特的数据\n不产生ICMP差错报告的情况\n非第一个IP分片出错\nICMP差错报告报文出错\n组播IP数据报出错\n本地环回IP数据报出错\n\n\nICMP控制报文源抑制报文用于拥塞控制。\n步骤\n发现拥塞：路由器或者信宿机缓冲区溢出时发送ICMP源抑制报文\n解决拥塞：信源机降低发送速率直到不再收到更多的源抑制报文\n恢复：信源机一段时间未收到源抑制报文，则逐渐恢复发送速率\n重定向报文用于路径控制。\n主机的路由表\n","thumbnail":"post/计算机网络/ICMP协议/cover.jpg","plink":"https://beginc.github.io/post/计算机网络/ICMP协议/"},{"title":"UDP协议","date":"2020-03-13T14:49:17.000Z","date_formatted":{"ll":"Mar 13, 2020","L":"03/13/2020","MM-DD":"03-13"},"updated":"2020-03-13T14:53:15.299Z","content":"UDP服务无连接\n不可靠\n无拥塞控制适合实时应用\n首部还短8B\n\n面向报文不会对上层数据拆分\n适合传输小块数据太长了需要IP分片，影响效率\n\n\nUDP协议格式\n\nUDP总长度整个UDP报文的长度。\n校验和校验失败时直接丢弃报文，发送ICMP差错报告。\n","thumbnail":"post/计算机网络/UDP协议/cover.jpg","plink":"https://beginc.github.io/post/计算机网络/UDP协议/"},{"title":"TCP协议","date":"2020-03-13T14:49:12.000Z","date_formatted":{"ll":"Mar 13, 2020","L":"03/13/2020","MM-DD":"03-13"},"updated":"2020-03-13T14:53:15.299Z","content":"TCP协议服务面向连接的可靠传输\n面向字节流\n流量控制\n拥塞控制\n差错控制\nTCP协议格式\n\n序号发送方数据区第一个字节的编号。\n确认号发送方期望收到的下一个字节的编号。也是对之前的数据的累积确认。\nack 201接下来希望收到第201号字节\n序号200以及之前的字节都收到了\n\nHLEN首部长度，以4字节为单位。\nFlagURG紧急数据，不用在TCP缓冲区排队，马上发送\n此时紧急指针 + 序号即为紧急数据结束的字节的编号\n\nACK确认号有效\n\nPSH要求接收方立即交付缓冲区的数据\n\nRST异常，重新建立连接\n\nSYN用于建立连接时序号同步\n\nFIN用于拆除连接\n\n校验和端到端校验，校验的数据包括\nTCP所有信息\nIP首部的伪首部\n\n\nTCP选项选项结束：作为TCP选项的结束标记\n无操作：用于填充，达到TCP选项长度为4的整数倍\n最大段大小（MSS）：告诉接收方本机能接受的最大TCP数据区字节数\n窗口规模因子：$W_n = W_o \\times 2^f$$W_o$为窗口字段的值\n$f$为规模银子\n\n\n\nTCP连接的建立与拆除见\nTCP可靠传输实现机制序号\n确认号\n重传\n检验\n序号用序号可以保证数据是有序交付的。\n确认号使用确认号可让发送方知道自己的报文是否正确送达。\n累积确认：ack 200说明200以前的字节都收到了\n捎带确认：可以发送数据的同时发送ACK\n重传如果在规定的时间内未收到已发送数据的确认号，则会超时重传。\n快速重传为了避免超时重传带来的时延，TCP引入了\n冗余确认\n快速重传\n冗余确认\n当接收方收到乱序到达的数据时会发送一个冗余确认，确认号为自己当前希望收到的数据的序号。\n快速重传\n当发送方收到三次冗余确认（假设是ack x）后，就会马上重传未确认的报文段（发送x + 1），而不是等超时重传。\nTCP流量控制流量控制指的是接收方限制发送方的发送速率。\n实现机制滑动窗口发送方和接收方都有发送缓存和接收缓存。\n发送方的发送窗口大小不能超过对方的接收窗口大小\n\n\n窗口控制接收方\n发送数据时在首部的窗口大小处填上自己的接收窗口大小。\n发送方\n发送方的发送窗口大小为接收方接收窗口大小和当前拥塞窗口大小的最小值。\n$W_{send} = min{W_{recv}, W_{conges}}$\nTCP拥塞控制拥塞控制指的是发送方限制自己的发送速率来缓解网络拥塞。\n实现机制慢开始\n拥塞避免\n快重传\n快恢复\n过程慢开始建立TCP连接时发送方将拥塞窗口设置为接收方的一个MSS\n每次收到一个确认段都将MSS增加一个发一个 ---&gt;  一个确认 ---&gt; 2个MSS\n发两个 ---&gt;  两个确认 ---&gt; 4个MSS\n发四个 ---&gt;  四个确认 ---&gt; 8个MSS\n...\n\n\n\n拥塞避免当拥塞窗口大小达到门限值时，即使收到多个确认，也只增加一个MSS\n快重传当收到三个冗余确认时，发送方进行快速重传\n将门限值减为当前拥塞窗口大小的一半\n拥塞窗口减为新的门限值\n快恢复窗口每次增加一个MSS\n","thumbnail":"post/计算机网络/TCP协议/cover.jpg","plink":"https://beginc.github.io/post/计算机网络/TCP协议/"},{"title":"IP协议","date":"2020-03-13T14:49:07.000Z","date_formatted":{"ll":"Mar 13, 2020","L":"03/13/2020","MM-DD":"03-13"},"updated":"2020-03-13T14:53:15.299Z","content":"IP地址1&lt;网络号&gt;:&lt;主机号&gt;\n\nIP地址分类\n\nA类地址\n用于大型网络\n127开头的为本地环回地址\nB类地址\n用于中型网络\nC类地址\n用于小型网络\nD类地址\n组播地址\nE类地址\n保留地址\n特殊IP地址\n类型地址作用目的地址源地址\n\n网络地址&lt;网络号&gt;:&lt;全0&gt;标识网段不可不可\n\n直接广播地址&lt;网络号&gt;:&lt;全1&gt;发送给某个网段的全部设备（主机，路由器）可不可\n\n受限广播地址&lt;全1&gt;:&lt;全1&gt;发送给本网段的所有主机（路由器进行隔离，不会发送到其他网段）可不可\n\n本网络特定主机地址&lt;全0&gt;:&lt;主机号&gt;发送给本网络的某个主机可不可\n\n本网络本主机地址&lt;全0&gt;:&lt;全0&gt;无盘工作站使用不可可\n\n环回地址127.*.*.*测试可不可\n私有地址10.0.0.0-10.255.255.255\n172.168.0.0-172.31.255.255\n192.168.0.0-192.168.255.255\nNAT地址转换私有地址的主机要和外部网络通信就要使用NAT进行地址转换。\n向外发送数据和接收数据时都使用NAT路由器的公网地址\n\n\nIP协议IP协议提供的服务无连接\n不可靠\n点到点传输\nIP协议格式\n\n版本4---IPv4\n首部长度以4字节为单位。\n数据包总长度以字节为单位。\n协议标识传输层协议。\n首部校验和用于点到点的IP首部校验\n服务类型D低时延\nT高吞吐量\nR高可靠性\nC低代价\n生存时间最大数据报生存时间防止IP数据包长时间在网络传播\n\n每经过一个路由器减一小于等于0时丢弃， 使用ICMP协议发送错误报告\n\nIP数据报分片由于底层网络的MTU限制，IP协议传送数据时可能需要将其进行分片\n标识信源机赋予数据包的标识符\n属于同一个数据报的的所有分片标识都相同\n标志D：Don&#39;t Fragment表示不要对该数据报进行分片\nM：More Fragment表示该数据报后还有分片\n片偏移以8个字节为单位，给出本片数据的第一个字节在原始数据报中的偏移量。\n","thumbnail":"post/计算机网络/IP协议/cover.jpg","plink":"https://beginc.github.io/post/计算机网络/IP协议/"},{"title":"HTTP协议","date":"2020-03-13T14:49:03.000Z","date_formatted":{"ll":"Mar 13, 2020","L":"03/13/2020","MM-DD":"03-13"},"updated":"2020-03-13T14:53:15.299Z","content":"HTTP协议层次位于应用层，基于传输层的TCP协议。\nURL统一资源定位符格式1传输协议:&#x2F;&#x2F;域名或IP:端口号 + 路径 + 文件名\n\nhttp://localhost:8080/pages/index.html\nHTTP协议格式请求报文\n\n方法GET请求指定资源\n\nHEAD请求URL指定的资源的元信息大小\n最后修改时间\n...\n\n\nPOST客户端向服务端发送资源\n有请求体（Request Body）\n\nPUT请求修改URL指定的资源\n有请求体（Request Body）\n\nDELETE请求删除URL指定的资源\n\nHTTP版本HTTP/0.9\nHTTP/1.0\nHTTP/1.1\nHTTP/1.1特点持续连接：允许一个TCP连接上进行多次HTTP请求与响应\n流水线技术：允许用户在一个响应返回前发送下一个请求\n响应报文\n\n状态码分类\n\n常见状态码\n状态码解释\n\n200OK - 请求成功\n\n301Moved Permanently - 资源被永久转移到其它URL\n\n400Bad Request - 客户端请求有语法错误，不能被服务器所理解\n\n401Unauthorized - 请求未经授权\n\n404Not Found - 请求资源不存在\n\n500Internal Server Error - 服务器内部发生了不可预期的错误\n\n503Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。\nHTTP首部分类通用首部\n请求首部\n响应首部\n实体首部\n拓展首部\n常见通用首部\n首部名称功能\n\nConnectionKeep-Alive：可进行TCP连接复用\n常用请求首部\n首部名称功能\n\nHost服务器的主机名和端口\n\nReferer当前请求的URL\n\nAccept告诉服务器能够发送的媒体类型\n\nAccept-Charset告诉服务器能够发送的字符集\n\nAccept-Encoding告诉服务器能够发送的编码方式\n\nAccept-Language告诉服务器能够发送的语言\n\nCookie客户端需要发送的cookie\n\nUser-Agent客户端程序信息\n\nContent-Type请求数据的MIME类型\n常见响应首部\n首部名称功能\n\nServer服务器应用软件名称及版本\n\nAccept-Range服务器可以接受的范围类型\n\nSet-Cookie设置cookie\nHTTPSHTTP缺点明文传输\n数据可被篡改\nSSLHTTPS增加了一个SSL（安全套接字层）提供安全支持。\n\n\n协议\nSSL\nTSL\n加密对称加密加密和揭秘使用同一个秘钥。\n缺点\n第一次传输密钥时还是明文，可被截获\n\n\n\n\n\n\n非对称加密非对称加密中有公钥和密钥。\n客户端\n公钥：clientPublicKey\n密钥：clientPrivateKey\n服务器\n公钥：serverPublicKey\n密钥：serverPrivateKey\n客户端发送到服务器\n客户端使用serverPublicKey加密\n服务器使用serverPrivateKey解密\n服务器发送到客户端\n服务器使用clientPublicKey加密\n客户端使用clientPrivateKey解密\n缺点\n非对称加密次数多，开销大\n非对称加密 + 对称加密服务器\n公钥：serverPublicKey\n密钥：serverPrivateKey\n客户端\n收到服务器的公钥后，在本地生成一个对称加密的密钥X\n使用serverPublicKey将密钥X加密发送给服务器\n通信\n双方通信都使用密钥X进行对称加密\n\n\n\n\n缺点\n存在中间人攻击。\n将服务器发来的公钥替换为自己的公钥\n将客户端发送给服务器的密钥X解密获取知道了密钥X，就可解密所有信息\n\n\n\n\n\n数字证书为了防止公钥传输时被篡改，我们可以使用数字签名技术。\n数字签名数字签名主要用来保证数据不可被篡改。\n数据摘要对要发送的数据取Hash\n\n\n\n私钥加密生成签名使用私钥生成签名，这样就没有人能够伪造签名\n\n\n\n将签名与数据一起发送\n\n\n接收方收到数据后进行数据完整性验证将数据生成摘要\n用发送方的公钥解密签名得到解密后的摘要\n将自己生成的摘要和解密后的摘要对比相同：没有被篡改\n不相同：被篡改了\n\n\n\n\n\n\n数字证书数字证书由CA机构颁发，数字证书其实就是一个对公钥的签名，由CA机构用其密钥进行签署，保证其不被篡改。\n\n\n通信过程其实就是在对称加密 + 非对称加密的基础上，将明文传输服务器公钥，变成了传输服务器的公钥的数字证书。\n\n\n\n\n\n\n\n\n\n\n参考漫画：什么是 HTTPS 协议？\n\n彻底搞懂HTTPS的加密机制\n\n数字签名是什么？\n\n","thumbnail":"post/计算机网络/HTTP协议/cover.jpg","plink":"https://beginc.github.io/post/计算机网络/HTTP协议/"},{"title":"DNS协议","date":"2020-03-13T14:48:57.000Z","date_formatted":{"ll":"Mar 13, 2020","L":"03/13/2020","MM-DD":"03-13"},"updated":"2020-03-13T14:53:15.299Z","content":"DNS层次\n\n根域根节点，为空。\n顶级域www.baidu.com其中com为顶级域\ncom\norg\nnet\n...\n二级域一般为公司名或者组织名。www.baidu.com其中baidu为二级域\nDNS解析过程递归解析DNS解析请求层层传递，最后层层返回。\n用户只需请求一次\n服务器压力大\n\n\n反复解析用户请求服务器时，服务器若不能给出结果，则会告诉用户接下来要找谁去解析，让用户自己请求\n用户请求多次\n服务器压力小\n","thumbnail":"post/计算机网络/DNS协议/cover.jpg","plink":"https://beginc.github.io/post/计算机网络/DNS协议/"},{"title":"路由协议","date":"2020-03-13T14:48:52.000Z","date_formatted":{"ll":"Mar 13, 2020","L":"03/13/2020","MM-DD":"03-13"},"updated":"2020-03-16T15:50:16.185Z","content":"路由算法分类静态路由算法管理员手动配置路由信息。\n动态路由算法根据路由算法，学习和优化路由表。\n全局性所有路由器都需要掌握完整的网络拓扑和链路代价。\n链路状态路由算法OSPF\n\n分散性路由器只需要掌握物理相连的设备以及链路代价。\n距离向量路由算法RIP\n\n内部网关路由协议一个AS自治系统内部使用的路由协议。\nRIP\nOSPF\n外部网关路由协议多个AS自治系统之间使用的路由协议。\nBGP\n\n\nRIP路由协议路由表\n\n距离向量算法初始时每个路由器都知道与自己直接相连的链路和设备的信息，初始化路由表\n每隔30秒将自己的路由表发送给相邻路由器\n收到路由表后更新自己的路由表\n若超过180秒未收到相邻路由器的信息，则判断其宕机，将经过该邻居路由器的路由表项的距离全部改成16（表示不可达）\n路由表更新\n收到路由表后按如下步骤进行路由表更新（假设收到了R1路由器的(Net3, 2, R2)）\n将收到的路由表中的所有项的下一跳路由器更新为发送方\n将收到的路由表中的所有项的距离加1\n若自己的路由表中无Net3，则直接将该项加入到自己的路由表\n若自己的路由表中有Net3若下一跳为R1，则无条件直接更新\n若下一跳不是R1，若距离更短则更新\n\n\n\n特点适用于小型网络（一条路由最多16个路由器）\n\n好消息传得快，坏消息传得慢\n可使用毒性逆转\n\n使用UDP协议\n\n","thumbnail":"post/计算机网络/路由协议/cover.jpg","plink":"https://beginc.github.io/post/计算机网络/路由协议/"},{"title":"链路层","date":"2020-03-13T14:48:48.000Z","date_formatted":{"ll":"Mar 13, 2020","L":"03/13/2020","MM-DD":"03-13"},"updated":"2020-03-16T15:37:18.820Z","content":"链路层功能加强物理层传输原始比特流的能力，将其改造成逻辑上无差错的数据链路。\n为网络层提供服务\n无确认无连接\n有确认无连接\n有确认有连接\n链路管理\n组帧\n流量控制\n点到点的流量控制\n收不下就不回复确认\n差错控制\n点到点的差错控制\n奇偶校验/CRC/海明码\n差错控制奇偶校验TODO\n海明码TODO\nCRCTODO\n组帧组帧的作用添加控制信息\n帧定界（方便拆包）\n组帧方法字符计数法在每个帧的首部填充上本帧的长度。\n\n\n缺点\n鲁棒性低若字符计数传输出错，则全部会发生错乱\n\n字符填充法在头部填充开始标记\n在尾部填充结束标记\n \n\n缺点\n开始和结束标记不能出现在数据部分只能传输固定编码的数据，不能传输任意二进制流\n\n字符填充法 + 转义在字符填充法的基础上，为数据部分出现的开始和结束标记添加上转义符号。\n\n\n\n\n零比特填充法开头填充01111110\n结尾填充01111110\n数据部分5110碰到5个连续的1就在后面填充一个0\n\n\n\n\n\n优点\n实现了字节流的透明传输\n链路管理\n\n信道划分介质访问控制频分多路复用不同的用户分配使用不同的传输频率\n时分多路复用不同的用户分配使用不同的时间\n波分多路复用即光的频分多路复用\n在光纤中不同的用户传输不同波长的光信号\n码分多路复用TODO\n轮询访问介质访问控制\n\n令牌一个特殊格式的MAC控制帧\n不带任何数据\n同一时刻只有一个人持有令牌\n拿到令牌的人可以发送数据\n随机访问介质访问控制ALOHA内容\n想发就发\n发生冲突后等待一个随机时间后进行重发\n冲突检测\n接收方收到差错的帧直接不回复\n发送方超时重发\nCSMA载波监听多路访问控制协议。\n内容\n发送之前先监听信道是否忙1坚持：忙：持续监听，闲则马上传输\n闲：马上传输\n\n非坚持忙：等待一个随机时间后再监听\n闲：马上传输\n\nP坚持忙：等待一个随机时间后再监听\n闲：以概率P直接传输，1-P概率等待一个时间槽再传输\n\n\n发生冲突：坚持发送完\nCSMA/CD适用\n总线型网络\n内容\n边发送边监听，冲突后以截断二进制指数规避算法决定重传时机\nCSMA/CA适用\n无线网络\n内容\n发送前先监听，若空闲则发送一个RTS(Request To Send)帧源地址\n目的地址\n预计持续发送时间\n\n接收端收到RTS帧后响应CTS(Clear To Send)帧，同时预约信道\n接收端正确收到数据时响应ACK帧\n流量控制与可靠传输停等协议使用一个比特对帧进行编号\n0号帧\n1号帧\n\n\n发送方\n交替发送0帧和1帧\n收到确认帧后才发送下一个帧\n长时间未收到确认帧则超时重发\n接收方\n交替接收0帧和1帧\n收到想要的帧后才发送确认帧\n帧丢失\n发送方超时重发\n帧出错\n接受方不发送确认\nACK帧丢失\n发送方超时重发\n接收方丢弃重复的帧，再次发送确认ACK帧\n\n\nACK帧迟到\n发送方超时重传\n\n发送方丢弃不符合编号的ACK帧\n\n\n\nGBN协议TODO\nSR协议TODO\n链路层设备集线器连接多个设备，收到帧后向所有出口转发。\n\n\n网桥对以太网进行扩展。\n功能\n根据MAC帧的目的地址进行转发和过滤，而不是广播\n优点\n隔离冲突域\n扩大局域网范围\n提高可靠性互联不同实现的以太网\n\n透明网桥和ARP高速缓存一样学习转发表。\n查转发表无记录时进行广播\n\n\n源路由网桥可将最好的路由信息放在帧的首部。\nTODO\n交换机 扩展以太网。多接口网桥。\n\n\n直通式交换机查表后立刻转发。\n不查错\n不缓存\n存储转发式交换机将帧放入高速缓存\n查错后进转发\n支持速率转换\n以太网以太网提供的服务无连接\n不可靠帧不带编号\n不发送确认帧，出错直接丢弃\n\n信道访问控制协议CSMA/CD\n以太网帧格式目的地址：MAC单播地址\n广播地址: 全F\n多播地址\n\n源地址：MAC\n类型：网络层协议\nFCS：CRC\n","thumbnail":"post/计算机网络/链路层/cover.jpg","plink":"https://beginc.github.io/post/计算机网络/链路层/"},{"title":"地址解析协议","date":"2020-03-13T14:48:34.000Z","date_formatted":{"ll":"Mar 13, 2020","L":"03/13/2020","MM-DD":"03-13"},"updated":"2020-03-13T14:53:15.299Z","content":"地址解析协议地址解析协议属于网络层，但是不使用IP协议。\nARP地址解析协议，由IP地址解析为MAC地址。\nRARP反向地址解析协议，由MAC地址解析为IP地址。\n无盘服务器启动后不知道自己的IP，进行解析\n地址解析协议格式\n\n硬件类型指出底层网络类型\n1---以太网\n协议类型指出网络层协议类型。\n0x0800---IPv4\n操作类型1：ARP请求\n2：ARP响应\n3：RARP请求\n4：RARP响应\nARP用途链路层通信需要使用MAC地址。\n\n\n过程假设A想要发送分组给B，则A需要解析B的MAC地址。\nA广播ARP请求因为A不知道B的MAC地址\n此广播为链路层广播，MAC目的地址为全F广播地址\n目的硬件地址全为0\n\n\n\nB单播应答\n\n\nARP高速缓存存储位置每台设备都在内存中存储了ARP高速缓存\n重启就没了\n自适应ARP高速缓存ARP表并不是固定的，而是会在收发数据的过程中，进行添加。\n为了避免每次发送数据包都需要解析MAC地址，所以要设立ARP高速缓存。\n\n\n\n\n\n\n\n\nRARP用于解析本机或者其他主机的IP地址。\n用途用于无盘计算机启动时，根据自己的MAC地址去解析自己的IP地址。\n过程假设A想要解析自己的IP地址。\nA广播RARP请求链路层广播\n目的硬件地址写的是待解析的主机的硬件地址\n\n\n\n服务器单播应答\n","thumbnail":"post/计算机网络/地址解析协议/cover.jpg","plink":"https://beginc.github.io/post/计算机网络/地址解析协议/"},{"title":"MySQL事务","date":"2020-03-12T05:23:28.000Z","date_formatted":{"ll":"Mar 12, 2020","L":"03/12/2020","MM-DD":"03-12"},"updated":"2020-03-13T16:27:33.136Z","content":"不一致现象丢失修改\n如下所示，两次对A减10的修改丢失了一次。\n\n事务T1事务T2A\n\nRead(A, t1)将A读入t1变量中100\n\nRead(A, t2)将A读入t2变量中100\n\nt1 = t1 - 10100\n\nt2 = t2 - 10100\n\nWrite(A, t1)90\n\nWrite(A)90\n不可重复读\n事务T1并未进行写操作，但是重复读A却读到了不同的数据。\n\n事务T1事务T2A\n\nRead(A, t1)100\n\nWrite(A, 90)90\n\nRead(A, t1)90\n脏读\n事务T1读到了事务T2未提交的数据，然后事务T2竟然回滚了，导致T1读到的数据和数据库不一致。\n\n事务T1事务T2A\n\nBegin T2100\n\nWrite(A, 90)90\n\nRead(A, t1)90\n\nRollback100\n幻读\n事务T1读到了事务T2插入的数据，导致前后第二次读到的数据多了一条。\n\n事务T1事务T2A表\n\n读A表所有记录（1条）1条记录\n\n插入A表一条记录2条记录\n\n读A表所有记录（2条）2条记录\n事务的概念事务为一组原子性的操作，要么全部执行，要么全部不执行。\n特性原子性事务的一组操作，要么全部执行，要么全部不执行。\n一致性保证不出现不一致现象。\n隔离性事务之前不互相影响。\n持久性已提交事务的影响是持久化到磁盘上了的。\n事务的隔离级别四种隔离级别\n脏读不可重复读幻读\n\nRead Uncommitted\n\nRead Committed解决\n\nRepeatable Read解决解决\n\nSerializable解决解决解决\nRead Uncommited可读未提交的数据。\nRead Commited只能读已经提交的数据。\nRepeatable Read（默认）可重复读。\nSerializable事务调度是可串行化的。\n事务的隔离级别实现原理InnoDB多版本并发控制MVCCInnoDB中对MVCC协议进行了实现。有关MVCC的最基础知识见数据库并发控制。\n元组结构\nRowIDIS_DELETEDB_TRX_IDDB_ROLL_PTRname\n\nInnoDB自动创建的ID列元组是否被删除相当于Begin版本链指针表中的姓名字段\n版本链InnoDB中的版本链存储使用的是Delta Storage，即存储增量更新。\n12345版本3(当前最新版本)\t\t\t版本2(旧版本)\t\t\t\t\t\t版本1(旧版本)(name: lhw)     ---&gt;     (nameDelta: John)       ---&gt;       (nameDelta: Bob)按照上述版本链我们可知：版本2，由最新版本进行增量恢复name ---&gt; John，得到了版本2的元组版本1，由版本2进行增量恢复name ---&gt; Bob，得到了版本1的元组\n\n而这种增量存储和增量恢复，其实就是Undo日志的形式，所以InnoDB中版本链中的历史数据是存储在Undo日志中的。版本链通过DB_ROLL_PTR来串联，该指针实际上指向的就是Undo日志中的回滚段。而且InnoDB中的版本链组织顺序为由新到旧。\n可见性可见性是通过创建Read View来实现的。\nRead ViewRead View就是对当前所有事务状态的一个快照。\n为什么要使用事务快照\n我们首先需要明白为什么需要使用事务快照。以Repetable Read隔离级别举例，我们希望在事务并发调度中，我们当前事务不应该读到别的事务未提交的数据，和本应该在我们的读操作之后才发生的写操作写入的数据，但并发调度下执行顺序是不可预知的，因此在封锁协议中我们使用锁来进行限制，但带来的就是并发度的降低。在MVCC中我们对一个数据创建了多个历史版本，我们知道，对于一个事务来说，肯定有某个版本的数据是符合我们当前要求的，所以我们需要一种方法来判断哪个历史版本的数据是对我们可见的，因此我们使用事务快照来实现。\nRead View结构\n\nReadView::idReadView::m_idsReadView::m_low_limit_idReadView::m_up_limit_id\n\n创建该视图的事务ID创建ReadView时，活跃的读写事务ID数组(未提交的事务)当前已经创建的最大事务ID（该事务可能提交了可能未提交）ReadView:m_ids集合中的最小值\n使用Read View我们将当前事务状态做了一个快照，分为三个部分\n已经提交的事务（肯定是可见的）\n未提交与已提交的事务（未提交的不可见，提交的可见）\n未开始事务（肯定不可见）\n\n\n可见性算法当我们要读取一行数据时我们进行如下比对\n若DB_TRX_ID &lt; m_up_limit_id，可见\n若DB_TRX_ID &gt; m_low_limit_id，不可见\n若m_up_limit_id &lt; DB_TRX_ID &lt; m_low_limit_id若DB_TRX_ID在m_ids数组中，不可见\n若DB_TRX_ID不在m_ids数组中，可见\n\n操作MVCC中有两种读的形式\n快照读：读取可见版本，不加锁，即最普通的select * from person\n当前读：读取最新版本，加行锁select * from person where name=lhw lock in share mode\nselect * from person where name=lhw for update\nupdate person set name=John\ninsert into person (name) values (Bob)\ndelete from table where name=lhw\n\n读操作沿着版本链从新到旧进行查找，由可见性算法判断可见的数据是可读的。\n写操作创建一个新的元组，旧元组放入Undo日志中。\nDB_TRX_ID为当前事务ID\nDB_ROLL_PTR指向Undo日志中上一个数据版本\nInnoDB隔离级别实现原理InnoDB中隔离级别的实现是使用了如下协议实现的\n两阶段封锁协议\nMVCC多版本并发控制协议\nRead Uncommitted读最新的数据，不加锁，不会遍历版本链。因为读数据又不加锁又不使用MVCC所以会产生脏读\n\n写时加行锁，不加间隙锁，事务结束时解锁。即使用了封锁协议的1级协议，但是还是无法避免脏读，究其原因就是因为读不加锁！\n\nRead Committed用的是语句级别的事务快照。\n读时创建Read View，下次读还需要再创建Read View，遍历版本链，使用可见性算法确定可见数据\n不加锁\n\n写时加行锁，不加间隙锁，事务结束时解锁。\nRepeatable Read读时创建Read View，供本次事务所有读使用，遍历版本链，使用可见性算法确定可见数据\n不加锁\n\n写时有索引：行锁 + 间隙锁（带范围时，间隙锁可解决幻读）\n无索引：表锁\n\nSerializable读写都加锁，使用S2PL严格两阶段封锁协议。\n读时创建Read View，供本次事务所有读使用，遍历版本链，使用可见性算法确定可见数据\n加共享锁\n\n写时有索引：行锁 + 间隙锁\n无索引：表锁\n\n参考MySQL 是如何实现四大隔离级别的?\n你真的懂MVCC吗？来手动实践一下？\n数据库内核日报: MySQL · 引擎特性 · InnoDB 事务子系统介绍\n","thumbnail":"post/数据库/MySQL/MySQL事务/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/MySQL事务/"},{"title":"数据库故障恢复","date":"2020-03-12T05:17:12.000Z","date_formatted":{"ll":"Mar 12, 2020","L":"03/12/2020","MM-DD":"03-12"},"updated":"2020-03-13T16:13:38.975Z","content":"故障恢复恢复手段重做事务Redo保证已经提交的事务的持久性。\n撤销事务Undo保证未提交事务的原子性。\n运行日志即Redis中的AOF。\n先写运行日志\n再进行数据库操作\n日志信息\n开始事务\n提交事务\n回滚事务\n&lt;T, X, oldValue, newValue&gt;事务改变了数据\n检查点在检查点时刻，数据库管理系统强制把缓存中的数据刷新到磁盘中\n在检查点之前内存中和磁盘中数据具有一致性\n检查点之前提交的事务不需要恢复\n检查点之后提交的事务故障时需要Redo\n检查点之后还未提交的事务需要Undo\n刷盘策略讨论何时将缓冲区内容同步到磁盘中。\nForce\n最晚在commit时刷盘。\nNo Force\n在事务commit过后一段时间再刷盘。\nNo Steal\n不允许在事务commit之前刷盘。\nSteal\n允许在事务commit之前刷盘。\n日志类型Undo日志记录顺序数据写到磁盘之前不能提交\n&lt;T, x, oldValue&gt;\nOutput(x)刷盘\n&lt;Commit T&gt; / &lt;Abort T&gt;\n恢复对找不到或的数据，按日志逆序，对数据进行恢复（获取oldValue写入）。\nRedo日志记录顺序先提交事务再刷盘。\n&lt;T, x, newValue&gt;\n&lt;Commit T&gt; / &lt;Abort T&gt; \nOutput(x)刷盘\n恢复对已经提交的事务，按日志顺序，重做已提交的所有修改（获取newValue写入）。\nUndo/Redo日志记录顺序先提交事务再刷盘。\n&lt;T, x, oldValue, newValue&gt;\n /  和Output(x)顺序无所谓\n恢复自前向后重做所有已提交的事务\n自后向前撤销所有未提交的事务\n","thumbnail":"post/数据库/数据库原理/数据库故障恢复/cover.jpg","plink":"https://beginc.github.io/post/数据库/数据库原理/数据库故障恢复/"},{"title":"数据库并发控制","date":"2020-03-12T05:17:07.000Z","date_formatted":{"ll":"Mar 12, 2020","L":"03/12/2020","MM-DD":"03-12"},"updated":"2020-03-12T05:27:10.126Z","content":"事务调度概念一组事务的基本步骤的一种执行顺序称作事务调度\n读\n写\n加锁\n解锁\n...\n正确性只有当一个并发调度与串行调度的执行结果一致时，称该并发调度是正确的。\n可串行性不管数据库初始状态如何，若该调度都与串行调度结果一致，则称该事务调度是可串行化的。\n与正确性的区别\n正确性：强调一次执行的正确性\n可串行性：强调不管初值是多少，执行多少次，都应该是正确的\n冲突可串行性冲突若两个操作交换次序后会导致事务行为发生改变，则称两个操作是冲突的。\n同一事务中\n任意两个操作都冲突\n不同事务中\n同一元素：写操作冲突\n同一元素：读后写，写后读冲突\n概念若一个事务调度可通过交换无冲突的操作得到一个串行调度，则称该调度为冲突可串行化的调度。\n意义由于有如下关系\n1事务调度正确性 &gt; 事务调度可串行性 &gt; 事务调度冲突可串行性\n\n要证明事务调度的正确性，我们可证明一个比其强的命题\n事务调度是可串行化的\n事务调度是冲突可串行化的\n但是可串行化是很难判断的，所以我们可以通过判断事务调度是不是冲突可串行化来判断一个事务调度是否正确。\n判别算法前驱图\n每个事务一个节点\n若事务A中的某个操作T1与事务B中某个操作T2冲突，且满足如下条件，则绘制一条事务A指向事务B的有向边T1必须在T2之前执行\n\n若图中无环则可冲突串行化\n\n\n\n\n基于封锁的并发控制封锁协议内容一个封锁协议定义了如何使用锁来进行并发控制。\n锁的类型共享锁任何事务都可读\n任何事务都不可写\n排他锁拿到锁的事务可读写\n其他任何事务不可读写\n更新锁初始可读\n以后可升级为写\n增量锁专门用于执行增量操作 A = A + X\n双写操作本来是冲突的，但是两个增量操作是可交换次序的\n封锁粒度属性值 ---&gt; 元组(行锁) ---&gt; 元组集合 ---&gt; 整个关系(表锁) ---&gt; 整个数据库\n粒度小，封锁开销大，并发度高\n粒度大，封锁开销小，并发度低\n相容性矩阵定义持有一种锁时，是否还能再申请其他锁。\n\n\n\n\n加锁解锁时机0级协议内容\n写之前加排他锁\n写完马上解锁\n解决的问题\n丢失修改读和写一起锁住保证原子性\n\n未解决的问题\n脏读\n不可重复读\n幻读\n\n\n\n\n1级协议内容\n写之前加排他锁\n事务提交后解锁\n解决的问题\n丢失修改\n脏读\n未解决的问题\n不可重复读\n幻读\n\n\n2级协议内容\n写之前加排他锁\n提交事务时解锁\n读之前加共享锁\n读完马上解锁\n解决的问题\n丢失修改\n脏读\n不可重复读\n未解决的问题\n幻读\n\n\n3级协议内容\n写之前加排他锁\n提交事务时解锁\n读之前加共享锁\n提交事务时解锁\n解决的问题\n丢失修改\n脏读\n不可重复读\n幻读\n\n\n\n\n两阶段封锁协议2PL使用该协议可产生可串行化的事务调度。\n内容读写之前都要获取锁，并且该协议将堆锁的操作分为了两个阶段\n加锁段\n解锁段\n加锁段先于解锁段\n加锁段中不能进行解锁\n解锁段中不能进行加锁\n12345678# 加锁段Lock(A)read(A)lock(B)write(B)# 解锁段Unlock(A)unlock(B)\n\n死锁两阶段封锁协议可能产生死锁。\n基于时间戳的并发控制事务的时间戳事务启动时，分配一个时间戳\n时间戳小的事务先执行，时间戳大的后执行\n并发控制利用时间戳可进行无锁并发。\n事务无冲突时：随便怎么执行\n事务冲突时：撤销重启该事务，分配一个更大的时间戳\n冲突\n读后写\n写后读\n写后写\n简单实现方法每个数据有两个时间戳\nWT：写过该数据的事务中最大的时间戳\nRT：读过该数据的事务中最大的时间戳\n每个事务有一个时间戳\nTS\n读写并发防止读后写，写后读，即当发生了这两种冲突时，重启事务。\n读数据\n若TS &gt; WT，操作允许，更新RT为max{RT, TS}\n若TS &lt; WT，操作失败，重启该事务\n写数据\n若TS &gt; RT，操作允许，更新WT为max{WT, TS}\n若TS &lt; RT，操作失败，重启该事务\n写写并发防止写后写。\n若TS &gt; WT，为按顺序写，允许操作，更新WT为TS\n若TS &lt; WT，即发生了写后写，重启该事务\n带提交位的实现方法简单实现方法中，无法解决脏读问题，即一个事务写数据后，另一个事务是可读的，但是若该写操作被撤销了，则导致了不一致性。\n数据戳\nWT：写过该数据的事务中最大的时间戳\nRT：读过该数据的事务中最大的时间戳\nC：提交位，表明写该数据的事务是否已经提交\nTODO\n多版本并发控制MVCC在封锁协议中，我们可使用读写锁来达到\n读读并发\n读写互斥\n写写互斥\n提高了一定的并发度，而在MVCC中，通过引入版本和可见性控制，实现了\n读读并发\n读写并发\n写写互斥\n进一步提高了读多写少场景下的性能。\n元组结构Version为版本标识\nBegin为最近创建或更新、删除该元组的事务时间戳\nEnd为该元组的过期时间戳（-代表当前未过期）\n\n\n操作更新操作更新操作不会直接对原来的元组进行更新，而是会创建该元组的一个新的版本。\n更新上一个版本的End为当前事务的时间戳\n新版本元组的Begin为当前事务的时间戳\n\n\n\n\n读操作对照元组的所有版本，若满足如下条件，则该版本的元组对当前事务来说是可见的\nBegin &lt;= TS &lt;= End\n版本链Version Chain由于一个元组有多个版本，因此我们使用链表的形式将其进行组织，组织的方式有如下两种\n由新到旧\n由旧到新\n历史版本数据存储对于历史版本的数据，我们有如下三种存储策略\nAppend Only Storage\n所有版本的数据存储在同一个表中，使用版本链进行串联。\n\n\nTime Travel Storage\n旧版本的数据被复制到另一张表中，使用版本链进行串联。\nDelta Storage\n旧版本数据的增量被存储在另外的存储空间。\n类似与Undo日志，Delta里面存储了该旧版本元组相对于新版本元组中，某个属性的旧值，这样我们可以通过对新版本的数据进行增量恢复，来得到旧版本的数据。\n","thumbnail":"post/数据库/数据库原理/数据库并发控制/cover.jpg","plink":"https://beginc.github.io/post/数据库/数据库原理/数据库并发控制/"},{"title":"Java并发之AQS","date":"2020-03-07T08:12:18.000Z","date_formatted":{"ll":"Mar 7, 2020","L":"03/07/2020","MM-DD":"03-07"},"updated":"2020-03-07T08:12:18.638Z","content":"","plink":"https://beginc.github.io/post/Java并发之AQS/"},{"title":"Java并发之ReentrantReadWriteLock","date":"2020-03-07T08:12:05.000Z","date_formatted":{"ll":"Mar 7, 2020","L":"03/07/2020","MM-DD":"03-07"},"updated":"2020-03-10T13:19:59.565Z","content":"ReentrantReadWriteLock特性支持ReentrantLock的所有特性\n\n支持读锁和写锁\n读读不互斥\n12345678910111213141516171819202122public class TestThread &#123;    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();    private ReentrantReadWriteLock.ReadLock readLock = lock.readLock();    private ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();    @Test    public void test1() throws ExecutionException, InterruptedException &#123;        Thread thread = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                readLock.lock();                System.out.println(\"获取读锁成功\");                readLock.unlock();            &#125;        &#125;);        readLock.lock();        thread.start();        thread.join();        readLock.unlock();    &#125;&#125;\n\n读写互斥\n12345678910111213141516171819202122232425public class TestThread &#123;    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();    private ReentrantReadWriteLock.ReadLock readLock = lock.readLock();    private ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();    @Test    public void test1() throws ExecutionException, InterruptedException &#123;        Thread thread = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                if(readLock.tryLock())&#123;                    System.out.println(\"获取读锁成功\");                    readLock.unlock();                &#125;                else                    System.out.println(\"获取读锁失败\");            &#125;        &#125;);        writeLock.lock();        thread.start();        thread.join();        writeLock.unlock();    &#125;&#125;\n\n写写互斥\n12345678910111213141516171819202122232425public class TestThread &#123;    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();    private ReentrantReadWriteLock.ReadLock readLock = lock.readLock();    private ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();    @Test    public void test1() throws ExecutionException, InterruptedException &#123;        Thread thread = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                if(writeLock.tryLock())&#123;                    System.out.println(\"获取写锁成功\");                    writeLock.unlock();                &#125;                else                    System.out.println(\"获取写锁失败\");            &#125;        &#125;);        writeLock.lock();        thread.start();        thread.join();        writeLock.unlock();    &#125;&#125;\n\n\n\nReentrantReadWriteLock原理同步器ReadLock和WriteLock使用的是同一个同步器，也就是该同步器既支持排他模式，又支持共享模式。\n12345public ReentrantReadWriteLock(boolean fair) &#123;    sync = fair ? new FairSync() : new NonfairSync();    readerLock = new ReadLock(this);    writerLock = new WriteLock(this);&#125;\n\n123protected ReadLock(ReentrantReadWriteLock lock) &#123;    sync = lock.sync;&#125;\n\n123protected WriteLock(ReentrantReadWriteLock lock) &#123;    sync = lock.sync;&#125;\n\n\n状态StateReentrantReadWriteLock的同步器中，读锁和写锁共用一个state\n读锁占用高16位\n写锁占用低16位\nWriteLock获取锁调用流程\nWriteLock.lock()调用acquire获取排他锁\n\n123public void lock() &#123;    sync.acquire(1);&#125;\n\nAQS在acquire中调用tryAcquire\nSync调用tryAcquire有人获得了读锁：失败\n有人获得了写锁：失败\n都无：获取写锁\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243@ReservedStackAccessprotected final boolean tryAcquire(int acquires) &#123;    /*             * Walkthrough:             * 1. If read count nonzero or write count nonzero             *    and owner is a different thread, fail.             * 2. If count would saturate, fail. (This can only             *    happen if count is already nonzero.)             * 3. Otherwise, this thread is eligible for lock if             *    it is either a reentrant acquire or             *    queue policy allows it. If so, update state             *    and set owner.             */    // 获取当前线程    Thread current = Thread.currentThread();    // 获取state    int c = getState();    // 获取写锁state    int w = exclusiveCount(c);    // 有人获得了锁（读锁，写锁）    if (c != 0) &#123;        // (Note: if c != 0 and w == 0 then shared count != 0)        // 1. c != 0且w == 0说明有线程获取了读锁，此时获取写锁失败，即读写互斥        if (w == 0 || current != getExclusiveOwnerThread())        // 2. 当前获得写锁的线程不是自己，此时获取写锁失败，写写互斥            return false;        // 判断是否超过最大重入次数        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)            throw new Error(\"Maximum lock count exceeded\");\t\t// 获取写锁，重入或非重入        setState(c + acquires);        return true;    &#125;    // 无人获得锁    // 判断写者是否应该阻塞---&gt;用于实现公平与非公平锁    if (writerShouldBlock() ||        // 获取写锁        !compareAndSetState(c, c + acquires))        return false;    // 设置写锁的拥有者为当前线程    setExclusiveOwnerThread(current);    return true;&#125;\n\n释放锁调用流程\nWriteLock.unlock()\n123public void unlock() &#123;    sync.release(1);&#125;\n\nAQS在release中调用tryRelease\nSync调用tryRelease\n12345678910111213@ReservedStackAccessprotected final boolean tryRelease(int releases) &#123;    if (!isHeldExclusively())        throw new IllegalMonitorStateException();    // 锁重入次数    int nextc = getState() - releases;    boolean free = exclusiveCount(nextc) == 0;    // 锁重入次数为0时，释放写锁    if (free)        setExclusiveOwnerThread(null);    setState(nextc);    return free;&#125;\n\nReadLock获取锁调用流程\nReadLock.lock()调用了acquireShared获取共享锁\n\n123public void lock() &#123;    sync.acquireShared(1);&#125;\n\nAQS在acquireShared中调用tryAcquireShared\n\nSync调用tryAcquireShared\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243@ReservedStackAccessprotected final int tryAcquireShared(int unused) &#123;    // 获取当前线程    Thread current = Thread.currentThread();    // 获取state    int c = getState();    // 获取排他锁的state    // 若有线程拿着排他锁且这个线程不是当前线程，则获取失败    // 即读写互斥    if (exclusiveCount(c) != 0 &amp;&amp;        getExclusiveOwnerThread() != current)        return -1;    // 获取共享锁的state    int r = sharedCount(c);    // 判断读者是否应该阻塞---&gt;用于实现公平与非公平锁    if (!readerShouldBlock() &amp;&amp;        r &lt; MAX_COUNT &amp;&amp;        // 把共享锁的state加1        compareAndSetState(c, c + SHARED_UNIT)) &#123;        // 如果当前线程为第一个读者        if (r == 0) &#123;            // 记录下当前线程为第一个读者            firstReader = current;            // 记录下第一个读者重入的次数            firstReaderHoldCount = 1;        // 如果当前线程是之前记录下的第一个读者        &#125; else if (firstReader == current) &#123;            // 第一个读者重入的次数加1            firstReaderHoldCount++;        // 如果当前线程不是第一个读者，也不是以前记录的第一个读者        &#125; else &#123;            HoldCounter rh = cachedHoldCounter;            if (rh == null ||                rh.tid != LockSupport.getThreadId(current))                cachedHoldCounter = rh = readHolds.get();            else if (rh.count == 0)                readHolds.set(rh);            rh.count++;        &#125;        return 1;    &#125;    return fullTryAcquireShared(current);&#125;\n\n释放锁调用流程\nReadLock.unlock()\n123public void unlock() &#123;    sync.releaseShared(1);&#125;\n\nAQS中调用tryReleaseShared()\n\nSync调用tryReleaseShared()\n\n12345678910111213141516171819202122232425262728293031323334@ReservedStackAccessprotected final boolean tryReleaseShared(int unused) &#123;    // 获取当前线程    Thread current = Thread.currentThread();    // 如果是第一个读者要求释放读锁    if (firstReader == current) &#123;        // assert firstReaderHoldCount &gt; 0;        if (firstReaderHoldCount == 1)            firstReader = null;        else            firstReaderHoldCount--;    &#125; else &#123;        HoldCounter rh = cachedHoldCounter;        if (rh == null ||            rh.tid != LockSupport.getThreadId(current))            rh = readHolds.get();        int count = rh.count;        if (count &lt;= 1) &#123;            readHolds.remove();            if (count &lt;= 0)                throw unmatchedUnlockException();        &#125;        --rh.count;    &#125;    for (;;) &#123;        int c = getState();        int nextc = c - SHARED_UNIT;        if (compareAndSetState(c, nextc))            // Releasing the read lock has no effect on readers,            // but it may allow waiting writers to proceed if            // both read and write locks are now free.            return nextc == 0;    &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","plink":"https://beginc.github.io/post/Java并发之ReentrantReadWriteLock/"},{"title":"Java集合之CopyOnWriteArrayList","date":"2020-03-04T10:55:56.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-05T07:49:45.498Z","content":"","thumbnail":"post/Java集合之CopyOnWriteArrayList/cover.jpg","plink":"https://beginc.github.io/post/Java集合之CopyOnWriteArrayList/"},{"title":"Java集合之ConcurrentLinkedDeque","date":"2020-03-04T10:55:44.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-05T07:49:41.662Z","content":"","thumbnail":"post/Java集合之ConcurrentLinkedDeque/cover.jpg","plink":"https://beginc.github.io/post/Java集合之ConcurrentLinkedDeque/"},{"title":"Java集合之LinkedBlockingQueue","date":"2020-03-04T10:55:08.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-05T07:50:04.834Z","content":"","thumbnail":"post/Java集合之LinkedBlockingQueue/cover.jpg","plink":"https://beginc.github.io/post/Java集合之LinkedBlockingQueue/"},{"title":"Java集合之Deque","date":"2020-03-04T10:44:00.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-16T15:30:48.411Z","content":"继承体系继承自Queue接口，为双端队列(Double End Queue)。\n\n\nDueue接口队头增\n123void addFirst(E e);boolean offerFirst(E e);void push(E e);\n\n拿\n123456789E element();E getFirst();E peek();E peekFirst();E poll();E pollFirst();E pop();E remove();E removeFirst();\n\n队尾增\n12345boolean addAll(Collection&lt;? extends E&gt; c);boolean add(E e);void addLast(E e);boolean offer(E e);boolean offerLast(E e);\n\n拿\n1234E getLast();E peekLast();E pollLast();E removeLast();\n\n实现类ArrayDeque基于数组（可扩容）。\nLinkedList该该类也实现了Deque接口。\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之Deque/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之Deque/"},{"title":"Java集合之Queue","date":"2020-03-04T10:30:45.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-16T15:30:48.411Z","content":"继承体系继承自Collection接口。\n\n\nQueue接口入队\n12boolean add(E e);boolean offer(E e);\n\n出队\n12E remove();E poll();\n\n取队头\n12E element();E peek();\n\n两组方法的区别区别在于失败的情况下\n\n功能抛异常返回false或null\n\n添加元素到队尾add(E e)boolean offer(E e)\n\n取队首元素并删除E remove()E poll()\n\n取队首元素但不删除E element()E peek()\n实现类PriorityQueue优先队列，其实就是大顶堆，小顶堆。\n元素需要实现Comparable接口或者传入Comparator\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之Queue/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之Queue/"},{"title":"Java集合之TreeSet","date":"2020-03-04T10:11:09.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-16T15:30:48.411Z","content":"继承体系实现了NavigableSet接口。提供按Key排序顺序的迭代顺序。\n\n\n底层实现使用TreeMap来保证Key排序。\n\n\n添加\n\n\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之TreeSet/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之TreeSet/"},{"title":"Java集合之LinkedHashSet","date":"2020-03-04T10:10:57.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-16T15:30:48.411Z","content":"继承体系继承自HashSet。保证迭代顺序为Key插入的顺序。\n\n\n底层原理使用的是LinkedHashMap来保证顺序。\nHashSet构造方法\n可看出，调用该构造方法时，创建的是一个LinkedHashMap。\n123HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125;\n\nLinkedHashSet构造方法\n\n\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之LinkedHashSet/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之LinkedHashSet/"},{"title":"Java集合之HashSet","date":"2020-03-04T10:10:49.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-16T15:30:48.411Z","content":"继承体系实现了Set接口。\n\n\n底层实现底层使用HashMap来保证元素的唯一性。\n\n\n添加元素\n直接使用HashMap.put，根据put的结果判断是否添加成功。\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之HashSet/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之HashSet/"},{"title":"Java集合之Set","date":"2020-03-04T10:10:39.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-16T15:30:48.411Z","content":"继承体系继承自Collection接口。Set保证集合内元素不重复。\n\n\nSet接口无新方法。\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之Set/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之Set/"},{"title":"Java集合之ConcurrentHashMap","date":"2020-03-04T04:00:37.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-16T15:30:48.411Z","content":"线程安全集合遗留类Hashtable操作方法都加上了synchronized方法\n线程安全\n效率低\n\n\n\n\n\n\nVector操作方法都加上了synchronized方法\n线程安全\n效率低\n\n\n\n\n\n\nCollections.synchronizedXXX装饰器模式，给所有的方法都加上了synchronized锁\n线程安全\n效率低\n\n\n\n\nConcurrentXXX位于JUC包下的线程安全集合，更加高效的线程安全集合。\nConcurrentHashMap继承体系实现了ConcurrentMap接口，该接口继承自Map接口。\n\n\nConcurrentHashMap之JDK1.8底层实现哈希表\n拉链法解决哈希冲突链表\n红黑树\n\n大部分逻辑和HashMap相同，如扩容策略，链表和红黑树互转时机等，只是多了并发控制。\n并发初始化在第一次put时会进行哈希桶的延时初始化，使用CAS和sizeCtl的状态来做并发控制。\n\n\n并发读不加锁，可直接读。\n读转发当发现哈希桶的某个头节点的hash小于0时，这时候可能是\n\n\n该节点为红黑树节点\n正在进行扩容Rehash操作，该节点被转移到了新的哈希桶中\n此时会调用该节点的find方法进行读操作的转发。\n\n\n并发写第一次Put进行哈希桶初始化。\n\n\n当前Key对应的哈希桶为空CAS将其替换成新节点。\n\n\n当前Key对应的哈希桶不为空插入\n对该哈希桶的头节点使用synchronized加锁细粒度锁，只锁住需要操作的链表，提高并发度\n\n若为链表，则尾插法插入链表末尾（无相同节点的情况下，有相同的根据onlyIfAbsent判断是否替换）\n若为红黑树，则插入红黑树（无相同节点的情况下，有相同的根据onlyIfAbsent判断是否替换）\n树化\n若链表长度大于TREEIFY_THRESHOLD，则转化为红黑树。\n计数\n把size加1，这里使用了和LongAdder相同的机制，并发写的情况下会设置Cell来转移冲突，提高并发。\n扩容\n若元素数量达到阈值，进行并发扩容。\n并发扩容ConcurrentHashMap中的并发扩容不是让一个线程扩容，其他线程阻塞，而是当线程发现哈希表正在扩容时，会一起加入帮助进行Rehash步骤。\n任务分配根据CPU核心的数量计算出每个线程应该负责的链表的数量，最小为MIN_TRANSFER_STRIDE（16）\n\n\n\n\n转发标记一个链表只能被一个线程进行Rehash，所以当一个链表开始被某个线程进行处理时，它会首先将该链表头替换成一个ForwardingNode作为标记，这样其他线程发现该链表头为ForwardingNode时就知道该链表已经有线程在进行处理了。\n\n\nSize计算由于存储size时使用了Cell来转移冲突，所以统计元素数量时就需要将所有的Cell中计数和baseCount加起来。\n\n\nSize弱一致性\n由于在统计元素数量时可能还会有并发进行的写操作，所以统计出来的size不一定是准确的。\nConcurrentHashMap之JDK1.7底层实现两层哈希表\n外层Segment\n\n内层HashEntry\n\n冲突解决方法为拉链法\n链表\n\n\n\nSegment数组初始化构造器调用时直接进行初始化，分配Segment数组空间。\nSegment数组大小固定，不可变\nSegment继承自ReentrantLock\n并发读读操作不加锁，可并发进行。\n并发写自旋获取对应Segment的锁在多处理器环境下，重复次数为64\n单处理器重复次数为1\n当执行tryLock()方法的次数超过上限时，则执行lock()方法挂起线程\n\n写入已经获取了分段锁，所以可以直接写\n\nSize计算求和所有Segment的元素数量，并记录下当前所有Segment的总modCount\n计算完后记录下当前的modCount求和结果为last\n再次回到步骤1，计算完后判断modCount和是否等于last相等：统计期间未发生并发修改，结果有效\n不相等：统计期间发生了并发修改，结果无效，回到步骤1进行重试，最多重试RETRIES_BEFORE_LOCK（2）次\n\n若重试两次后依旧结果无效，则对当前Segment进行加锁，再次统计\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之ConcurrentHashMap/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之ConcurrentHashMap/"},{"title":"Java集合之TreeMap","date":"2020-03-04T04:00:31.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-16T15:30:48.411Z","content":"继承体系实现了NavigableMap接口。\n\n\n底层实现红黑树。\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之TreeMap/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之TreeMap/"},{"title":"Java集合之LinkedHashMap","date":"2020-03-04T04:00:25.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-16T15:30:48.408Z","content":"继承体系继承自HashMap。\n和TreeMap的不同\nTreeMap保证的顺序是Key的排序顺序，而不是插入顺序。\n\n\n迭代顺序插入顺序保证了迭代顺序为Key插入的顺序。\nLRU顺序保住了迭代顺序为最近最少使用的Key到最近使用最多的Key。可用来实现LRU缓存。\naccessOrder为true\n123456public LinkedHashMap(int initialCapacity,                         float loadFactor,                         boolean accessOrder) &#123;    super(initialCapacity, loadFactor);    this.accessOrder = accessOrder;&#125;\n\n影响顺序的方法\nput\nputAll\nputIfAbsent\nget\ngetOrDefault\nreplace\ncompute\ncomputeIfAbsent\ncomputeIfPresent\nmerge\n不影响顺序\n使用下列方法时，不影响顺序。\nkeySet\nvalues\nentrySet\n底层实现底层使用了双向链表来串联所有的Entry，其顺序就是Key插入的顺序。\n实现原理在HashMap中为LinkedHashMap预留了三个回调函数，在执行了对应的方法后，就会调用对应的回调函数。\n123void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;void afterNodeInsertion(boolean evict) &#123; &#125;void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;\n\nafterNodeAccess当开启了accessOrder时，将其放到链表的尾部。\n\n\nafterNodeInsertion扩展点\n要实现LRU缓存的自动淘汰功能，可重写removeEldestEntry来决定是否要进行节点删除。\n\n\nafterNodeRemoval从链表移除节点。\nnewNodeHashMap中使用newNode来创建链表节点\n\n\nLinkedHashMap重写了newNode方法，同时还将新的节点插入了链表的末尾\n\n\nnewTreeNode原理同newNode\n\n\n实现LRU缓存1234567891011121314151617181920class LRUCache extends LinkedHashMap&lt;String, Integer&gt;&#123;    private final int capacity;    private final int DEFAULT_CACHE_CAPACITY = 16;    public LRUCache()&#123;        super(16, 0.75f, true);        this.capacity = DEFAULT_CACHE_CAPACITY;    &#125;    public LRUCache(int capacity)&#123;        super(capacity, 0.75f, true);        this.capacity = capacity;    &#125;    @Override    protected boolean removeEldestEntry(Map.Entry&lt;String, Integer&gt; eldest) &#123;        return size() &gt; capacity;    &#125;&#125;\n\n测试\n1234567891011121314public class Main &#123;    public static void main(String[] args) &#123;        LRUCache cache = new LRUCache(4);        cache.put(\"A\", 1);        cache.put(\"B\", 2);        cache.put(\"C\", 3);        cache.put(\"D\", 4);        // &#123;A=1, B=2, C=3, D=4&#125;        System.out.println(cache);        cache.put(\"E\", 5);        // &#123;B=2, C=3, D=4, E=5&#125;        System.out.println(cache);    &#125;&#125;\n\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之LinkedHashMap/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之LinkedHashMap/"},{"title":"Java集合之NavigableMap","date":"2020-03-04T03:48:20.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-16T15:30:48.408Z","content":"继承体系继承自SortedMap接口，扩展提供了对于给定key的最近邻查找功能（小于，小于等于，大于，大于等于）。\n\n\nNavigableMap接口查\nlower即小于\nfloor即小于等于\nhigher即大于\nceiling即大于等于\n12345678K lowerKey(K key);Map.Entry&lt;K,V&gt; lowerEntry(K key);K floorKey(K key);Map.Entry&lt;K,V&gt; floorEntry(K key);K higherKey(K key);Map.Entry&lt;K,V&gt; higherEntry(K key);K ceilingKey(K key);Map.Entry&lt;K,V&gt; ceilingEntry(K key);\n\n迭代\n12NavigableSet&lt;K&gt; descendingKeySet();NavigableMap&lt;K,V&gt; descendingMap();\n\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之NavigableMap/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之NavigableMap/"},{"title":"Java集合之SortedMap","date":"2020-03-04T03:39:18.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-16T15:30:48.411Z","content":"继承体系继承自Map接口，提供了按key的排序顺序迭代访问集合的功。\nKey必须实现Comparable接口或提供Comparator\n\n\nSortedMap接口查\n1234// 返回排序器，若返回null说明使用自然排序Comparator&lt;? super K&gt; comparator();K firstKey();K lastKey();\n\n迭代\n123456// toKey为exclusiveSortedMap&lt;K,V&gt; headMap(K toKey);// fromKey为inclusiveSortedMap&lt;K,V&gt; tailMap(K fromKey);// [fromKey, toKey)SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey);\n\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之SortedMap/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之SortedMap/"},{"title":"Java集合之Map","date":"2020-03-04T03:20:34.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-16T15:30:48.408Z","content":"继承体系Map接口为顶层接口。Map并未实现Iterable接口。\nMap接口增改\n123V put(K key, V value);void putAll(Map&lt;? extends K, ? extends V&gt; m);V putIfAbsent(K key, V value);\n\n删\n12void clear();V remove(Object key);\n\n查\n12345V get(Object key);V getOrDefault(Object key, V defaultValue);boolean containsKey(Object key);boolean containsValue(Object value);boolean isEmpty();\n\n迭代\n123Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();Set&lt;K&gt; keySet();Collection&lt;V&gt; values();\n\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之Map/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之Map/"},{"title":"Java集合之HashMap","date":"2020-03-04T03:19:11.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"updated":"2020-03-16T15:30:48.408Z","content":"继承体系Map接口的实现类。\n\n\nHashMap之JDK1.8底层实现哈希表\n冲突解决方法---&gt;拉链法链表\n红黑树\n\n\n\nHashMap重点问题哈希算法\n\n哈希表的尺寸问题\n扩容何时扩容\n扩多少\n\nRehash\n\n拉链查找的效率问题\n链表与红黑树的转化时机\n\n哈希算法哈希算法的优劣\n评判一下哈希算法的优劣主要就是看是否能将key均匀的映射到桶上，减少哈希冲突。\n三次运算\nkey.hashCode()\n1key.hashCode()\n\n扰动\n将hashCode的低16位和高16位进行按位异或\n\n1次异或运算\n\n让hash分布的更均匀\n\n\n1hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16)\n\n与bucketSize进行模运算此处位运算与hash % bucketSize等价，但是效率更高\n\n1index = hash &amp; (bucketSize - 1)\n\n哈希表的初始化JDK1.8中哈希表在第一次put操作时才进行延迟初始化，分配桶数组空间。\n哈希表的尺寸问题何时扩容当前元素数量大于阈值时进行扩容。\n阈值\nloadFactory为重要参数哈希表的效率由loadFactory决定过高则查找效率太低\n过低则空间利用率太低\n\n\n默认loadFactory为0.75\n1threshold = capacity * loadFactor\n\n扩多少每次扩容到原来尺寸的一倍\n16---&gt;32\n32---&gt;64\n...\n1newCap = oldCap &lt;&lt; 1\n\nRehash扩容之后会对元素重新进行hash，让元素均匀分布到新的哈希表上。\n优化点\n由于每次扩容为原来的两倍，元素重新进行哈希后只可能落在两个桶中的一个\n当hash &amp; oldCap == 0：落在原来的桶\n当hash &amp; oldCap == 1：落在原来的桶的下标再加上oldCap处\n利用此点可避免rehash时重新计算每一个key的hash。\n链表插入方法\n尾插法（避免并发扩容时发生循环死链）\n拉链查找的效率问题当哈希冲突过多时，使用原始拉链法则会造成同一个桶的链很长，查找效率过低，因此JDK1.8中引入了红黑树进行优化\n当链过长时会将其转化为红黑树\n当链过短时会将其退化为链表\n转化时机链表转红黑树\n桶数组长度大于等于MIN_TREEIFY_CAPACITY（64）\n该链长度大于TREEIFY_THRESHOLD（8）\n红黑树转链表\n链表长度小于UNTREEIFY_THRESHOLD\nHashMap之1.7底层实现哈希表\n冲突解决方法---&gt;拉链法链表\n\n\n\n哈希算法三次运算\nkey.hashCode()\n1key.hashCode()\n\n扰动\n5次异或运算\n\n让hash分布的更均匀\n\n\n123h ^&#x3D; k.hashCode();h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);h &#x3D; h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);\n\n与bucketSize进行模运算\n1index = hash &amp; (bucketSize - 1)\n\n哈希表的初始化JDK1.7中哈希表在构造方法处就进行初始化，分配桶数组空间。\n哈希表的尺寸问题何时扩容同JDK1.8。\n扩多少同JDK1.8。\nRehash扩容之后会对元素重新进行hash，让元素均匀分布到新的哈希表上。\n哈希无优化，直接重新计算\n\n链表插入方法为尾插法（并发扩容时可能发生循环死链）\n\n并发死链TODO\nHashMap1.7与1.8比较\n功能1.71.8\n\n拉链结构链表链表 + 红黑树\n\n扩容时链表插入方式头插法尾插法\n\n哈希表初始化时机构造器初始化第一次put时延迟初始化\n\n哈希算法五次异或一次异或\n\nRehash重新计算hash不用重新计算哈希\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之HashMap/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之HashMap/"},{"title":"JVM之类加载","date":"2020-03-03T07:54:09.000Z","date_formatted":{"ll":"Mar 3, 2020","L":"03/03/2020","MM-DD":"03-03"},"updated":"2020-03-03T09:55:28.639Z","content":"类加载阶段加载将类的字节码载入方法区，为instanceKlass结构。\n\n\n链接验证验证字节码是否符合JVM规范。\n准备为static变量分配空间，设置默认值。注意是设置默认值，不是赋值\nJDK1.8中静态变量存储在类对象中（堆）\n\n若static变量为final的基本类型或String，则赋值在准备阶段完成\n若static变量为final的引用类型，则赋值会在初始化阶段完成，而不是准备阶段\n解析将常亮池中的符号引用全部转换成直接引用。\n类和接口的全限定名\n字段的名称和描述符\n方法的名称和描述符\n未解析的常量池，还不知道类，字段，方法等的具体内存位置。\n\n\n解析后的常亮池，符号引用变成了内存地址。\n\n\n初始化即执行类的()V方法\nJVM保证该方法执行的线程安全性\n初始化发生的时机类初始化是懒惰的。\n触发初始化\nmain方法所在的类，总会被首先初始化\n首次访问类的静态变量或静态方法\n子类初始化，会触发父类的初始化\n子类访问父类的静态常亮，只会触发父类的初始化\nnew对象\n不触发初始化\n访问类的static final修饰的基本类型或String常量，不会触发初始化\n访问类的Class对象，不会触发初始化\n创建类的数组，不会触发初始化\n类加载器的loadClass方法，不会触发初始化\nClass.forName的第二个参数为false时，不会触发初始化\n类加载器类加载器类别\n\n双亲委派模式如果一个类加载器收到了加载某个类的请求,则该类加载器并不会去加载该类,而是把这个请求委派给父类加载器,每一个层次的类加载器都是如此,因此所有的类加载请求最终都会传送到顶端的启动类加载器;只有当父类加载器在其搜索范围内无法找到所需的类,并将该结果反馈给子类加载器,子类加载器会尝试去自己加载。\n\n\n打破双亲委派DriverManager是由BootstrapClassLoader但它却使用了ServiceLoader.load方法来加载Driver实现类，而ServiceLoader.load中使用的是线程上下文类加载器，为Applicationn ClassLoader，打破了双亲委派。\n\n\n线程上下文类加载器ClassLoader.getSystemClassLoader()为Application ClassLoader\n\nThread.currentThread().getContextClassLoader()线程上下文类加载器\n为Application ClassLoader\n\n自定义类加载器何时需要自定义类加载器加载任意路径下的类文件\n实现同名类的隔离仅当包名类型和类加载器都相同时，两个类才相同\n\n步骤继承ClassLoader\n重写findClass方法读取类文件成为byte[]\n使用defineClass来加载类\n\n使用者调用loadClass来加载类\n123456789101112131415161718192021222324class MyClassLoader extends ClassLoader&#123;    public static final String PATH = \"C:\\\\Users\\\\Administrator\\\\Desktop\";    @Override    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;        File file = new File(PATH, name + \".class\");        try(FileInputStream in = new FileInputStream(file); ByteArrayOutputStream out = new ByteArrayOutputStream();)&#123;            int avaliable;            byte[] buffer = new byte[1024];            while((avaliable = in.read(buffer)) != -1)&#123;                out.write(buffer, 0, avaliable);            &#125;           return defineClass(name, out.toByteArray(), 0, out.size());        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;\n\n1234567public class Main &#123;    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;        MyClassLoader loader = new MyClassLoader();        Class cls = loader.loadClass(\"Person\");        System.out.println(cls);    &#125;&#125;\n\n\n\n","thumbnail":"post/Java/JVM/JVM之类加载/cover.jpg","plink":"https://beginc.github.io/post/Java/JVM/JVM之类加载/"},{"title":"JVM之类文件结构","date":"2020-03-03T06:33:46.000Z","date_formatted":{"ll":"Mar 3, 2020","L":"03/03/2020","MM-DD":"03-03"},"updated":"2020-03-03T09:55:28.639Z","content":"类文件结构魔数\n版本次版本号\n主版本号\n\n常量池\n访问标志\n本类索引\n父类索引\n接口\n字段\n方法\n属性\n\n\n1234567891011public class Main&#123;    int field;    public Main()&#123;        field = 1;    &#125;    public static void main()&#123;        String str = \"Hello Java\";    &#125;&#125;\n\n对应的反编译后的信息。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Classfile /C:/Users/Administrator/Desktop/Main.class  Last modified 2020-3-3; size 294 bytes  MD5 checksum d044bf6f49686f9050ce57df066d7b98  Compiled from \"Main.java\"public class Main  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #5.#15         // java/lang/Object.\"&lt;init&gt;\":()V   #2 = Fieldref           #4.#16         // Main.field:I   #3 = String             #17            // Hello Java   #4 = Class              #18            // Main   #5 = Class              #19            // java/lang/Object   #6 = Utf8               field   #7 = Utf8               I   #8 = Utf8               &lt;init&gt;   #9 = Utf8               ()V  #10 = Utf8               Code  #11 = Utf8               LineNumberTable  #12 = Utf8               main  #13 = Utf8               SourceFile  #14 = Utf8               Main.java  #15 = NameAndType        #8:#9          // \"&lt;init&gt;\":()V  #16 = NameAndType        #6:#7          // field:I  #17 = Utf8               Hello Java  #18 = Utf8               Main  #19 = Utf8               java/lang/Object&#123;  int field;    descriptor: I    flags:  public Main();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=2, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V         4: aload_0         5: iconst_1         6: putfield      #2                  // Field field:I         9: return      LineNumberTable:        line 4: 0        line 5: 4        line 6: 9  public static void main();    descriptor: ()V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=1, locals=1, args_size=0         0: ldc           #3                  // String Hello Java         2: astore_0         3: return      LineNumberTable:        line 9: 0        line 10: 3&#125;SourceFile: \"Main.java\"\n\n\n\n魔数开头四个字节，固定为0xCAFEBABE，标识为Java字节码，若没有则为无效类文件。\n版本描述版本信息。\n常量池常量池表项数为constant_pool_count - 1。\n常量池表主要存放两类信息\n字面量\n符号引用类和接口的全限定名\n字段的名称和描述符\n方法的名称和描述符\n\n1234567891011121314151617181920Constant pool:   #1 = Methodref          #5.#15         // java/lang/Object.\"&lt;init&gt;\":()V   #2 = Fieldref           #4.#16         // Main.field:I   #3 = String             #17            // Hello Java   #4 = Class              #18            // Main   #5 = Class              #19            // java/lang/Object   #6 = Utf8               field   #7 = Utf8               I   #8 = Utf8               &lt;init&gt;   #9 = Utf8               ()V  #10 = Utf8               Code  #11 = Utf8               LineNumberTable  #12 = Utf8               main  #13 = Utf8               SourceFile  #14 = Utf8               Main.java  #15 = NameAndType        #8:#9          // \"&lt;init&gt;\":()V  #16 = NameAndType        #6:#7          // field:I  #17 = Utf8               Hello Java  #18 = Utf8               Main  #19 = Utf8               java/lang/Object\n\n访问标志\n\n语法原理构造方法cinit编译器会从上至下收集所有静态代码块和静态成员赋值的代码，合并成为一个()V方法\n该方法在类加载的初始化阶段被调用\n\n\n\n\n\n\ninit编译器会从上至下收集{}初始化代码块和成员变量赋值的代码，形成新的构造方法，但原始构\n造方法内的代码总是在最后。\n多态\n\n本类方法：实际调用的方法地址\n\n\ninvokevirtual\n通过对象的对象头KClass部分找到实际的Class\nKClass结构中有vtable，方法映射规则在编译器已经写好了\n查表获取方法的具体地址\n执行字节码\n","thumbnail":"post/Java/JVM/JVM之类文件结构/cover.jpg","plink":"https://beginc.github.io/post/Java/JVM/JVM之类文件结构/"},{"title":"Java之动态代理","date":"2020-03-03T02:32:21.000Z","date_formatted":{"ll":"Mar 3, 2020","L":"03/03/2020","MM-DD":"03-03"},"updated":"2020-03-03T05:44:01.048Z","content":"JDK动态代理JDK动态代理可以动态的创建一个接口的实现对象，也可以动态创建一个接口的实现类的代理对象，配合反射方法调用，动态的织入横切逻辑。\n接口\n12345interface Person &#123;    void eat();    void walk();&#125;\n\n实现类\n123456789101112class PersonImpl implements Person &#123;    @Override    public void eat() &#123;        System.out.println(\"Eating...\");    &#125;    @Override    public void walk() &#123;        System.out.println(\"Walking...\");    &#125;&#125;\n\n产生代理\nProxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h )loader为接口的类加载器\ninterfaces为要代理的接口\nInvocationHandler处理方法调用\n\n123456789101112131415161718192021222324252627class PersonProxyFactory &#123;    public static Person getInstance(Person person) &#123;        return (Person) Proxy.newProxyInstance(person.getClass().getClassLoader(), new Class[]&#123;                Person.class        &#125;, new PersonInvocationHandler(person));    &#125;&#125;class PersonInvocationHandler implements InvocationHandler &#123;    private Person person;    public PersonInvocationHandler(Person person) &#123;        this.person = person;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        // 方法调用前织入逻辑        System.out.println(\"Before...\");        Object object = method.invoke(person, args);        // 方法调用后织入逻辑        System.out.println(\"After...\");        return object;    &#125;&#125;\n\n缺点\n类必须要实现接口才能代理\nCGLIB动态代理CGLIB动态生成代理类的子类来实现方法拦截。\nMethodInterceptor用于拦截被代理的对象的方法调用。\nobj被代理对象\nmethod被拦截的方法\nargs参数\nproxy用于调用被代理对象的方法\n12345678910class PersonIntercetor implements MethodInterceptor&#123;    @Override    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;        System.out.println(\"Before...\");        Object object = methodProxy.invokeSuper(o, objects);        System.out.println(\"After...\");        return object;    &#125;&#125;\n\nEnhancer用于创建代理对象。\n123456789101112public class Main &#123;    public static void main(String[] args) &#123;        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(PersonImpl.class);            enhancer.setCallback(new PersonIntercetor());        PersonImpl person = (PersonImpl) enhancer.create();        person.eat();        person.walk();    &#125;&#125;\n\nCallbackFilter用于根据方法调用不同的Callback。\nEnhancer传入Callback数组\nCallbackFilter返回该调用的Callback在数组中的下标\n123456789101112class PersonCallbackFilter implements CallbackFilter&#123;    @Override    public int accept(Method method) &#123;        if(method.getName().equals(\"eat\"))            return 1;        else if(method.getName().equals(\"walk\"))            return 2;        return 0;    &#125;&#125;\n\n123456789101112131415161718192021222324252627282930313233343536373839public class Main &#123;    public static void main(String[] args) &#123;        Enhancer enhancer = new Enhancer();        MethodInterceptor intercepDefault = new MethodInterceptor() &#123;            @Override            public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;                return proxy.invokeSuper(obj, args);            &#125;        &#125;;        MethodInterceptor intercepEat = new MethodInterceptor() &#123;            @Override            public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;                System.out.println(\"Intercept Eat...\");                return proxy.invokeSuper(obj, args);            &#125;        &#125;;        MethodInterceptor intercepWalk = new MethodInterceptor() &#123;            @Override            public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;                System.out.println(\"Intercept Walk...\");                return proxy.invokeSuper(obj, args);            &#125;        &#125;;        enhancer.setSuperclass(PersonImpl.class);        enhancer.setCallbacks(new Callback[]&#123;                intercepDefault,                intercepEat,                intercepWalk        &#125;);        enhancer.setCallbackFilter(new PersonCallbackFilter());        PersonImpl person = (PersonImpl) enhancer.create();        person.eat();        person.walk();    &#125;&#125;\n\n一些特殊的CallbackNoOp什么做也不做，直接调用被代理的方法。\n123456789101112public class Main &#123;    public static void main(String[] args) &#123;        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(PersonImpl.class);        enhancer.setCallback(NoOp.INSTANCE);        PersonImpl person = (PersonImpl) enhancer.create();        person.eat();        person.walk();    &#125;&#125;\n\nFixedValue不调用代理方法，直接返回固定的值。\n123456789public interface FixedValue extends Callback &#123;    /**     * Return the object which the original method invocation should     * return. This method is called for &lt;b&gt;every&lt;/b&gt; method invocation.     * @return an object matching the type of the return value for every     * method this callback is mapped to     */    Object loadObject() throws Exception;&#125;\n\n1234567891011121314151617181920212223242526272829class Animal&#123;    private String category;    public Animal(String category) &#123;        this.category = category;    &#125;    public String getCategory() &#123;        System.out.println(\"Original Getter...\");        return category;    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(Animal.class);        enhancer.setCallback(new FixedValue() &#123;            @Override            public Object loadObject() throws Exception &#123;                return \"Fixed\";            &#125;        &#125;);        Animal animal = (Animal) enhancer.create(new Class[]&#123;String.class&#125;, new Object[]&#123;\"Dog\"&#125;);        // Fixed        System.out.println(animal.getCategory());    &#125;&#125;\n\nLazyLoader用于延迟加载对象。\n在属性第一次 被getter方法获取时会调用LazyLoader的loadObject方法进行加载\n之后再调用getter不用再重新加载\n12345678910111213141516171819202122232425class Dog &#123;    private String category;    public Dog() &#123;    &#125;    public Dog(String category) &#123;        this.category = category;    &#125;    @Override    public String toString() &#123;        return \"Dog&#123;\" +                \"category='\" + category + '\\'' +                '&#125;';    &#125;    public String getCategory() &#123;        return category;    &#125;    public void setCategory(String category) &#123;        this.category = category;    &#125;&#125;\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445class Person &#123;    private String name;    private Dog dog;    public Person() &#123;        dog = getLazyDog();    &#125;    public Person(String name) &#123;        this.name = name;        dog = getLazyDog();    &#125;\t    // 创建延迟加载对象    public Dog getLazyDog()&#123;        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(Dog.class);        enhancer.setCallback(new LazyLoader() &#123;            @Override            public Object loadObject() throws Exception &#123;                Dog dog = new Dog();                dog.setCategory(\"柯基\");                return dog;            &#125;        &#125;);        return (Dog) enhancer.create();    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Dog getDog() &#123;        return dog;    &#125;    public void setDog(Dog dog) &#123;        this.dog = dog;    &#125;&#125;\n\n123456789101112public class Main &#123;    public static void main(String[] args) &#123;        Person person = new Person(\"小明\");        // 不会加载dog        System.out.println(person.getName());        // 加载dog        System.out.println(person.getDog());        // 不用重新加载dog        System.out.println(person.getDog());    &#125;&#125;\n\nDispatcher用于延迟加载对象\n每一次调用getter都会重新加载\n123456789101112131415161718192021222324252627282930313233343536373839404142434445class Person &#123;    private String name;    private Dog dog;    public Person() &#123;        dog = getLazyDog();    &#125;    public Person(String name) &#123;        this.name = name;        dog = getLazyDog();    &#125;\t// 创建延迟加载对象    public Dog getLazyDog()&#123;        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(Dog.class);        enhancer.setCallback(new Dispatcher() &#123;            @Override            public Object loadObject() throws Exception &#123;                System.out.println(\"...\");                Dog dog = new Dog();                dog.setCategory(\"柯基\");                return dog;            &#125;        &#125;);        return (Dog) enhancer.create();    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Dog getDog() &#123;        return dog;    &#125;    public void setDog(Dog dog) &#123;        this.dog = dog;    &#125;&#125;\n\n12345678910111213public class Main &#123;    public static void main(String[] args) &#123;        Person person = new Person(\"小明\");        // 不会加载dog        System.out.println(person.getName());        // 加载dog        System.out.println(person.getDog());        // 加载dog        System.out.println(person.getDog());            &#125;&#125;\n\nJDK动态代理和CGLIB动态代理速度对比创建速度各创建1000000次代理，JDK动态代理创建速度远快于CGLIB。\n\n\n1234567891011121314151617181920212223242526272829303132333435363738public class Main &#123;    public static void main(String[] args) &#123;        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(PersonImpl.class);        enhancer.setCallback(new MethodInterceptor() &#123;            @Override            public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;                return proxy.invokeSuper(obj, args);            &#125;        &#125;);        long start, end;        // *****************************************        start = System.currentTimeMillis();        for (int i = 0; i &lt; 1000000; i++) &#123;            Proxy.newProxyInstance(Person.class.getClassLoader(), new Class[]&#123;Person.class&#125;, new InvocationHandler() &#123;                @Override                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                    return method.invoke(proxy, args);                &#125;            &#125;);        &#125;        end = System.currentTimeMillis();        System.out.println(\"[JDK]: \" + (end - start) + \"ms\");        // *****************************************        // *****************************************        start = System.currentTimeMillis();        for (int i = 0; i &lt; 1000000; i++) &#123;            enhancer.create();        &#125;        end = System.currentTimeMillis();        System.out.println(\"[CGLIB]: \" + (end - start) + \"ms\");        // *****************************************    &#125;&#125;\n\n执行速度各执行100000000次简单方法，二者差不多。\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243public class Main &#123;    public static void main(String[] args) &#123;        Person personOriginal = new PersonImpl();        Person personByJDK = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class[]&#123;Person.class&#125;, new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                return method.invoke(personOriginal, args);            &#125;        &#125;);        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(PersonImpl.class);        enhancer.setCallback(new MethodInterceptor() &#123;            @Override            public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;                return proxy.invokeSuper(obj, args);            &#125;        &#125;);        Person personByCGLIB = (Person) enhancer.create();        long start, end;        // *****************************************        start = System.currentTimeMillis();        for (int i = 0; i &lt; 100000000; i++) &#123;            personByJDK.eat();        &#125;        end = System.currentTimeMillis();        System.out.println(\"[JDK]: \" + (end - start) + \"ms\");        // *****************************************        // *****************************************        start = System.currentTimeMillis();        for (int i = 0; i &lt; 100000000; i++) &#123;            personByCGLIB.eat();        &#125;        end = System.currentTimeMillis();        System.out.println(\"[CGLIB]: \" + (end - start) + \"ms\");        // *****************************************    &#125;&#125;\n\n","thumbnail":"post/Java/Java语言/Java之动态代理/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java之动态代理/"},{"title":"12-Spring之AOP原理","date":"2020-03-03T02:24:27.000Z","date_formatted":{"ll":"Mar 3, 2020","L":"03/03/2020","MM-DD":"03-03"},"updated":"2020-03-03T05:44:01.048Z","content":"AOP注解注解开发时由@EnableAspectJAutoProxy启动AOP功能，由此注解开始研究。\n12345@EnableAspectJAutoProxy@Configurationpublic class MyConfig &#123;&#125;\n\nAOP原理导入AspectJAutoProxyRegistrar这个组件\n\n\nAspectJAutoProxyRegistrar实现了ImportBeanDefinitionRegistrar，向容器中注册了AspectJAnnotationAutoProxyCreator\n\n\n若容器中无name为org.springframework.aop.config.internalAutoProxyCreator的Bean则注册AnnotationAwareAspectJAutoProxyCreator的BeanDefinition\n\n\n\n\n查看AnnotationAwareAspectJAutoProxyCreator的继承关系，发现它是InstantiationAwareBeanPostProcessor的实现类，重点关注该接口的方法。\n\n\n调试发现最后进入父类AbstractAutoProxyCreator的postProcessAfterInitialization方法，此处准备创建代理对象。\n\n\n创建代理对象\n\n\n选择代理方法\n\n\n总结\n一句话就是使用InstantiationAwareBeanPostProcessor在Bean初始化完之后执行postProcessAfterInitialization为其生成了一个动态代理对象。\n","thumbnail":"post/Java/Spring/12-Spring之AOP原理/cover.png","plink":"https://beginc.github.io/post/Java/Spring/12-Spring之AOP原理/"},{"title":"11-Spring之循环引用","date":"2020-03-02T15:22:42.000Z","date_formatted":{"ll":"Mar 2, 2020","L":"03/02/2020","MM-DD":"03-02"},"updated":"2020-03-14T13:31:19.452Z","content":"循环引用循环引用即对象之前直接或间接的互为创建对象的前提条件，导致没有一个Bean能够创建成功，形象化比喻就是要由鸡得先有蛋，但是要由蛋得先有鸡。\nSpring检测循环引用基础数据结构DependentBeanMap就是一个HashMap，存储了一个Bean都被哪些Bean给依赖。\n\n\nDependenciesForBeanMap就是一个HashMap，存储了一个Bean都依赖了哪些Bean。\n\n\n检测机制核心解决思路就是\n创建A时先创建A的依赖B\n创建A的依赖B时先检查A是否又被B直接或间接依赖若A又被B依赖则发生了循环引用\n若A未被B依赖则无循环引用\n\n直接循环引用假设A和B直接循环引用。\n\n\n准备创建A\n\n发现A依赖B\n\n检查A是否被B依赖\n检查A的DependentBeanMap\n发现A的DependentBeanMap为null，则说明当前没有发现被B依赖\n\n\n记录当前发现的依赖关系\nA依赖B\nB被A依赖\n\n\n\n准备创建B\n\n发现B依赖A\n\n检查B是否被A依赖\n查看B的DependentBeanMap\n发现B被A依赖\n\n创建失败，发现循环引用\n\n间接循环引用假设A依赖B，B依赖C，C又依赖A。\n\n\n\n\n准备创建A\n\n发现A依赖B\n\n检查A是否被B依赖\n检查A的DependentBeanMap\n\n发现没有，则说明当前没有发现被B依赖\n\n\n\n记录当前发现的依赖关系\nA依赖B\nB被A依赖\n\n\n\n准备创建B\n\n发现B依赖C\n\n检查B是否被C依赖\n查看B的DependentBeanMap，发现不包含C，但是DependentBeanMap不为空\n此时可能发生间接循环引用\n\n递归检查每一个依赖B的Bean是否被C依赖\n检查到有，说明发生了间接循环引用\n未检查到，说明当前未发现\n\n[递归中]检查A是否被C依赖\n查看A的DependentBeanMap，发现为null，则说明当前没有发现A被C依赖\n\n[递归返回]检查完了每一个依赖B的Bean，发现当前未被C依赖，说明当前B未被C依赖\n\n记录当前发现的依赖关系\nB依赖C\nC被B依赖\n\n\n\n准备创建C\n发现C依赖A\n检查C是否被A依赖查看C的DependentBeanMap，发现不包含A，但是不为空\n此时可能发生间接循环引用\n\n递归检查每一个依赖C的Bean是否被A依赖\n[递归中]检查B是否被A依赖查看B的DependentBeanMap，发现包含A\n\n发生了间接循环引用\n源码分析\n\n\n\n循环引用解决方案\n\n使用Setter注入依赖使用Setter注入时，A与B都可顺利创建完毕，然后再使用Setter给其注入依赖。\n","thumbnail":"post/Java/Spring/11-Spring之循环引用/cover.png","plink":"https://beginc.github.io/post/Java/Spring/11-Spring之循环引用/"},{"title":"10-Spring之IoC容器初始化与Bean生命周期","date":"2020-03-02T15:22:14.000Z","date_formatted":{"ll":"Mar 2, 2020","L":"03/02/2020","MM-DD":"03-02"},"updated":"2020-03-03T05:44:01.048Z","content":"IoC容器初始化所以的步骤都在AbstractApplicationContext.refresh()方法中。\n\n\nprepareRefresh记录启动时间\n设置启动状态\n加载Properties文件\nobtainFreshBeanFactory创建BeanFactory(DefaultListableBeanFactory)\n如果是XML一派的ApplicationContext的话还会在此处加载BeanDefinition\nprepareBeanFactory给BeanFactory做了一些设置和注入\npostProcessBeanFactory允许子类重写改方法对BeanFactory进行后处理，此处为空方法。\ninvokeBeanFactoryPostProcessors调用实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor\n\n调用实现了Ordered接口的BeanDefinitionRegistryPostProcessor\n\n调用普通的BeanDefinitionRegistryPostProcessor\n\n调用实现了PriorityOrdered接口的BeanFactoryPostProcessor\n\n调用实现了Ordered接口的BeanFactoryPostProcessor\n\n调用普通的BeanFactoryPostProcessor\n\nregisterBeanPostProcessors注册实现了PriorityOrdered接口的BeanPostProcessor\n注册实现了Ordered接口的BeanPostProcessor\n注册普通的BeanPostProcessor\n注册MergedBeanDefinitionPostProcessor\ninitMessageSource若BeanFactory中无name为messageSource的Bean，则注册DelegatingMessageSource\ninitApplicationEventMulticaster若BeanFactory中无name为applicationEventMulticaster，则注册SimpleApplicationEventMulticaster\nonRefresh子类可重写改方法，此处为空。\nregisterListeners往applicationEventMulticaster中注册实现了ApplicationEventListener接口的类。\nfinishBeanFactoryInitialization实例化单例对象。\n\n\nfinishRefresh若BeanFactory没有name为lifecycleProcessor的Bean，则注册一个DefaultLifecycleProcessor\n调用lifecycleProcessor的onFresh方法\n发布ContextRefreshedEvent事件\nBean生命周期","thumbnail":"post/Java/Spring/10-Spring之IoC容器初始化与Bean生命周期/cover.png","plink":"https://beginc.github.io/post/Java/Spring/10-Spring之IoC容器初始化与Bean生命周期/"},{"title":"Redis之分布式锁","date":"2020-03-02T09:12:23.000Z","date_formatted":{"ll":"Mar 2, 2020","L":"03/02/2020","MM-DD":"03-02"},"updated":"2020-03-02T10:26:54.031Z","content":"分布式锁场景商品下单以下代码模拟下单过程。\n先获取商品库存数量\n若大于0则下单\n若小于0则失败\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Main &#123;    private static Inventory inventory;    private static LongAdder adder = new LongAdder();    private static CountDownLatch latch;    public static void main(String[] args) throws IOException, InterruptedException &#123;        ExecutorService executor = Executors.newCachedThreadPool();        for (int i = 0; i &lt; 10; i++) &#123;            latch = new CountDownLatch(20);            inventory = new Inventory(10);            adder.reset();            for (int j = 0; j &lt; 20; j++) &#123;                executor.submit(new Runnable() &#123;                    @Override                    public void run() &#123;                        if (inventory.sell())                            adder.increment();                        latch.countDown();                    &#125;                &#125;);            &#125;            latch.await();            System.out.println(\"共卖出了\" + adder.intValue() + \"件商品\");        &#125;        executor.shutdown();    &#125;&#125;class Inventory &#123;    private int stock;    public Inventory(int stock) &#123;        this.stock = stock;    &#125;    public int getStock() &#123;        return stock;    &#125;    public boolean sell() &#123;        if (getStock() &gt; 0) &#123;            stock--;            return true;        &#125;        return false;    &#125;&#125;\n\n可看成发生了超卖。原因就是获取库存和减少库存（下单）不是原子性的。\n\n\n单机环境解决\n在单机环境下我们进行加锁即可解决。\n1234567891011121314151617181920212223242526class Inventory &#123;    private int stock;    private ReentrantLock lock = new ReentrantLock();    public Inventory(int stock) &#123;        this.stock = stock;    &#125;    public int getStock() &#123;        return stock;    &#125;    public boolean sell() &#123;        lock.lock();        try&#123;            if (getStock() &gt; 0) &#123;                stock--;                return true;            &#125;        &#125; finally &#123;            lock.unlock();        &#125;        return false;    &#125;&#125;\n\n\n\n分布式环境\n假如我们处在分布式环境，每个客户端都需要从服务器获取商品数量，判断之后然后下单，此时可能发生如下情况。究其原因还是获取库存数量以及下单操作不具有原子性。但是我们无法再通过简单的加锁实现了，此时我们需要分布式锁。\n\n\nRedis分布式锁在Redis中我们可以使用Redis的SETNX命令来实现分布式锁。\n流程SETNX lock 1加锁\n\n若设置成功（获取锁成功）则进行事务操作\n若设置失败（获取锁失败）则等待\nDEL lock解锁\n\n死锁若一个客户端获取到锁后宕机了，则此时会发生死锁。\n解决策略为lock设置超时时间。\n方案一SETNX lock 1\nEXPIRE lock 10设置超时时间\n\n方案二方案一缺点是SETNX和EXPIRE不具有原子性。\nSET lock 1 EX 10 NX\n\n\n","thumbnail":"post/中间件/Redis/Redis之分布式锁/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis之分布式锁/"},{"title":"Redis之数据删除策略","date":"2020-03-02T08:43:39.000Z","date_formatted":{"ll":"Mar 2, 2020","L":"03/02/2020","MM-DD":"03-02"},"updated":"2020-03-11T09:29:29.699Z","content":"定时删除为key设置一个过期时间，到达时间后马上将该key删除。\n指令\nEXPIRE key seconds\nPEXPIRE key milliseconds\nEXPIREAT key timestamp\nPEXPIREAT key milliseconds-timestamp\nTTL key\nPTTL key\n特点\n节约内存，到期马上删除\nCPU压力大，占用CPU时间\n惰性删除为key设置一个过期时间，到达时间后，下次访问时再将其删除。\n配置\n1lazyfree-lazy-expire yes\n\n特点\nCPU压力小\n会出现长期占用内存的数据\n定期删除每秒执行hz次serverCron()\n每次serverCron()遍历每个数据库执行databasesCron()\n每次databasesCron()对expires表进行循环检查随机挑选W个key进行检查，删除超时的key\n若一轮中删除的key的数量 &gt; W * 25%，则循环该过程\n若一轮中删除的key的数量 &lt;= W * 25%，则检查下一个库的expires\n\n\n\n特点\nCPU性能占用可控\n内存压力不是很大，过期数据被持续清理\n配置\n1hz 10\n\n淘汰策略当内存满时且无过期数据，此时根据淘汰策略来删除一些数据\n检查有时效的数据volatile-lru\nvolatile-lfu\nvolatile-ttl最快要过期的数据\n\nvolatile-random\n检查全库allkeys-lru\nallkeys-lfu\nallkeys-random\n禁止淘汰noenviction（默认策略）\n配置123456# 最大内存占用maxmemory 0# 选取多少数据为待检测数据，不会开启全库扫描maxmemory-samples# 淘汰策略maxmemory-policy\n\n\n\n","thumbnail":"post/中间件/Redis/Redis之数据删除策略/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis之数据删除策略/"},{"title":"Redis之常见解决方案","date":"2020-03-02T07:57:10.000Z","date_formatted":{"ll":"Mar 2, 2020","L":"03/02/2020","MM-DD":"03-02"},"updated":"2020-03-02T10:27:27.330Z","content":"缓存预热启动redis服务器时主动加载一些数据，减缓启动服务器时数据库的压力。\n解决方法\n根据统计结果加载热点数据\n缓存雪崩问题在一个较短的时间内，缓存中较多的key集中过期，导致数据库被请求压垮。\n解决多级缓存 Nginx缓存 + Redis缓存 + Ehcache缓存\n服务限流降级\n使用LRU缓存策略保留热点数据\n过期时间使用固定时间 + 随机值\n热点数据延时\n缓存击穿问题单个热点数据过期的瞬间，大量请求压垮了数据库服务器。\n解决和缓存雪崩类似\n缓存穿透问题用户请求了不存在的数据，导致Redis缓存不命中，流量压往数据库，大量该种请求则可能是黑客攻击。\n解决缓存null结果，设置短过期时间\n白名单策略将数据id使用bitmap存储，不在其中的key请求注解拦截\n\nkey加密将key进行加密，发现不符合规则的key后直接拦截\n\n","thumbnail":"post/中间件/Redis/Redis之常见解决方案/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis之常见解决方案/"},{"title":"Redis之哨兵模式","date":"2020-03-02T07:48:21.000Z","date_formatted":{"ll":"Mar 2, 2020","L":"03/02/2020","MM-DD":"03-02"},"updated":"2020-03-11T09:58:43.838Z","content":"哨兵的作用监控Master存活检测\nSlave存活检测\n\n通知当被监控的主服务器出现问题时，向其他哨兵，客户端发送通知\n\n自动故障转移断开Master与Slave的连接\n投票选取新的Master\n连接Slave到新的Master\n告知客户端新的服务器地址\n\n哨兵搭建配置redis-sentinel.conf\n12345678910# 哨兵服务端口port 26379# 监控的主机地址 端口 超过几个哨兵认为其宕机时认定为真的宕机sentinel monitor master 192.168.31.201 6379 2# 超过多少毫秒无响应时认为其宕机sentinel down-after-milliseconds master 10000# 新的Master进行数据同步时并行的Slave同步数量sentinel parallel-syncs master 1# 超过多长时间同步算超时sentinel failover-timeout master 180000\n\n启动1redis-sentinel redis-sentinal.conf\n\n基于Docker Compose搭建哨兵模式集群配置12345redis-sentinal\\\tsentinal\\\t\tDockerfile\t\tredis-sentinal.conf\tdocker-compose.yml\n\nDockerfile\n用于构建redis-sentinal镜像\n1234FROM redis:5.0.7COPY ./redis-sentinel.conf /usr/local/etc/redis-sentinel.confCMD [ \"redis-sentinel\", \"/usr/local/etc/redis/redis-sentinel.conf\" ]\n\nredis-sentinal.conf\n12345port 26379sentinel monitor master redis-master 6379 2sentinel down-after-milliseconds master 10000sentinel parallel-syncs master 1sentinel failover-timeout master 180000\n\ndocker-compose.yml\n1234567891011121314151617181920212223242526272829303132333435363738version: \"3\"services:  redis-mater:    image: redis:5.0.7    expose:      - 6379    networks:      - redis-cluster    redis-slave:    image: redis:5.0.7    command: redis-server --replicaof redis-master 6379    depends_on:      - redis-mater    expose:      - 6379    links:      - redis-mater:redis-master    networks:      - redis-cluster  redis-sentinel:    build: ./sentinel    image: redis-sentinel    depends_on:      - redis-mater      - redis-slave    expose:      - 26379    links:      - redis-mater:redis-master    networks:      - redis-clusternetworks:  redis-cluster:    driver: bridge\n\n启动启动\n1docker-compose up -d\n\n扩展\n1docker-compose scale redis-slave=3 redis-sentinal=3\n\n","thumbnail":"post/中间件/Redis/Redis之哨兵模式/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis之哨兵模式/"},{"title":"Redis之主从复制","date":"2020-03-01T15:18:37.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-02T10:25:26.336Z","content":"主从复制的作用读写分离\n负载均衡\n故障恢复\n数据备份\n主从复制流程建立连接阶段Slave连接方式一：命令\n1slaveof &lt;masterIP&gt; &lt;masterPort&gt;\n\n方式二：启动参数\n1redis-server --replicaof &lt;masterIP&gt; &lt;masterPort&gt;\n\n方式三：配置\n123replicaof &lt;masterIP&gt; &lt;masterPort&gt;# slave只读replica-read-only yes\n\n认证配置\n1masterauth &lt;password&gt;\n\n数据同步阶段全量复制第一次主从同步时发生的是全量复制\nMaster生成RDB文件发送给Slave\nSlave接收RDB文件，清空数据库，执行RDB数据恢复\n增量复制全量复制时，Master还会建立一个复制积压缓冲区（AOF），记录发送到Master的写指令，在全量复制后\nMaster会将复制积压缓冲区的数据发送给Slave\nSlave收到后会执行bgrewriteaof进行AOF重写，然后增量恢复数据\n\n\n复制积压缓冲区将写指令转换成AOF的格式放入复制缓冲缓冲区\n使用offset来区分不同的Slave当前同步的进度Master需要存Slave的offset\nSlave需要存自己的offset\n双方都存offset是为了在出现网络异常时进行offset同步\n\n当超过复制积压缓冲区大小时，会丢弃队头指令\n\n\n命令传播阶段当Master收到写指令时\n使用命令传播程序将指令分发到所有的Slave\n将写指令存入复制积压缓冲区（备份）\n网络异常\n若短暂超时重连，则此时Slave发过来的offset对应的数据可能还在复制缓冲区中，此时执行部分复制\n若长时间断线后重连，则此时Slave发过来的offset对应的数据可能已经出队，此时执行全量复制\n\n\n\n\n主从复制配置Slave\n配置功能\n\nreplicaof  配置主服务器\n\nreplica-read-only yes从机是否只读\n\nreplica-serve-stale-data yes在复制未完成或者与主机失去连接时是否还提供读服务\nMaster\n配置功能\n\nrepl-backlog-size 1mb复制积压缓冲区大小\n\nmin-replicas-to-write 2当Slave多数掉线，数量小于该值时，Master写功能关闭，拒绝信息同步\n\nmin-replicas-max-lag 8当所有Slave延迟大于8秒时，Master写功能关闭，拒绝信息同步\n","thumbnail":"post/中间件/Redis/Redis之主从复制/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis之主从复制/"},{"title":"Redis之持久化","date":"2020-03-01T14:42:05.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-02T01:39:27.882Z","content":"Redis持久化机制内存快照RDB对内存的数据做一个全盘的持久化备份。\n日志AOF对写操作进行日志记录。\nRDB对内存做快照。\n相关命令save\n执行一次内存快照。\n会阻塞服务器直到快照完成\nbgsave\n后台执行一次内存快照。\n使用Fork生成一个子进程做内存快照\n相关配置\n配置默认功能\n\ndbfilenamedump.rdb本地RDB文件名\n\ndir本地RDB文件目录\n\nrdbcompressionyes是否使用LZF对RDB文件进行压缩\n\nrdbchecksumyes是否对RDB文件进行校验，设置为no可节约10%时间\n\nsave second changes时间范围内发生了changes次改变则进行RDB持久化\n优缺点优点\n存储效率高\n全量备份\n恢复速度快\n缺点\n无法做到实时持久化，会丢失数据\nFork子进程做内存快照，内存消耗大\n全量备份，效率低\n各版本RDB格式不统一\nAOF对写操作做日志记录，恢复时优先级高于RDB。\n\n\n持久化策略always\n每次写操作都马上同步到AOF文件中\neverysec\n每秒将写操作同步到AOF文件中\nno\n系统控制\nAOF重写对AOF文件进行指令分析重写，压缩文件体积。\n已经超时的数据不再写入文件\n忽略无效指令\n同一条数据的多条写指令进行合并\n自动重写bgrewriteaofFork一个子进程重写AOF文件\n\n配置配置项\nauto-aof-rewrite-min-size\nauto-aof-rewrite-percentage\n比对参数\naof_current_size\naof_base_size\n触发条件\naof_current_size &gt; auto-aof-rewrite-min-size\n(aof_current_size - aof_base_size) / aof_base_size &gt;= auto-aof-rewrite-percentage\n相关配置\n配置默认功能\n\nappendonly yes|nono是否开启AOF\n\nappendfsync always|everysec|no持久化策略\n\nappendfilenameappendonly.aofAOF持久化文件名\n\ndir持久化文件目录\n优缺点优点\n存储速度快\n数据安全性相对RDB要高\n资源消耗小（没有Fork子进程）\n缺点\n文件体积大\n恢复速度慢\n","thumbnail":"post/中间件/Redis/Redis之持久化/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis之持久化/"},{"title":"Redis配置文件","date":"2020-03-01T08:33:14.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-02T10:28:14.864Z","content":"\n配置功能\n\ninclude /path/to/other.conf导入配置文件\n\nbind 127.0.0.1绑定哪个接口\n\nport 6379端口\n\ntcp-backlog 511控制TCP连接队列大小\n\ntimeout 0客户端闲置多少秒后断开连接，0为不断开\n\ndaemonize yes是否以守护进程模式运行\n\nloglevel debug|verbose|notice|warning日志级别\n\nlogfile &quot;&quot;日志文件\n\ndatabases 16数据库数量\n\nsave  触发RDB的策略\n\nrdbcompression yes是否开启RDB压缩\n\nrdbchecksum yes是否开启RDB校验\n\ndbfilename dump.rdbRDB文件名\n\ndir ./RDB和AOF存储的路径\n\nreplicaof   设置主服务器\n\nreplica-serve-stale-data yes为no时，当主从复制未结束或连不上主服务器时，从服务器拒绝服务\n\nreplica-read-only yes从服务器是否为只读\n\nrepl-backlog-size 1mb主从复制的复制积压缓存队列大小\n\nmin-replicas-to-write 3与min-replicas-max-lag配合，当至少有min-replicas-to-write个Slave且延迟小于min-replicas-max-lag秒时，主节点才服务，否则拒绝写入和主从同步。\n\nmin-replicas-max-lag 10\n\nrequirepass 123123密码\n\nmaxmemory最大内存使用量\n\nmaxmemory-policy noeviction数据淘汰策略\n\nmaxmemory-samples 5淘汰时间时最多采样五个进行考察\n\nlazyfree-lazy-expire no是否开启惰性删除\n\nappendonly no是否开启AOF\n\nappendfilename &quot;appendonly.aof&quot;AOF文件名称\n\nappendfsync everysecAOF刷盘策略\n\nauto-aof-rewrite-percentage 100AOF重写策略系数\n\nauto-aof-rewrite-min-size 64mbAOF重写策略系数\n","thumbnail":"post/中间件/Redis/Redis配置文件/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis配置文件/"},{"title":"Redis之发布订阅","date":"2020-03-01T08:28:46.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-02T10:28:29.898Z","content":"","thumbnail":"post/中间件/Redis/Redis之发布订阅/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis之发布订阅/"},{"title":"Redis之事务","date":"2020-03-01T08:28:41.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-02T10:25:13.146Z","content":"Redis事务特征原子性：事务内的一组命令会按顺序原子性执行，不会被其他指令插入\n\n执行失败无法回滚\n\nRedis事务命令MULTI\n开启事务，之后的所有命令都会被放入队列缓存。\nEXEC\n执行事务，事务内所有命令被按顺序原子执行。\nDISCARD\n没有EXEC之前，使用DISCARD撤销事务，队列内命令被删除。\nWATCH\n事务开始前，监视某些key，若EXEC时发现key被改变了，则撤销事务。\nUNWATCH\n撤销监视。\n实例\n提交事务\n\n\n放弃事务\n\n\nRedis事务错误处理命令写错\n事务直接被取消。\n\n\n命令执行出错\n其他命令依然会被执行，不会回滚事务。\n","thumbnail":"post/中间件/Redis/Redis之事务/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis之事务/"},{"title":"Redis之HyperLogLog","date":"2020-03-01T08:28:36.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-02T10:25:35.807Z","content":"","thumbnail":"post/中间件/Redis/Redis之HyperLogLog/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis之HyperLogLog/"},{"title":"Redis之List","date":"2020-03-01T08:28:29.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-02T01:39:27.882Z","content":"前言在List的各种命令中\n带L前缀：操作List第一个元素\n带R前缀：操作List最后一个元素\n常用命令阻塞移除并获取表头\nBLPOP key1 [key2] timeouttimeout为超时时间\n\n\n\n阻塞移除并获取表尾\nBRPOP key [key2] timeout\n\n\n阻塞从一个表尾取出放入另一个表头\nBRPOPLPUSH source destination timeout\n\n\n移除并获取表头\nLPOP key1 [key2]\n移除并获取表尾\nRPOP key [key2]\n从一个表尾取出放入另一个表头\nRPOPLPUSH source destination\n通过索引获取列表元素\nLINDEX key index\n\n\n在列表元素前或元素后插入元素\nLINSERT key BEFORE|AFTER pivot valuepivot是值而不是索引\n\n\n\n获取列表长度\nLLEN key\n\n\n列表存在时插入值到头部\nLPUSHX key value\n\n\n列表存在时插入到表尾\nRPUSHX key value\n\n\n\n\n获取列表切片\nLRANGE key start stop闭区间[start, stop]\nstop为-1可取到最后\n\n\n\n移除指定元素\nLREM key count valuecount移除多少个\n\n\n\n通过索引设置元素值\nLSET key index value\n\n\n保留区间内元素\nLTRIM key start stop只保留[start, stop]的元素\n\n\n\n使用场景顺序展示微博粉丝列表按关注顺序展示\n","thumbnail":"post/中间件/Redis/Redis之List/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis之List/"},{"title":"Redis之ZSet","date":"2020-03-01T08:28:11.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-02T01:39:27.882Z","content":"常用命令添加成员\nZADD key score1 member1 [score2 member2] \n查询成员的分数\nZSCORE key member\n\n\n增加成员的分数\nZINCRBY key increment member\n\n\n查询成员数量\nZCARD key\n\n\n查询指定分数区间的成员数量\nZCOUNT key min max\n\n\n从低到高查询指定排行区间内的成员\nZRANGE key start stop [WITHSCORES]WITHSCORES返回分数\n\n\n\n从高到低查询指定排行区间内的成员\nZREVRANGE key start stop [WITHSCORES]WITHSCORES返回分数\n\n\n\n从低到高查询指定分数区内的成员\nZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]LIMIT限制返回数量\n\n\n\n从高到低查询指定分数区内的成员\nZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT]注意是从max到min\n\n\n\n查询指定成员的从低到高的排名\nZRANK key member\n\n\n查询指定成员从高到低的排名\nZREVRANK key member\n\n\n删除成员\nZREM key member [member]\n删除指定排名区间内的成员\nZREMRANGEBYRANK key start stop\n删除给定分数区间的成员\nZREMRANGEBYSCORE key min max\n交集\nZINTERSTORE destination numkeys key [key] [WEIGHTS weight [weight]] [AGGREGATE SUM|MIN|MAX]destination为结果集合\nnumkeys指定参与交集的集合数量\nWEIGHTS指定每个集合的元素权重（聚合之前乘以该权重，默认为1）\nAGGREGATE SUM相同的key其分数求和（默认）\nAGGREGATE MIN相同的key其分数求最小值\nAGGREGATE MIN相同的key其分数求最大值\n\n\n\n并集\nZUNIONSTORE destination numkeys key [key] [WEIGHTS weight [weight]] [AGGREGATE SUM|MIN|MAX]\n应用场景排行榜","thumbnail":"post/中间件/Redis/Redis之ZSet/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis之ZSet/"},{"title":"Redis之Set","date":"2020-03-01T08:28:07.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-02T01:39:27.882Z","content":"常用命令添加成员\nSADD key menber [menber]\n\n\n获取所有成员\nSMEMBERS key\n随机获取多个成员\nSRANDMEMBER key [count]\n\n\n获取并移除一个随机成员\nSPOP key\n\n\n获取成员数\nSCARD key\n\n\n判断是否为集合成员\nSISMEMBER key menber\n\n\n转移集合指定成员\nSMOVE source destination member\n\n\n移除成员\nSREM key member [member]\n\n\n交集\nSINTER key1 [key2]\n\nSINTERSTORE destination key1 [key2]\n\n并集\nSUNION key1 [key2]\nSUNIONSTORE destination key1 [key2]\n差集\nSDIFF key1 [key2]返回key1集合与后面所有集合的差集\n\n\n\nSDIFFSTORE destination key1 [key2]差集的结果存入destination\n\n\n\n应用场景共同好友","thumbnail":"post/中间件/Redis/Redis之Set/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis之Set/"},{"title":"Redis之Hash","date":"2020-03-01T08:28:04.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-02T01:39:27.882Z","content":"常用命令设置单个字段\nHSET key field value\n\n\n获取单个字段\nHGET key field value\n\n\n设置多个字段\nHMSET key field value [key field value]\n\n\n当字段不存在时设置\nHSETNX key field value\n\n\n获取多个字段\nHMGET key field [field]\n\n\n获取所有字段名\nHKEYS key\n\n\n获取所有字段值\nHVALS key\n\n\n获取所有字段名以及值\nHGETALL key\n\n\n获取字段数量\nHLEN key\n\n\n删除字段\nHDEL key field [field]\n\n\n判断字段是否存在\nHEXISTS key field\n\n\n整数增加字段值\nHINCRBY key field increment\n\n\n浮点数增加字段值\nHINCRBYFLOAT key field increment\n\n\n应用场景购物车key：用户id\nfieldKey：商品编号\nfieldVal：商品数量\n","thumbnail":"post/中间件/Redis/Redis之Hash/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis之Hash/"},{"title":"Redis之String","date":"2020-03-01T08:28:00.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-11T08:59:40.695Z","content":"常用命令设置设置单个key\nSET key value\n\n\n获取值的同时设置值\nGETSET key value\n\n\n设置多个key\nMSET key value key value...\n\n\n设置位\nSETBIT key offset value\n\n\n当key不存在时设置\nSETNX key value\n\n\n当所有key都不存在时设置多个key\nMSETNX key value key value\n\n\n\n\n设置位切片\nSETRANGE key offset value\n\n\n追加字符串\nAPPEND key value\n\n\n查询获取单个值\nGET key\n\n\n获取位切片\nGETRANGE key start end闭区间[start, end]\n\n\n\n获取位\nGETBIT key offset把value转换成ASCII码对应的二进制（小端对齐）\n把string当做bitmap使用（把值转换成二进制），获取对应的位\n\n\n\n\n\n设置位\nSETBIT key offset\n逻辑操作位\nBITOP op destination key [key]and\nor\nnot\nxor\n\n位统计\nBITCOUNT key [start end]统计1的位个数\n\n获取字符串长度\nSTRLEN key\n\n\n获取多个值\nMGET key1 key2...\n\n\n算术自增一\nINCR key\n\n\n\n\n增加指定整数\nINCRBY key increment\n\n\n增加指定浮点数\nINCRBYFLOAT key increment\n\n\n自减一\nDECR key\n\n\n自减指定整数\nDECRBY key decrement\n\n\n删除DEL key\n\n\n命名规范表名:主键名:主键值:字段名\n使用场景存储高频访问信息存储微博用户粉丝数目\n1set user:id:35357:fans 10000\n\n分布式锁SETNX\n","thumbnail":"post/中间件/Redis/Redis之String/cover.png","plink":"https://beginc.github.io/post/中间件/Redis/Redis之String/"},{"title":"JVM之内存结构","date":"2020-03-01T01:41:09.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-03T08:15:54.496Z","content":"JVM内存结构\n\n程序计数器是一块较小的内存空间\n记录当前线程的PC\n线程私有\n无OutOfMemoryError\n虚拟机栈线程私有\n每个执行的方法会在栈里分配一个栈帧(Frame)参数\n局部变量表\n返回地址\n\n垃圾回收\n虚拟机栈不涉及垃圾回收，因为方法调用完成后，栈帧就会弹出，回收内存。\n栈内存溢出\n方法调用层数过多（死递归）\n栈帧过大\nVM参数\n-Xss：设置栈大小\n本地方法栈调用Native方法使用的栈。\n堆线程共享\n需要GC\n每个线程都有私有的分配缓冲区(Thread Local Allocation Buffer)，提升对象分配时的效率\nVM参数\n-Xmx：最大堆空间\n方法区存放于类相关的信息\n1.6使用永久代实现\n1.8使用元空间实现\n\n\n\n\n类在C++中使用instanceKlass来描述。\njava_mirror为暴露给Java使用的接口\n\n\nVM参数\n-XX:MaxMetaspaceSize=8m最大元空间大小\n-XX:MaxPermSize=8m最大永久代大小\n运行时常量池常量池就是一张表，虚拟机根据常量池找到要执行的类名，方法名，参数类型，字面常量等信息。class文件被加载进内存时，会将常量池中的符号解析为真实地址，常量池就变成了运行时常量池。\n\n\nStringTableStringTable的引入是为了复用字符串对象，减少内存使用。\n常量池中的字符串仅仅是符号，第一次使用时才变成对象（运行时才创建，延迟加载）。\n第一次使用变成对象时，会将该字符串对象放入StringTable(如果不存在)。\nStringTable就是一个哈希表。\nStringTable位置\n1.6：永久代方法区\n1.8：堆\n字符串常量拼接\n利用编译期优化会将&quot;a&quot; + &quot;b&quot;直接合并成&quot;ab&quot;\n12345public class Main&#123;    public static void main(String[] args)&#123;        String a = \"a\" + \"b\";    &#125;&#125;\n\n\n\n字符串对象拼接\n利用StringBuilder\n1234567public class Main&#123;    public static void main(String[] args)&#123;        String a = \"a\";        String b = \"b\";        String c = a + b;    &#125;&#125;\n\n\n\n手动放入StringTable\nString.intern()\n1.8若该字符串不在串池，则将其放入串池，返回串池中的对象。\n若该字符串在串池，不会放入，返回本身。\n\n1.6若该字符串不在串池，则将其复制一份放入串池，返回串池中的对象。\n若该字符串在串池，不会放入，返回本身。\n\n1234567891011121314public class Main &#123;    public static void main(String[] args) throws IOException &#123;        String s1 = \"ab\";        String s2 = new String(\"a\") + new String(\"b\");        // false        System.out.println(s1 == s2);        String s3 = s2.intern();        // false        System.out.println(s1 == s2);        // true        System.out.println(s1 == s3);    &#125;&#125;\n\nVM参数\n-XX:+PrintStringTableStatistics打印StringTable信息\n\n\n-XX:StringTableSize=200000调整StringTable桶的个数\n直接内存用于NIO，当做数据缓冲区\n\n分配回收成本较高\n\n读写性能高\n\n不受JVM垃圾回收管理\n\nJVM和系统共用直接内存（不是内核缓冲，减少了一次拷贝）\n\n\n\n直接内存回收原理\n\n\n\n\n\n\n\n\n\n\n\n\n","thumbnail":"post/Java/JVM/JVM之内存结构/cover.jpg","plink":"https://beginc.github.io/post/Java/JVM/JVM之内存结构/"},{"title":"JVM之垃圾回收","date":"2020-03-01T01:41:03.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-02T01:41:26.225Z","content":"判断可回收对象引用计数法记录一个对象被引用的次数\n当被引用次数为0时该对象可被回收\n循环引用\n发生循环引用时两个对象都不可被回收。\n\n\n可达性分析法从GC Root对象出发，寻找引用对象链，被GC Root直接或间接引用的对象为不可回收对象。\nGC RootGC Root对象是不可回收的对象。\nSystem Class由启动类加载器加载的类\n\nThread活跃的线程\n\nStack Local局部变量和参数\n\nJNI Local本地方法调用的局部变量和参数\n\nJNI Global全局JNI引用\n\nMonitor Used用于synchronized的对象\n\nHeld By JVM\n系统类加载器\n一些重要的异常类\n\n五种引用\n\n强引用沿着GC Root的引用链能够找到，则不会被回收。\n软引用仅有软引用引用该对象时，在垃圾回收后，若内存仍然不足时会触发垃圾回收，回收软引用引用的对象。\n软引用本身的回收可以配合引用队列。\n12345678public class Main &#123;    public static void main(String[] args) throws IOException &#123;        String s = \"abc\";        ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;&gt;();        SoftReference&lt;String&gt; reference = new SoftReference&lt;&gt;(s, queue);    &#125;&#125;\n\n弱引用仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用引用的对象。\n弱引用本身的回收可以配合引用队列。\n12345678public class Main &#123;    public static void main(String[] args) throws IOException &#123;        String s = \"abc\";        ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;&gt;();        WeakReference&lt;String&gt; reference = new WeakReference&lt;&gt;(s, queue);    &#125;&#125;\n\n虚引用不影响关联对象的垃圾回收\n虚引用必须配合引用队列使用\n当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n12345678public class Main &#123;    public static void main(String[] args) throws IOException &#123;        String s = \"abc\";        ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;&gt;();        PhantomReference&lt;String&gt; reference = new PhantomReference&lt;&gt;(s, queue);    &#125;&#125;\n\n终结器引用当一个对象重写了finalize方法，在类加载的时候JVM会调用Finalizer的register方法将其封装成一个Finalizer对象，并且最终封装到FinalReference对象里面\n\n终结器引用必须配合引用队列使用\n\n在垃圾回收时会将终结器引用入队（此时还没回收对象）\n\nFinalizer线程会通过终结器引用找到引用对象调用其finalize方法\n\n第二次垃圾回收时该对象才会被回收\n\n垃圾回收算法标记清除Mark Sweep步骤\n对可回收对象进行标记\n回收内存\n优点\n速度快\n缺点\n内存碎片\n\n\n标记整理Mark Compact步骤\n标记可回收对象\n回收内存\n紧凑\n优点\n无内存碎片\n缺点\n速度慢\n\n\n复制Copying步骤\n标记FROM中可回收对象\n将存活对象复制到TO\n回收FROM的内存\n交换FROM和TO\n优点\n速度快\n\n无内存碎片\n\n缺点\n需要双倍内存空间\n\n\n分代垃圾回收分代\n新生代伊甸园\n幸存区FROM\nTO\n\n\n老年代\n步骤\n对象首先分配在伊甸园区\n当新生代空间不足时触发Minor GC伊甸园和FROM存活的对象复制到TO中\n存活的对象年龄加1\n交换FROM和TO\nMinor GC会Stop The World\n\n当Minor GC时对象寿命超过阈值晋升至老年代\n最大寿命为15\n\n当老年代空间不足时先尝试触发Minor GC\n若空间仍然不足，则触发Full GC进行全盘垃圾回收，会Stop The World\n\n\n\nVM参数\n\n参数功能\n\n-Xms堆初始大小\n\n-Xmx或-XX:MaxHeapSize=size堆最大大小\n\n-Xmn或-XX:MaxNewSize=size新生代大小\n\n-XX:+UseAdaptiveSizePolicy每次 GC 后会重新计算 Eden、From 和 To 区的大小，计算依据是 GC 过程中统计的 GC 时间、吞吐量、内存占用量。\n\n-XX:InitialSurvivorRatio=ratio + -XX:+UseAdaptiveSizePolicy幸存区占新生代比例（动态大小）\n\n-XX:SurvivorRatio=8(Eden为8/10，FROM和TO各为1/10)幸存区占新生代比例（静态大小）\n\n-XX:MaxTenuringThreshold=threshold晋升阈值\n\n-XX:+PrintTenuringDistribution打印晋升详情\n\n-XX:+PrintGCDetails -verbose:gc打印GC详情\n\n-XX:+ScavengeBeforeFullGCFull GC前进行Minor GC\n垃圾回收器\n\nSerial GC + Serial Old GC特点\n单线程进行垃圾回收\n回收时Stop The World\nSerial GC负责新生代使用复制算法\n\nSerial Old GC负责老年代使用标记整理算法\n\n\n\nVM参数\n-XX:+UseSerialGC新生代Serial GC\n老年代Serial Old GC\n\nParNew GC特点\n简单的将Serial GC多线程化\n其他都和Serial GC相同\n工作在新生代\nVM参数\n-XX:+UseParNewGC新生代ParNew GC\n老年代Serial Old GC\n\nParallel GC + Parallel Old GC特点\n和ParNew差不多相同\n\n关注的是垃圾回收的吞吐量\n\nParallel GC负责新生代\n使用复制算法\n\nParallel Old GC负责老年代\n使用标记整理算法\n\n1.8默认采用\n\n\n\nVM参数\n-XX:+UseParallelGC新生代Parallel GC\n老年代Serial Old GC\n\n-XX:+UseParallelOldGC新生代Parallel GC\n老年代Parallel Old GC\n\n-XX:GCTimeRatio=ratio大于0小于100，最大GC时间占比允许为1 / (1 + ratio)与-XX:UseAdaptiveSizePolicy配合使用\n\n-XX:MaxGCPauseMillis=ms最大GC允许停顿时间与-XX:UseAdaptiveSizePolicy配合使用\n\n-XX:ParallelGCThreads=n并行的线程数\nCMS GC特点\n工作在老年代\n关注响应时间\n步骤\n初始标记标记从GC Roots可直达的老年代对象\n遍历被新生代存活对象所引用的老年代对象(需要扫描新生代)\n\n\n\n并发标记遍历第一个阶段标记的对象，递归遍历老年代，对存活的老年代对象进行标记\n并发标记是和用户线程同时运行的，可能出现以下情况，这些对象对应的Card会被标记为Dirty新生代的对象晋升到了老年代\n直接在老年代分配的对象（大对象）\n老年代对象的引用关系发生变更\n...\n总而言之就是老年代多出了对象\n老年代里引用和被引用关系发生了变化\n\n\n\n\n\n并发预清理\n扫描Dirty对象，进行相应的标记，清除Card标识\n\n可中止的并发预清理\n 发送该阶段的前提\nEden内存使用量超过了CMSScheduleRemarkEdenSizeThreshold\n该阶段循环执行两项任务\n\n扫描FROM和TO区的对象，标记可达的老年代对象\n\n扫描处理Dirty Card中的对象\n中止条件\n\n循环次数达到阈值CMSMaxAbortablePrecleanLoops\n\n执行时间达到阈值CMSMaxAbortablePrecleanTime\n\n新生代Eden区的内存使用量达到了阈值CMSScheduleRemarkEdenPenetration\n\n\n重新标记\n Stop The World进行最后的重新标记\n遍历新生代对象，重新可达的老年代对象\n根据GC Root，标记可达的老年代对象\n遍历老年代的Dirty Card，重新标记\n\n并发清理\n使用标记清除算法回收内存\n\n并发重置\n重新初始化\n\n触发时机周期性GC（Background Collector）\n每隔2秒检查是否满足GC条件\n*未开启-XX:+UseCMSInitiatingOccupancyOnly *\n老年代使用率达到阈值CMSInitiatingOccupancyFraction\n永久代的使用率达到阈值CMSInitiatingPermOccupancyFraction且开启了CMSClassUnloadingEnabled\n新生代的晋升担保失败老年代没有足够的空间来容纳全部的新生代对象或历史平均晋升到老年代的对象\n\n主动GC（Foreground Collector）\n新生代晋升失败\n执行System.gc()\nCMS降级当内存碎片过多，在老年区分配空间也失败后，CMS会退化 为Serial Old。\nFull GC时机当回收垃圾的速度赶不上产生垃圾的速度，并发失败时触发Full GC。\nVM参数\n参数功能\n\n-XX:+UseConcMarkSweepGC新生代为ParNew；老年代为CMS；并发失败时为Serial Old\n\n-XX:ParallelGCThreads并行GC进行内存回收时的线程数量\n\n-XX:ConcGCThreads并发GC时的线程数量\n\n-XX::CMSInitiatingOccupancyFraction老年代内存达到百分之多少时触发GC\n\n-XX:+CMSScavengeBeforeRemark重新标记前是否执行Minor GC\n\n-XX:+CMSInitiatingPermOccupancyFraction永久代达到百分之多少时触发GC\n\n-XX:+CMSPrecleaningEnabled开启并发预清理\n\n-XX:CMSScheduleRemarkEdenSizeThresholdEden内存超过该阈值时执行可中止的并发预清理\n\n-XX:CMSMaxAbortablePrecleanLoops可中止并发预清理阶段循环次数阈值\n\n-XX:CMSMaxAbortablePrecleanTime可中止并发预清理阶段循环时间阈值\nG1 GC特点\n同时注重吞吐量和响应时间\n适合超大堆内存\n将堆划分为多个大小相等的Region\n整体上为标记整理算法，两个区域之间复制使用复制算法\n工作在新生代和老年代\n步骤\n新生代回收(会Stop The World)\n Eden区内存达到一定数量时会触发新生代回收\n\n\n\n​    幸存的复制到幸存区\n\n\n​    当幸存区满后Eden区和幸存区幸存的对象拷贝到另一个幸存区，达到年龄阈值的晋升到老年代\n\n\n新生代垃圾回收 + 并发标记\n在YGC的时候回对GC Root可直达的对象进行初始标记\n\n老年代占用对空间达到阈值InitiatingHeapOccupancyPercent时会进行并发标记(不会STW)\n\n\n\n混合垃圾回收\n会对E,S,O三个区进行全面垃圾回收\n最终标记(Remark)会STW\n拷贝存活(Evacuation)会STW-XX:MaxGCPauseMillis=ms拷贝老年代时根据该参数只挑一部分老年代对象进行回收\n\n\n\n\n\nFull GC时机\n并发标记和混合收集时若回收速度低于产生速度时发生Full GC。\nVM参数\n-XX:+UseG1GC\n-XX:G1HeapRegionSize=size调整堆Region的大小\n参考图解 CMS 垃圾回收机制，你值得拥有\nJava之CMS GC的7个阶段\n垃圾回收算法与 JVM 垃圾回收器综述\n","thumbnail":"post/Java/JVM/JVM之垃圾回收/cover.jpg","plink":"https://beginc.github.io/post/Java/JVM/JVM之垃圾回收/"},{"title":"Docker之DockerCompose","date":"2020-02-29T12:15:46.000Z","date_formatted":{"ll":"Feb 29, 2020","L":"02/29/2020","MM-DD":"02-29"},"updated":"2020-02-29T16:08:44.570Z","content":"","thumbnail":"post/Docker/Docker之DockerCompose/cover.jpg","plink":"https://beginc.github.io/post/Docker/Docker之DockerCompose/"},{"title":"Docker之Dockerfile","date":"2020-02-29T12:15:32.000Z","date_formatted":{"ll":"Feb 29, 2020","L":"02/29/2020","MM-DD":"02-29"},"updated":"2020-02-29T16:08:47.443Z","content":"Dockerfile简介Dockerfile即指定如何一步步构建一个容器，有了Dockerfile我们就可以准确无误的构建一个容器。\nDockerfile命令FROM说明该镜像是基于哪个镜像进行构建。\n1FROM rackspacedot/python37\n\nMAINTAINER指定维护者\n1MAINTAINER rylynn\n\nRUN构建镜像时运行的shell命令。每条RUN命令都会让镜像多一层，所以尽量用/连接多条命令。\nexec格式\n1RUN [\"yum\", \"install\", wget]\n\nshell格式\n1RUN yum install wget\n\nCMD设置启动时默认运行的shell命令。\n可被启动时指定的命令所覆盖\n多个CMD只有最后一个生效\n1CMD echo hello\n\nENTRYPOINT设置启动时运行的shell命令\n不可被启动时指定的命令所覆盖，一定会运行\n\n启动时所指定的命令行参数会传给ENTRYPOINT指定的命令\n\nCMD生效时也会当做参数传递给ENTRYPOINT指定的命令\n\n1ENTRYPOINT echo hello\n\nEXPOSE暴露容器内的端口。\n1EXEPOSE 80 443\n\nENV设置容器内环境变量。\n1ENV env1=1 env2=2\n\nADD拷贝文件到镜像中。\nURL：自动下载\n压缩包：自动解压\n1ADD https://xxx.com/html.tar.gz /var/www/html\n\nCOPY拷贝文件到镜像中，不会自动下载和解压。\n1COPY ./start.sh /start.sh\n\nVOLUME挂载数据卷到容器内。\n1VOLUME[\"/usr/local/rocketmq\", \"/data\"]\n\nUSER指定后续命令的用户和用户组。\n1user root:root\n\nHEALTHCHECK告诉Docker如何测试容器以检查它是否仍在工作，即健康检查。\n参数\n--interval=DURATION (default: 30s)：每隔多长时间探测一次，默认30秒\n-- timeout= DURATION (default: 30s)：服务响应超时时长，默认30秒\n--start-period= DURATION (default: 0s)：服务启动多久后开始探测，默认0秒\n--retries=N (default: 3)：认为检测失败几次为宕机，默认3次\n返回值\n0：容器成功是健康的，随时可以使用\n1：不健康的容器无法正常工作\n2：保留不使用此退出代码\n12HEALTHCHECK --interval=5m --timeout=3s --retries=3 \\    CMD curl -f http:/localhost/ || exit 1\n\nWORKDIR指定工作目录。\n1WORKDIR /data\n\nARG指定构建时的参数，只在build过程中有效。\n--build-arg &lt;参数名&gt;=&lt;值&gt;可覆盖参数\n1ARG arg1=1\n\nONBUILD指定当该镜像被用作FROM的目标时执行的命令。\n1ONBUILD RUN mkdir mydir","thumbnail":"post/Docker/Docker之Dockerfile/cover.jpg","plink":"https://beginc.github.io/post/Docker/Docker之Dockerfile/"},{"title":"Docker之数据持久化","date":"2020-02-29T12:15:25.000Z","date_formatted":{"ll":"Feb 29, 2020","L":"02/29/2020","MM-DD":"02-29"},"updated":"2020-02-29T16:08:39.042Z","content":"Docker数据持久化简介有时候我们需要对容器上的数据做持久化，而不是让数据随着容器的销毁而销毁，如数据库容器，这时候我们就需要使用Docker的数据持久化机制。\nDocker数据卷常用命令查看数据卷\n1docker volume ls\n\n\n\n查看数据卷详细信息\n1docker volume inspect 数据卷id\n\n\n\n删除数据卷\n1docker volume rm 数据卷id\n\n\n\n创建数据卷\n1docker volume create 数据卷名称\n\n\n\n绑定数据卷-v：绑定数据卷\n1docker run -v volume名称:容器内目录 镜像名\n\n使用docker volume inspect查看到数据卷绑定到本机的目录\nMountpoint\n\n\nDocker Bind Mount即直接绑定数据卷，这种方式不具有移植性。\n1docker run -v 宿主机目录:容器内目录 镜像名","thumbnail":"post/Docker/Docker之数据持久化/cover.jpg","plink":"https://beginc.github.io/post/Docker/Docker之数据持久化/"},{"title":"Docker之网络","date":"2020-02-29T12:14:49.000Z","date_formatted":{"ll":"Feb 29, 2020","L":"02/29/2020","MM-DD":"02-29"},"updated":"2020-02-29T16:08:42.030Z","content":"Linux Network Namespace在Docker中，容器之间以及容器和宿主之间的网络环境可进行隔离，实现的技术是Linux Network Namespace，即每个容器都有自己独立的Namespace。\n宿主Namespace\n\n\n容器Namespace\n\n\nVeth不同的Network Namespace之前要通信的话可以通过Linux提供的一种虚拟网络设备Veth来进行连接，Veth总是成对出现\n输入端\n输出端\n\n\n网桥网桥是工作在链路层的一种网络设备，它根据mac地址将帧转发到不同的出口，它可以隔离冲突域，连接不同的网段。\n\n\nDocker0装好Docker后，宿主机上会有一个虚拟的网桥Docker0。\n\n\n默认情况下各个容器都会通过Veth连接到Docker0，因此不同容器之间，以及容器和宿主机之间都是可以通信的。\n\n\n\n\nDocker网络类型Bridge就是使用网桥以及Veth来连接不同的container。\nHost容器和宿主机共享Network Namespace。\nNone容器内无网络接口，为孤立的Network Namespace。\nContainer容器和另外一个容器共享Network Namespace。\nDocker网络常用命令查看网络\n1docker network ls\n\n\n\n查看网络详细信息\n1docker network inspect 网络名称\n\n\n\n创建网络\n-d：指定网络类型\n1docker network create -d 网络类型 网络名称\n\n\n\n删除网络\n1docker network rm 网络名称\n\n\n\n连接网络\n让容器连接到指定网络\n启动时手动指定\n1docker run --network mybridge -d redis:5.0.7\n\n加入网络\n1docker network connect bridge 6ccee\n\n断开网络\n1docker network disconnect bridge 6ccee\n\n","thumbnail":"post/Docker/Docker之网络/cover.jpg","plink":"https://beginc.github.io/post/Docker/Docker之网络/"},{"title":"Docker之镜像","date":"2020-02-29T12:14:28.000Z","date_formatted":{"ll":"Feb 29, 2020","L":"02/29/2020","MM-DD":"02-29"},"updated":"2020-02-29T16:07:50.751Z","content":"Docker镜像简介Docker中的镜像与容器就像是类和对象的关系。一个镜像由以下要素来标识\nRepository\nTag\nDocker镜像常用操作列出镜像\n1docker images\n\n\n\n拉取镜像\n1docker pull redis:5.0.7\n\n\n\n查找镜像\n1docker search redis\n\n\n\n删除镜像\n1docker rmi redis:5.0.7\n\n\n\n构建镜像\n-t ：指定要创建的目标镜像名\n1docker build -t myimage:1.0 ./Dockerfile\n\n设置镜像标签\n1docker tag imageId repository:tag","thumbnail":"post/Docker/Docker之镜像/cover.jpg","plink":"https://beginc.github.io/post/Docker/Docker之镜像/"},{"title":"Docker之容器","date":"2020-02-29T12:14:17.000Z","date_formatted":{"ll":"Feb 29, 2020","L":"02/29/2020","MM-DD":"02-29"},"updated":"2020-02-29T16:08:36.274Z","content":"Docker容器常用命令创建启动容器\n-i：以交互模式运行\n-t：终端\n-d：后台运行\n-P：容器内部端口随机映射到主机的高端口。\n-p：宿主机端口:容器内端口\n--name：容器名称\n1docker run -it --name redis:5.0.7\n\n\n\n查看容器\n-a：显示所有容器（包括未运行的）\n1docker ps -a\n\n\n\n启动容器\n容器id不用填满\n1docker start 容器id\n\n\n\n停止容器\n1docker stop 容器id\n\n\n\n进入容器\n命令同docker run\ndocker exec退出终端容器不会停止\n\ndocket attach退出终端容器会停止\n\n1docker exec -ti redis(容器名) /bin/bash\n\n\n\n删除容器\n1docker rm 容器id\n\n\n\n清理容器\n删除所有终止运行的容器\n1docker container prune\n\n查看容器网络端口\n容器端口/协议 -&gt; IP:端口\n1docker port 容器名\n\n\n\n查看容器日志\n可查看容器内部的标准输出\n-f：持续跟踪最新日志\n1docker logs -f 容器id\n\n查看容器所有信息\n1docker inspect 容器id","thumbnail":"post/Docker/Docker之容器/cover.jpg","plink":"https://beginc.github.io/post/Docker/Docker之容器/"},{"title":"9-Spring之扩展","date":"2020-02-29T09:12:50.000Z","date_formatted":{"ll":"Feb 29, 2020","L":"02/29/2020","MM-DD":"02-29"},"updated":"2020-03-06T08:39:11.605Z","content":"BeanFactoryPostProcessor接口BeanFactoryPostProcessor\n123456public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;            &#125;&#125;\n\n调用时机所有BeanDefinition已经加载完毕，但是还未开始创建Bean。\n作用我们可以通过BeanFactory获取BeanDefinition，在其初始化之前对BeanDefinition进行修改。\n1beanFactory.getBeanDefinition(\"bean\");\n\n应用TODO\nBeanDefinitionRegistryPostProcessor接口BeanDefinitionRegistryPostProcessor接口继承自BeanFactoryPostProcessor。\n1234567891011public class MyBeanDefinitionRegistrarPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;    @Override    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;    &#125;    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;    &#125;&#125;\n\n调用时机postProcessBeanFactory就是BeanFactoryPostProcessor调用的时机。\n\npostProcessBeanDefinitionRegistry在所有BeanDefinition即将被加载前调用。\n\n作用可以在使用BeanDefinitionRegistry向容器中注册BeanDefinition，从而来添加组件。\n1registry.registerBeanDefinition();\n\n应用在mybatis-spring整合包中，我们通常会配置MapperScannerConfigurer来扫描mapper包，做动态代理开发。\n123 &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;     &lt;property name=\"basePackage\" value=\"cn.edu.njust.dao\"&gt;&lt;/property&gt;&lt;/bean&gt;\n\n之所以我们不用手动调用sqlSession.getMapper来手动获取mapper，而是直接使用Spring来获取mapper接口的，有两个原因\nMapperFactoryBean\n整合包中实现了这个FactoryBean，用来为我们生成代理。本质上就是sqlSession.getMapper\n1234@Overridepublic T getObject() throws Exception &#123;    return getSqlSession().getMapper(this.mapperInterface);&#125;\n\nMapperScannerConfigurer\n这个类实现了BeanDefinitionRegistryPostProcessor接口，在postProcessBeanDefinitionRegistry方法中使用了ClassPathMapperScanner的scan方法进行扫描。\n12345678910111213141516171819202122232425262728@Overridepublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;    if (this.processPropertyPlaceHolders) &#123;        processPropertyPlaceHolders();    &#125;    // *********************************************************************    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);    // *********************************************************************    scanner.setAddToConfig(this.addToConfig);    scanner.setAnnotationClass(this.annotationClass);    scanner.setMarkerInterface(this.markerInterface);    scanner.setSqlSessionFactory(this.sqlSessionFactory);    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);    scanner.setResourceLoader(this.applicationContext);    scanner.setBeanNameGenerator(this.nameGenerator);    scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);    if (StringUtils.hasText(lazyInitialization)) &#123;        scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));    &#125;    scanner.registerFilters();    // *********************************************************************    scanner.scan(        StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));    // *********************************************************************&#125;\n\nscan调用了doScan，它先调用了父类的doScan扫描并注册了mapper接口的BeanDefinition，然后在processBeanDefinitions里修改了BeanDefinition的BeanClass，将其设置为MapperFactoryBean，这使得我们使用Spring获取接口时，实际上是调用了MapperFactoryBean的getObject方法，生成了动态代理。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Overridepublic Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;    // *********************************************************************    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages);    // *********************************************************************    if (beanDefinitions.isEmpty()) &#123;        LOGGER.warn(() -&gt; \"No MyBatis mapper was found in '\" + Arrays.toString(basePackages)                    + \"' package. Please check your configuration.\");    &#125; else &#123;    // *********************************************************************        processBeanDefinitions(beanDefinitions);    // *********************************************************************    &#125;    return beanDefinitions;&#125;private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123;    GenericBeanDefinition definition;    for (BeanDefinitionHolder holder : beanDefinitions) &#123;        definition = (GenericBeanDefinition) holder.getBeanDefinition();        String beanClassName = definition.getBeanClassName();        LOGGER.debug(() -&gt; \"Creating MapperFactoryBean with name '\" + holder.getBeanName() + \"' and '\" + beanClassName                     + \"' mapperInterface\");        // the mapper interface is the original class of the bean        // but, the actual class of the bean is MapperFactoryBean        definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // issue #59    // *********************************************************************        definition.setBeanClass(this.mapperFactoryBeanClass);        definition.getPropertyValues().add(\"addToConfig\", this.addToConfig);        boolean explicitFactoryUsed = false;        if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123;            definition.getPropertyValues().add(\"sqlSessionFactory\",                                               new RuntimeBeanReference(this.sqlSessionFactoryBeanName));            explicitFactoryUsed = true;        &#125; else if (this.sqlSessionFactory != null) &#123;            definition.getPropertyValues().add(\"sqlSessionFactory\", this.sqlSessionFactory);            explicitFactoryUsed = true;        &#125;        if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123;            if (explicitFactoryUsed) &#123;                LOGGER.warn(                    () -&gt; \"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.\");            &#125;            definition.getPropertyValues().add(\"sqlSessionTemplate\",                                               new RuntimeBeanReference(this.sqlSessionTemplateBeanName));            explicitFactoryUsed = true;        &#125; else if (this.sqlSessionTemplate != null) &#123;            if (explicitFactoryUsed) &#123;                LOGGER.warn(                    () -&gt; \"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.\");            &#125;            definition.getPropertyValues().add(\"sqlSessionTemplate\", this.sqlSessionTemplate);            explicitFactoryUsed = true;        &#125;        if (!explicitFactoryUsed) &#123;            LOGGER.debug(() -&gt; \"Enabling autowire by type for MapperFactoryBean with name '\" + holder.getBeanName() + \"'.\");            definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);        &#125;        definition.setLazyInit(lazyInitialization);    &#125;&#125;\n\nBeanPostProcessor接口BeanPostProcessor\n12345678910public class MyBeanPostProcessor implements BeanPostProcessor &#123;    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;        return bean;    &#125;    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;        return bean;    &#125;&#125;\n\n调用时机postProcessBeforeInitialization在Bean调用任何初始化方法之前\npostProcessAfterInitialization在Bean调用初始化方法之后\n作用对Bean进行修改\n生成Bean的代理对象返回\n应用AOP使用BeanPostProcessor生成代理Bean。\nInstantiationAwareBeanPostProcessorApplicationListenerMethodInvokingBean","thumbnail":"post/Java/Spring/9-Spring之扩展/cover.png","plink":"https://beginc.github.io/post/Java/Spring/9-Spring之扩展/"},{"title":"8-Spring之纯注解开发","date":"2020-02-29T05:42:38.000Z","date_formatted":{"ll":"Feb 29, 2020","L":"02/29/2020","MM-DD":"02-29"},"updated":"2020-03-06T14:08:56.240Z","content":"纯注解开发简介在Spring中我们进行配置的方式有如下三种：\nXML配置\nXML配置 + 注解\n注解类\n注解类@Configuration加上了该注解的类即为注解类，在该类中我们可以进行组件的注册以及各种功能的启动配置（AOP，事务，MVC等）。\n1234@Configurationpublic class Config &#123;    &#125;\n\nBean注册@Bean注册普通Bean加在注解类的方法上，将方法返回的对象注册到IoC容器中。\n默认name\n默认name为方法名\n12345678@Configurationpublic class BeanRegisterConfig &#123;    @Bean    public Person person()&#123;        return new Person();    &#125;&#125;\n\n指定name\n12345678@Configurationpublic class BeanRegisterConfig &#123;    @Bean(\"lhw\")    public Person person() &#123;        return new Person();    &#125;&#125;\n\n注册FactoryBeanFactoryBean是实现了接口FactoryBean的特殊Bean，它是一个用于产生Bean的工厂Bean。\n编写实现FactoryBean接口的类\ngetObject()返回要注册的Bean\ngetObjectType()返回要注册的Bean的类型\nisSingleton()是否为单例\n12345678910111213141516public class MyFactoryBean implements FactoryBean&lt;Dog&gt; &#123;    @Override    public Dog getObject() throws Exception &#123;        return new Dog();    &#125;    @Override    public Class&lt;?&gt; getObjectType() &#123;        return Dog.class;    &#125;    @Override    public boolean isSingleton() &#123;        return false;    &#125;&#125;\n\n注册FactoryBean\n12345678@Configurationpublic class BeanRegisterConfig &#123;    @Bean    public MyFactoryBean dog()&#123;        return new MyFactoryBean();    &#125;&#125;\n\n获取FactoryBean产生的Bean\n12// 返回Dogcontext.getBean(\"dog\");\n\n获取FactoryBean\n加上&amp;则会返回FactoryBean本身。\n12// 返回MyFactoryBeancontext.getBean(\"&amp;dog\");\n\n@ComponentScan用于开启包扫描。该注解可重复添加。\n指定包名123456@ComponentScan(basePackages = \"bean\")@ComponentScan(basePackages = \"controller\")@Configurationpublic class BeanRegisterConfig &#123;&#125;\n\n指定过滤器@Filtertype\nFilterType.ANNOTATION过滤指定注解\n\nFilterType.ASSIGNABLE_TYPE过滤指定类\n\nFilterType.ASPECTJ使用AspectJ表达式过滤\n\nFilterType.REGEX使用正则表达式过滤\n\nFilterType.CUSTOM使用自定义过滤器过滤\n\nclasses\n指定类\nincludeFilters指定要注册的类的过滤器。需要配合useDefaultFilters=false来使用。\n12345678// 只注册有@Service注解的类@ComponentScan(basePackages = \"bean\", includeFilters = &#123;        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Service.class&#125;)&#125;, useDefaultFilters = false)@Configurationpublic class BeanRegisterConfig &#123;&#125;\n\nexcludeFilters指定不注册的类。\n12345678// 不注册@Component注解的类@ComponentScan(basePackages = \"bean\", excludeFilters = &#123;        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Component.class&#125;)&#125;)@Configurationpublic class BeanRegisterConfig &#123;&#125;\n\n@ComponentScans指定多个@ComponentScan。\n12345678@ComponentScans(&#123;        @ComponentScan(\"bean\"),        @ComponentScan(\"controller\")&#125;)@Configurationpublic class BeanRegisterConfig &#123;&#125;\n\n@Component加在类上，用于包扫描注册该类。\n默认name\n默认name为类名，其中第一个字母小写。\n1234@Componentpublic class Bean &#123;    &#125;\n\n指定name\n1234@Component(\"myBean\")public class Bean &#123;    &#125;\n\n@Controller功能同@Component，语义上用来包扫描注册Controller。\n@Service功能同@Component，语义上用来包扫描注册Service。\n@Repository功能同@Component，语义上用来包扫描注册DAO。\n@Import用来给容器中导入组件。Bean的name为类的全名（包名 + 类名）。\n导入普通Bean12345@Import(Dog.class)@Configurationpublic class BeanRegisterConfig &#123;&#125;\n\n导入ImportSelector编写实现ImportSelector接口的类\n参数AnnotationMetaData可以获取注解类的各种元信息。\n注解类上的注解信息\n注解类的方法信息\n返回值为String数组，可指定要注册的组件的类名。\n12345678910111213141516171819public class MyImportSelector implements ImportSelector &#123;    @Override    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;        // 获取注解类中加了指定注解的方法的元信息        Set&lt;MethodMetadata&gt; annotatedMethods = importingClassMetadata.getAnnotatedMethods(\"org.springframework.context.annotation.Bean\");        for (MethodMetadata annotatedMethod : annotatedMethods) &#123;            System.out.println(annotatedMethod.getMethodName());        &#125;        // 获取注解类的注解元信息        Set&lt;String&gt; annotationTypes = importingClassMetadata.getAnnotationTypes();        for (String annotationType : annotationTypes) &#123;            System.out.println(annotationType);        &#125;        return new String[]&#123;                \"bean.Dog\"        &#125;;    &#125;&#125;\n\n导入ImportSelector\n123456789@Import(MyImportSelector.class)@Configurationpublic class BeanRegisterConfig &#123;    @Bean    public Person person()&#123;        return new Person();    &#125;&#125;\n\n导入ImportBeanDefinitionRegistrar编写ImportBeanDefinitionRegistrar实现类\nAnnotationMetadata可用来获取注解类的元信息\nBeanDefinitionRegistry可用来获取BeanDefinition信息\n注册BeanDefinition\n\n123456789101112public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;        // 获取BeanDefinitionRegistry中的BeanDefinition信息        String[] beanDefinitionNames = registry.getBeanDefinitionNames();        for (String beanDefinitionName : beanDefinitionNames) &#123;            System.out.println(beanDefinitionName);        &#125;        // 注册BeanDefinition        RootBeanDefinition beanDefinition = new RootBeanDefinition(Fish.class);        registry.registerBeanDefinition(\"fish\", beanDefinition);    &#125;&#125;\n\n导入ImportBeanDefinitionRegistrar\n123456789@Import(MyImportBeanDefinitionRegistrar.class)@Configurationpublic class BeanRegisterConfig &#123;    @Bean    public Person person()&#123;        return new Person();    &#125;&#125;\n\n导入配置类有时候我们希望把不同方面的配置放在不同的配置类中，最终通过一个汇总的配置类进行集中，此时可使用@Import导入其他配置类。\n12345678@Configurationpublic class OtherConfig &#123;    @Bean    public Fish fish()&#123;        return new Fish();    &#125;&#125;\n\n123456789@Import(OtherConfig.class)@Configurationpublic class BeanRegisterConfig &#123;    @Bean(\"lhw\")    public Person person() &#123;        return new Person();    &#125;&#125;\n\nBean条件注册@Conditional加在方法上可指定在什么条件下Bean被注册。\n编写实现Condition接口的类\n123456789101112131415161718192021public class MyCondition implements Condition &#123;    @Override    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;        // 获取BeanFactory        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();        // 获取ClassLoader        ClassLoader classLoader = context.getClassLoader();        // 获取环境信息        // - 环境变量        // - 加载的配置文件信息        Environment environment = context.getEnvironment();        // 获取BeanDefinitiionRegistry        BeanDefinitionRegistry registry = context.getRegistry();        // 获取ResourceLoader        ResourceLoader resourceLoader = context.getResourceLoader();        // 若环境变量有dog则返回true        String property = environment.getProperty(\"dog\");        return property != null;    &#125;&#125;\n\n在@Bean注解的方法上添加@Conditional注解\n123456789@Configurationpublic class BeanRegisterConfig &#123;    @Conditional(MyCondition.class)    @Bean    public Dog dog()&#123;        return new Dog();    &#125;&#125;\n\n加在注解类上当满足条件时这个配置类才会生效。\n123456789@Conditional(MyCondition.class)@Configurationpublic class BeanRegisterConfig &#123;    @Bean    public Dog dog()&#123;        return new Dog();    &#125;&#125;\n\n@Profile该注解一般用于在不同的生产环境下生效不同的配置。\n注解加在方法上\n只有当spring.profiles.active与其匹配时才注册该Bean。\n123456789@Configurationpublic class BeanRegisterConfig &#123;    @Profile(\"dev\")    @Bean    public Dog dog() &#123;        return new Dog();    &#125;&#125;\n\n加在注解类上\n只有当spring.profiles.active与其匹配时该配置类才生效。\n123456789@Profile(\"dev\")@Configurationpublic class BeanRegisterConfig &#123;        @Bean    public Dog dog() &#123;        return new Dog();    &#125;&#125;\n\n激活环境使用虚拟机参数\n在虚拟机参数上添加\n1-Dspring.profiles.active=dev\n\n编程指定\n先设置activeProfiles再刷新容器。\n1234AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();context.getEnvironment().setActiveProfiles(\"dev\");context.register(BeanRegisterConfig.class);context.refresh();\n\nBean生命周期@Scope@LazyBean生命周期方法初始化之前初始化之前指Bean已经被创建，注入过依赖，但是还没有调用任何其他初始化方法之前（init-method, afterPropertiesSet）。\nBeanPostProcessor参数为bean对象和它的name，返回值可以直接返回原来的Bean对象，也可以返回包装过后的Bean对象。\npostProcessBeforeInitializatio\n编写实现BeanPostProcessor的类\n注意，所有的Bean都会经过该后处理器，所以我们需要进行判断。\n123456789101112public class MyBeanPostProcessor implements BeanPostProcessor &#123;    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;        if(beanName.equals(\"person\"))&#123;            System.out.println(\"Before Init Person.........\" + bean.toString());        &#125;        return bean;    &#125;    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;        return bean;    &#125;&#125;\n\n注册BeanPostProcessor\n12345678910111213@Configurationpublic class BeanLifecycleConfig &#123;    @Bean    public Person person()&#123;        return new Person();    &#125;    @Bean    public BeanPostProcessor personPostProcessor()&#123;        return new MyBeanPostProcessor();    &#125;&#125;\n\n初始化初始化指Bean已经被创建，注入过依赖，调用过后置处理器的postProcessBeforeInitialization方法之后。\n@BeaninitMethod\n1234567891011121314151617@Componentpublic class Person &#123;    private String name;    private Integer age;    public Person() &#123;    &#125;    public Person(String name, Integer age) &#123;        this.name = name;        this.age = age;    &#125;    public void init()&#123;        System.out.println(\"Init Person.........\" + toString());    &#125;&#125;\n\n12345678@Configurationpublic class BeanLifecycleConfig &#123;    @Bean(initMethod = \"init\")    public Person person()&#123;        return new Person();    &#125;&#125;\n\nInitializaingBean接口让Bean实现该接口，重写afterPropertiesSet方法。\nafterPropertiesSet\n123456789101112131415161718@Componentpublic class Person implements InitializingBean &#123;    private String name;    private Integer age;    public Person() &#123;    &#125;    public Person(String name, Integer age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public void afterPropertiesSet() throws Exception &#123;        System.out.println(\"Init Person.........\" + toString());    &#125;&#125;\n\n@PostConstruct标注在方法上指明是初始化方法。\n1234567891011121314151617@Componentpublic class Person &#123;    private String name;    private Integer age;    public Person() &#123;    &#125;    public Person(String name, Integer age) &#123;        this.name = name;        this.age = age;    &#125;\t@PostConstruct    public void init()&#123;        System.out.println(\"Init Person.........\" + toString());    &#125;&#125;\n\n初始化之后BeanPostProcessor参数为bean对象和它的name，返回值可以直接返回原来的Bean对象，也可以返回包装过后的Bean对象。\npostProcessAfterInitialization\n编写实现BeanPostProcessor的类\n123456789101112131415public class MyBeanPostProcessor implements BeanPostProcessor &#123;    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;        if(beanName.equals(\"person\"))&#123;            System.out.println(\"Before Init Person.........\" + bean.toString());        &#125;        return bean;    &#125;    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;        if(beanName.equals(\"person\"))&#123;            System.out.println(\"After Init Person.........\" + bean.toString());        &#125;        return bean;    &#125;&#125;\n\n注册BeanPostProcessor\n12345678910111213@Configurationpublic class BeanLifecycleConfig &#123;    @Bean    public Person person()&#123;        return new Person();    &#125;    @Bean    public BeanPostProcessor personPostProcessor()&#123;        return new MyBeanPostProcessor();    &#125;&#125;\n\n销毁之前初始化之后指Bean已经被创建，注入过依赖，调用过初始化方法(init-method, afterPropertiesSet)之后。\n@BeandestroyMethod\n1234567891011121314151617@Componentpublic class Person&#123;    private String name;    private Integer age;    public Person() &#123;    &#125;    public Person(String name, Integer age) &#123;        this.name = name;        this.age = age;    &#125;    public void destroy()&#123;        System.out.println(\"Destroy Person.........\" + toString());    &#125;&#125;\n\n12345678@Configurationpublic class BeanLifecycleConfig &#123;    @Bean(destroyMethod = \"destroy\")    public Person person()&#123;        return new Person();    &#125;&#125;\n\nDisposalBean接口让Bean实现DisposalBean接口，重写destroy方法。\n1234567891011121314151617@Componentpublic class Person implements DisposableBean &#123;    private String name;    private Integer age;    public Person() &#123;    &#125;    public Person(String name, Integer age) &#123;        this.name = name;        this.age = age;    &#125;    public void destroy()&#123;        System.out.println(\"Destroy Person.........\" + toString());    &#125;&#125;\n\n@PreDestroy标注在方法上指明是销毁方法。\n1234567891011121314151617@Componentpublic class Person&#123;    private String name;    private Integer age;    public Person() &#123;    &#125;    public Person(String name, Integer age) &#123;        this.name = name;        this.age = age;    &#125;\t@PreDestroy    public void destroy()&#123;        System.out.println(\"Destroy Person.........\" + toString());    &#125;&#125;\n\nBean依赖注入@Value用来注入基本类型。\n直接注入123456789101112@Componentpublic class Fish &#123;    @Value(\"清江鱼\")    private String category;    public Fish(String category) &#123;        this.category = category;    &#125;    public Fish() &#123;    &#125;&#125;\n\nSpEL注入使用#{}。\n123456789101112@Componentpublic class Fish &#123;    @Value(\"#&#123;'清江' + '鱼'&#125;\")    private String category;    public Fish(String category) &#123;        this.category = category;    &#125;    public Fish() &#123;    &#125;&#125;\n\n配置文件注入使用${}注入配置文件中的内容。\n123456789101112@Componentpublic class Fish &#123;    @Value(\"$&#123;fish.category&#125;\")    private String category;    public Fish(String category) &#123;        this.category = category;    &#125;    public Fish() &#123;    &#125;&#125;\n\n@Autowired自动按类型注入。\n只有一个匹配时，无歧义\n有多个匹配时，使用变量名作为name进行注入\n可使用required来指定是否必须注入。\n1234567891011121314@Componentpublic class Fish &#123;    private String category;    @Autowired(required=false)    private ApplicationContext context;    public Fish(String category) &#123;        this.category = category;    &#125;    public Fish() &#123;    &#125;&#125;\n\n@Primary加在注解类的@Bean的方法上，用于指定当容器中有多个相同类型的Bean时，@Autowired优先注入哪个Bean。\n12345678910111213141516171819@Configurationpublic class BeanDIConfig &#123;    @Bean    public Fish fish()&#123;        return new Fish();    &#125;\t// 优先注入    @Primary    @Bean    public Dog dog()&#123;        return new Dog();    &#125;        @Bean    public Dog dog1()&#123;        return new Dog();    &#125;&#125;\n\n@Qualifier与@Autowired组合使用先按类型注入，再按name注入。\n123456789101112131415@Componentpublic class Fish &#123;    private String category;    @Qualifier(\"dog\")    @Autowired    private Dog dog;    public Fish(String category) &#123;        this.category = category;    &#125;    public Fish() &#123;    &#125;&#125;\n\n加载配置类方法的参数上指定传入的参数在容器中的name。\n1234567891011121314@Configurationpublic class BeanDIConfig &#123;    @Bean    public Fish fish(@Qualifier(\"dog\") Dog dog)&#123;        System.out.println(dog);        return new Fish();    &#125;    @Bean    public Dog dog()&#123;        return new Dog();    &#125;&#125;\n\n@Resource指定name: 效果同@Autowired加@Qualifier。\n不指定name: 效果同@Autowired，但是无@Primary支持\n1234567891011121314@Componentpublic class Fish &#123;    private String category;    @Resource(name=\"dog\")    private Dog dog;    public Fish(String category) &#123;        this.category = category;    &#125;    public Fish() &#123;    &#125;&#125;\n\n@InjectTODO\nXXXAware接口Bean实现该接口，提供setXXX方法，可以注入Spring底层的一些组件。\nApplicationContextAware\nBeanFactoryAware\nBeanNameAware\nEmbeddedStringResolverAware\nEnvironmentAware\nResourceLoaderAware\n123456789101112131415161718@Componentpublic class Fish implements BeanFactoryAware &#123;    private String category;    private BeanFactory beanFactory;    public Fish(String category) &#123;        this.category = category;    &#125;    public Fish() &#123;    &#125;    @Override    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;        this.beanFactory = beanFactory;    &#125;&#125;\n\n@PropertySource引入properties配置文件。\n123456789@PropertySource(\"classpath:fish.properties\")@Configurationpublic class BeanDIConfig &#123;    @Bean    public Fish fish()&#123;        return new Fish();    &#125;&#125;\n\n@PropertySources引入多个properties配置文件。\n1234567891011@PropertySources(&#123;        @PropertySource(\"classpath:fish.properties\")&#125;)@Configurationpublic class BeanDIConfig &#123;    @Bean    public Fish fish()&#123;        return new Fish();    &#125;&#125;\n\nAOP见7-Spring之XML配置加注解开发。\n@EnableAspectJAutoProxy需要在配置类上加上该注解才能开启AOP注解功能。\n12345@Configuration@EnableAspectJAutoProxypublic class Config &#123;&#125;\n\n事务管理见7-Spring之XML配置加注解开发。\n配置事务管理器使用配置类注册事务管理器。\n123456789101112131415161718192021222324252627282930313233343536@Configuration@PropertySources(        @PropertySource(\"classpath:jdbc.properties\"))public class JdbcConfig &#123;    @Value(\"$&#123;jdbc.driver&#125;\")    private String driverClassName;    @Value(\"$&#123;jdbc.url&#125;\")    private String url;    @Value(\"$&#123;jdbc.username&#125;\")    private String username;    @Value(\"$&#123;jdbc.password&#125;\")    private String password;    @Bean(\"dataSource\")    public DataSource dataSource() &#123;        DriverManagerDataSource dataSource = new DriverManagerDataSource();        dataSource.setDriverClassName(\"\");        dataSource.setUrl(\"\");        dataSource.setUsername(\"\");        dataSource.setPassword(\"\");        return dataSource;    &#125;    @Bean(\"jdbcTemplate\")    public JdbcTemplate jdbcTemplate(@Qualifier(\"dataSource\") DataSource dataSource) &#123;        return new JdbcTemplate(dataSource);    &#125;    @Bean(\"transactionManager\")    public PlatformTransactionManager transactionManager(@Qualifier(\"dataSource\") DataSource dataSource) &#123;        return new DataSourceTransactionManager(dataSource);    &#125;&#125;\n\n@EnableTransactionManagement在配置类上加上该注解才能开启事务管理注解功能。\n123456@Configuration@EnableTransactionManagementpublic class Config &#123;&#125;\n\nSpringMVC初始化继承自AbstractAnnotationConfigDispatcherServletInitializer，会调用该类进行IoC父子容器的初始化以及SpringMVC的配置。\ngetRootConfigClasses为父容器的配置类\ngetServletConfigClasses为SpringMVC子容器的配置类\ngetServletMappings为DispatcherServlet的映射路径\n12345678910111213141516public class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;        return new Class[]&#123;Config.class&#125;;    &#125;    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;        return new Class[]&#123;MVCConfig.class&#125;;    &#125;    @Override    protected String[] getServletMappings() &#123;        return new String[]&#123;\"/\"&#125;;    &#125;&#125;\nSpringMVC子容器只扫描Controller\n123456@Configuration@ComponentScan(value = \"controller\", includeFilters = &#123;        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Controller.class),&#125;)public class MVCConfig &#123;&#125;\n父容器不扫描Controller\n123456@Configuration@ComponentScan(value = \"*\", excludeFilters = &#123;        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Controller.class)&#125;, useDefaultFilters = false)public class Config &#123;&#125;\n\n定制SpringMVC配置实现WebMvcConfigurer，重写对应的方法进行相关组件的注册和配置。\n\n\n1234567@Configuration@ComponentScan(value = \"controller\", includeFilters = &#123;        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Controller.class),&#125;)public class MVCConfig implements WebMvcConfigurer &#123;&#125;\n\n跨域配置\n123456789@Overridepublic void addCorsMappings(CorsRegistry registry) &#123;    registry.addMapping(\"/**\")        .allowedOrigins(\"*\")        .allowedMethods(\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\")        .allowCredentials(true)        .maxAge(3600)        .allowedHeaders(\"*\");&#125;\n\n拦截器配置\n1234@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;    registry.addInterceptor(new MyInterceptor());&#125;\n\n静态资源处理配置\n1234@Overridepublic void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;    configurer.enable();&#125;\n\n异常处理器配置\n1234@Overridepublic void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;    resolvers.add(new MyHandlerExceptionResolver());&#125;\n\n视图解析器配置\n12345@Overridepublic void configureViewResolvers(ViewResolverRegistry registry) &#123;    registry.jsp().prefix(\"/WEB-INF/\");    registry.jsp().suffix(\".jsp\");&#125;\n\n测试见7-Spring之XML配置加注解开发。\n","thumbnail":"post/Java/Spring/8-Spring之纯注解开发/cover.png","plink":"https://beginc.github.io/post/Java/Spring/8-Spring之纯注解开发/"},{"title":"TCP连接队列","date":"2020-02-28T04:24:02.000Z","date_formatted":{"ll":"Feb 28, 2020","L":"02/28/2020","MM-DD":"02-28"},"updated":"2020-02-29T16:14:25.457Z","content":"连接队列当服务端调用listen函数监听端口的时候，内核会为每个监听的socket创建两个队列\n半连接队列(SYN Queue)\n全连接队列(Accept Queue)\n半连接队列在三次握手时，当服务端收到客户端的SYN段，发送完ACK + SYN段后，服务端进入SYN_RCVD状态，这个时候会将socket放入半连接队列里。\n\n\nSYN Flood攻击SYN Flood攻击是DDoS攻击的一种，攻击者会发送大量SYN段给服务端，服务端会建立大量半连接，在半连接队列满时，服务端会忽略后续连接，导致工作异常。\n解决方法syn_cookies\nTODO\n全连接队列当三次握手都完成后，服务端会将socket从半连接队列里移除，放入全连接队列里。\n连接队列调优内核调优半连接队列大小\n1echo 4096 &gt; /proc/sys/net/ipv4/tcp_max_syn_backlog\n\n全连接队列大小\n1echo 4096 &gt; /proc/sys/net/core/somaxconn\n\n应用调优listen(int sockfd, int backlog)\nbacklog参数可以控制连接队列大小\n12半连接队列长度 = min(backlog，net.core.somaxconn，tcp_max_syn_backlog)全连接队列长度 = min(backlog，net.core.somaxconn)\n\n连接队列监控查看连接队列溢出次数\n1netstat -s | egrep \"listen|LISTEN\"\n\n查看全连接队列状态\n1ss -lnt\n\n\n\nSend-Q表示全连接队列大小的最大值\nRecv-Q表示全连接队列的使用大小\n参考TCP的全连接和半连接队列\n成为高手前必懂的TCP干货\n","thumbnail":"post/计算机网络/TCP连接队列/cover.jpg","plink":"https://beginc.github.io/post/计算机网络/TCP连接队列/"},{"title":"TCP状态转换","date":"2020-02-28T04:23:35.000Z","date_formatted":{"ll":"Feb 28, 2020","L":"02/28/2020","MM-DD":"02-28"},"updated":"2020-02-29T16:14:21.972Z","content":"TCP状态转换图\n\n\n\nTIME_WAIT作用在客户端发送了最后一个ACK挥手包后，会进入时长为2MSL（最大报文段生存时间，在网络传输中超过这个时间的报文段将被丢弃）的TIME_WAIT状态，之后再完全关闭连接，主要有以下两点原因\n保证最后一个ACK挥手包被服务端接收到\n最后一个ACK挥手包可能会发生丢失，若客户端发送完后直接进入关闭状态，则当服务端重发第三次FIN挥手包时，客户端会发生异常，直接回复一个RST包重置连接。因此必须等待一个MSL的时间保证自己能够回复重发的FIN挥手包，正确关闭连接。\n\n\n保证旧连接的网络包在网络中完全消失\n旧连接的网络包有可能由于网络原因，在网络中徘徊后迟到到达客户端，若客户端直接关闭连接后，又与相同的服务端在相同的端口建立了TCP连接（称为一个化身），那么客户端会误以为这个旧的包时现在的连接上所传输的包，导致数据错乱，因此必须再等待一个MSL，保证其在网络中消失。\n参考TCP的TIME_WAIT状态\nTCP状态转换图总结\n成为高手前必懂的TCP干货\n","thumbnail":"post/计算机网络/TCP状态转换/cover.jpg","plink":"https://beginc.github.io/post/计算机网络/TCP状态转换/"},{"title":"TCP三次握手四次挥手","date":"2020-02-28T04:23:24.000Z","date_formatted":{"ll":"Feb 28, 2020","L":"02/28/2020","MM-DD":"02-28"},"updated":"2020-03-13T15:17:35.695Z","content":"三次握手TCP建立连接的作用TCP基于网络层IP协议，IP协议只提供点到点的首部校验，并未对数据部分承诺可靠传输，因此TCP需要实现端到端的可靠传输。TCP实现可靠传输的核心就是：\n序号：表示当前传输的报文段第一个字节的编号\n确认号：表示确认收到了确认号之前的所有字节（累积确认）\n通过这两个字段，在收到报文时就可确认报文是否合法，因此在建立连接时的任务就是要确认通信双方的初始序号大小。\n三次握手过程\n\n为何需要三次握手如果要双方都确认对方的初始序号，那么至少需要一来一回两次通信\nClient: SYN + 客户端初始序号x\nServer：SYN  + ACK + 服务端初始序号y + 对客户端的确认号x + 1（确认收到了客户端的初始序号）\n为何需要第三次：由于底层IP协议不提供可靠传输，因此服务端发送给客户端的初始序号报文可能丢失，因此客户端必须收到后给予服务端一个ACK确认报文\n异常情况第一次握手包丢失\n客户端收不到服务端的ACK确认报文，会超时重传\n第二次握手包丢失\n服务端收不到客户端的ACK确认报文，会超时重传\n第三次握手包丢失\n客户端收到ACK后，已经进入了Established状态\n客户端不发送数据：服务端会超时重传第二次握手包\n客户端发送数据：会带上ACK和数据，服务端收到确认后进入Established状态\n服务端没有收到确认，无法发送数据，定时超时重传第二次握手包重传超过一定次数后发送RST报文，关闭连接\n\n四次挥手TCP拆除连接的作用很显然，是用于告诉对方结束发送数据。\n四次挥手过程\n\n为何需要四次挥手第一次：A告诉B我发送完毕了\n第二次：B告诉A，收到\n第三次：由于A单方面告诉B结束发送数据，但是B可能还有数据未发送完成，此时他会继续发送数据直到发送完毕，此时B需要通知A我已经发送完毕了，连接可以完全拆除\n第四次：相同的原因，底层网络不可靠，A需要给B发送ACK确认报文\n异常情况第一次挥手包丢失\nA会超时重传\n第二次挥手包丢失\nB会在后续发送数据，或者第三次挥手时发送ACK确认\n第三次挥手包丢失\nB会超时重传\n第四次挥手包丢失\nB会重发第三次挥手包，直到收到确认\n参考TCP 为什么是三次握手，而不是两次或四次？\n","thumbnail":"post/计算机网络/TCP三次握手四次挥手/cover.jpg","plink":"https://beginc.github.io/post/计算机网络/TCP三次握手四次挥手/"},{"title":"Java之NIO","date":"2020-02-27T15:19:30.000Z","date_formatted":{"ll":"Feb 27, 2020","L":"02/27/2020","MM-DD":"02-27"},"updated":"2020-02-29T16:21:19.957Z","content":"Bufferbuffer即缓冲区。\nBuffer类型ByteBuffer\nCharBuffer\nShortBuffer\nIntBuffer\nLongBuffer\nFloatBuffer\nDoubleBuffer\nBuffer内存类型方法","thumbnail":"post/Java/Java语言/Java之NIO/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java之NIO/"},{"title":"I/O模型","date":"2020-02-27T13:22:16.000Z","date_formatted":{"ll":"Feb 27, 2020","L":"02/27/2020","MM-DD":"02-27"},"updated":"2020-02-29T16:20:45.527Z","content":"概念区分阻塞与非阻塞阻塞与非阻塞是对请求的发起者而言的\n阻塞：请求未返回之前，发起者一直等待其返回，不做其他任何事情\n非阻塞：请求发起后不等待其返回，就去做其他事情\n举例\n阻塞即买炒饭时老板没做好，你就一直等着，啥也不干\n阻塞即买炒饭时告诉老板来一碗炒饭，之后你就开始玩手机，干其他事\n同步与异步同步与异步是对请求的响应者而言的\n同步：请求未处理完之前不返回响应\n异步：请求接收到之后马上返回响应，之后再进行处理\n举例\n同步即炒饭老板听到别人说来一碗炒饭后，没炒完饭不给他回应\n异步即炒饭老板听到别人说来一碗炒饭后，直接告诉他收到了马上炒，然后开始炒饭\nI/O模型阻塞I/O\n\n非阻塞I/O需要CPU轮询来检查数据是否准备好\n\n\n信号驱动I/O调用sigaction时立刻返回，建立信号处理程序\n数据准备好后通知信号处理程序\n执行recvfrom复制数据\n免去了CPU轮询的过程\n\n\n异步I/O异步I/O与信号驱动I/O最大区别在于，信号驱动是内核通知我们何时开始一个I/O操作，而异步I/O是由内核通知我们I/O操作何时完成，两者有本质区别。\n\n\nI/O多路复用I/O多路复用（Multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。\nSelect调用select时传入要监视的fd_set（socket描述符数组）\n把进程添加到所有socket的等待队列中，进程阻塞\n\n\n数据到来时通过中断程序将进程从所有socket等待队列中移除，唤醒进程\n\n\n\n\n进程被唤醒时，并不知道是哪个socket有数据，需要对其进行遍历，判断之后做出处理\n缺点\n每次调用select都需要将进程加入到所有监视socket的等待队列\n每次唤醒都需要从每个队列中移除\n每次调用select，都需要把fd_set集合从用户态拷贝到内核态（因此限制fd_set最大为1024）\nPollpoll的机制与select类似，与select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。\nEpoll功能分离\n和select不同，epoll通过引入eventpoll对象将维护等待队列和阻塞进程功能分离。避免每次都把进程遍历加入socket等待队列/移出等待队列。\n当某个进程调用epoll_create方法时，内核会创建一个eventpoll对象\n创建epoll对象后，可以用epoll_ctl添加或删除所要监听的socket，内核会将eventpoll添加到socket的等待队列中\n进程执行epoll_wait语句后，内核会将进程放入eventpoll的等待队列中，阻塞进程\n\n\n\n\n维护就绪列表\n不同于select，epoll还会维护就绪的socket的列表，避免程序对socket进行遍历。进程被唤醒后直接通过就绪列表就可知道就绪的socket。\n触发方式\n水平触发：只要监听的文件描述符中有数据，就会触发epoll_wait返回\n边缘触发：只有监听的文件描述符的读/写事件发生，才会触发epoll_wait返回\n参考如果这篇文章说不清epoll的本质，那就过来掐死我吧！\n迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO讲的这么清楚的好文章\nlinux多路IO--epoll(一)--水平触发和边沿触发\n信号驱动IO与异步IO\n","thumbnail":"post/Linux/IO模型/cover.jpg","plink":"https://beginc.github.io/post/Linux/IO模型/"},{"title":"Linux零拷贝","date":"2020-02-27T12:48:47.000Z","date_formatted":{"ll":"Feb 27, 2020","L":"02/27/2020","MM-DD":"02-27"},"updated":"2020-02-29T16:20:49.597Z","content":"传统I/O传统的read和write系统调用涉及到了\n4次用户态内核态上下文切换\n2次CPU拷贝\n2次DMA拷贝\n效率较为低下。\n\n\n零拷贝零拷贝技术核心目的就是要减少内存拷贝，减少内核态用户态上下文切换。\n用户态直接I/O让进程直接在用户态下进行I/O操作。\n优点\n无上下文切换\n无CPU拷贝\n缺点\n失去了OS的缓冲区管理功能，需要用户自己维护缓存区\nCPU和硬件设备速度差异大，造成了过多了CPU时间浪费\n\n\nMmap + Write内存映射文件，将一个进程的地址空间中的一段虚拟地址映射到磁盘文件地址。该模式下用户与内核共享一块缓存空间，减少了一次CPU拷贝\n4次上下文切换\n1次CPU拷贝\n2次DMA拷贝\n缺点\n该磁盘文件可能被另一个进程截获，write调用会被终止。\n\n\nSendfile用于直接在两个通道之中进行数据传输，数据不经过用户空间。\n2次上下文切换\n1次CPU拷贝\n2次DMA拷贝\n缺点\n数据不经过用户空间，用户无法对数据进行更改，只适用于纯粹的数据传输。\n只能从文件拷贝到套接字。\n\n\nSendfile + DMA Gather Copysendfile模式下，还是存在一次不必要的CPU拷贝，sendfile加上DMA Gather Copy之后\n读完数据将缓冲区文件描述符和数据长度拷贝到Socket缓冲区。\nDMA Gather Copy直接根据描述信息到内核缓冲区拿数据。\n该模式下涉及到了\n2次上下文切换\n0次CPU拷贝\n2次DMA拷贝\n缺点\n需要硬件支持。\n只能从文件拷贝到套接字。\n\n\nSplicesendfile需要硬件支持，还只支持从文件到套接字的拷贝，而splice模式下\n不需要硬件支持\n支持两个文件描述符之间的拷贝\n通过在内核缓冲区和Socket缓冲区之间建立了管道，避免了CPU拷贝\n2次上下文切换\n0次CPU拷贝\n2次DMA拷贝\n\n\n\n参考深入剖析Linux IO原理和几种零拷贝机制的实现\n","thumbnail":"post/Linux/Linux零拷贝/cover.jpg","plink":"https://beginc.github.io/post/Linux/Linux零拷贝/"},{"title":"RocketMQ之高性能消息存储","date":"2020-02-27T12:04:21.000Z","date_formatted":{"ll":"Feb 27, 2020","L":"02/27/2020","MM-DD":"02-27"},"updated":"2020-02-29T16:17:20.759Z","content":"消息发送流程在RocketMQ所有消息都会被持久化存储。\n消息发送：先持久化消息再回复ACK\n消息消费：需要从持久化文件中读取消息\n消息I/O的性能决定了整个MQ系统的性能，因此必须设计出一套高效的消息存储方案。\n\n\n存储结构CommitLogMQ收到消息时会先把消息持久化，然后再返回ACK确认，为了保证I/O的高效性，RocketMQ用到了两个技术。\n顺序写对于磁盘介质来说，顺序读写时速度最快，因此Broker会维护CommitLog文件，当消息来时（任何主题的消息），会追加到该文件的末尾，来保证最高的性能。一个CommitLog文件默认最大大小为1G，超过后会重新创建一个CommitLog文件，以该文件第一个消息的Offset来命名。\n零拷贝使用了mmap + write技术减少了CPU拷贝缓冲区的次数。\n传统I/O\n对于传统I/O方式一次I/O读和一次I/O写需要\n4次用户态内核态上下文切换\n2次CPU Copy\n2次DMA Copy\n\n\nmmap + write\n使用内存映射文件(mmap)技术可将一块磁盘空间映射到一个用户和内核公用的内核缓冲区中，一次I/O读和I/O写需要\n4次用户态内核态上下文切换\n1次CPU Copy\n2次DMA Copy\n\n\nComsumeQueue在Broker中所有的消息都被写入了CommitLog文件时，而Consumer进行消息消费时，需要按照Topic进行消息检索，此时会有很大的查找开销，因此RocketMQ使用了ConsumeQueue文件来进行索引加速。每个Topic的每个队列都会有一个ConsumeQueue文件，存储了\nCommitLog Offset消息在CommitLog中的起始Offset\nSize消息的大小\nMessage Tag  HashCode\n\n\nIndex该文件提供了索引结构以来支持按key或者时间区间对消息进行查询。\n高可靠消息存储刷盘机制同步刷盘\nBroker接收到消息时，将消息写入到CommitLog中后再返回ACK。\n性能较低\n异步刷盘\nBroker接收到消息时，消息只写入了缓冲区中，此时直接返回，在消息积累到一定程度时，统一触发刷盘操作。\n性能较高\n主从复制同步复制\n同步双写，当Master和Slave都写成功后，才返回ACK。\n高可靠\n性能较低\n异步复制\nMaster写成功后，直接返回ACK，异步复制到Slave。\n低可靠\n性能较高\n故障恢复由于消息会先存储到CommitLog中，然后异步地更新ConsumeQueue和Index文件，若来不及更新时就宕机，则会导致数据不一致。\n解决方法\nBroker在启动时会创建abort文件\n正常退出：在JVM钩子函数中删除abort文件\n非正常退出：启动时检测到abort文件存在，说明数据可能不一致，会进行修复\n","thumbnail":"post/中间件/RocketMQ/RocketMQ之高性能消息存储/cover.png","plink":"https://beginc.github.io/post/中间件/RocketMQ/RocketMQ之高性能消息存储/"},{"title":"RocketMQ之高可用消息发送","date":"2020-02-27T11:43:36.000Z","date_formatted":{"ll":"Feb 27, 2020","L":"02/27/2020","MM-DD":"02-27"},"updated":"2020-02-29T16:17:16.812Z","content":"消息发送流程验证消息确保Producer处于运行状态\n确保消息符合规范\n查找路由路由缓存\nProducer本地会缓存查找过的路由信息，当本地缓存存在时，无需向NameServer查找。\n查找路由\n当本地缓存不存在需要查找的路由时，Producer会从NameServer拉取路由信息。\n消息发送负载均衡在对应Topic的多个消息队列中，Producer使用Round-Robin的方式进行队列选择，来实现消息发送的负载均衡。\n高可用消息发送由于NameServer不会主动推送最新的路由信息，所以Producer本地路由信息中可能包含已经宕机的Broker信息，此时需要一定机制来保证高可用的消息发送。\n重试机制当消息发送失败时，Producer会进行retryTimesWhenSendFailed(同步)/retryTimesWhenSendAsyncFailed(异步)次重试。\n规避故障Broker可通过设置sendLatencyFaultEnable来控制规避模式。\n非故障延迟该模式下，若尝试给一个Broker发送消息失败时，会将其记录下来，在下次重试时，则会跳过该故障Broker的队列，选择其他队列进行消息发送。但是这种机制只能保证一次消息发送中规避掉故障Broker，在下次发送信息时，还要经历失败---&gt;规避的过程。\n故障延迟该机制下，在发送消息给一个队列之前，会先验证其是否可用（处于可用时间），若不可用，则会获取下一个消息队列。当在某一个Broker处第一次发送消息失败时，会为其预估出一个故障时间，在此时间内该Broker都被认为是不可用状态，在下次发送消息时，该Broker的消息队列会通不过可用验证，直接跳过。若当前所有Broker都处于故障时间，则会随机在其中选择一个消息队列进行发送。\n","thumbnail":"post/中间件/RocketMQ/RocketMQ之高可用消息发送/cover.png","plink":"https://beginc.github.io/post/中间件/RocketMQ/RocketMQ之高可用消息发送/"},{"title":"RocketMQ之NameServer","date":"2020-02-27T11:27:05.000Z","date_formatted":{"ll":"Feb 27, 2020","L":"02/27/2020","MM-DD":"02-27"},"updated":"2020-02-29T16:17:23.341Z","content":"NameServer功能服务注册每个Broker启动都需要向所有NameServer注册。\n服务发现每个Broker都需要与NameServer保持长连接，每隔30秒发送心跳。NameServer每个30秒检测Broker是否存活，如果检测到宕机，则将其从注册表中移除。\n路由管理NameServer需要维护路由信息，即Producer发送的消息应该发送给谁，Consumer应该找谁消费。当路由发生变化时，不会主动推送给客户端，而是由客户端定时拉取Topic最新的路由。\nNameServer集群NameServer集群被设计成无状态的，集群中所有结点的信息保持最终一致性，可以轻松横向扩展。这种简易设计是为了提高NameServer的高性能。\n","thumbnail":"post/中间件/RocketMQ/RocketMQ之NameServer/cover.png","plink":"https://beginc.github.io/post/中间件/RocketMQ/RocketMQ之NameServer/"},{"title":"RocketMQ各种消息","date":"2020-02-26T02:30:29.000Z","date_formatted":{"ll":"Feb 26, 2020","L":"02/26/2020","MM-DD":"02-26"},"updated":"2020-02-29T16:17:08.392Z","content":"环境搭建12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;rocketmq01&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;project.sourceEncoding&gt;UTF-8&lt;/project.sourceEncoding&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;            &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;            &lt;version&gt;4.6.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\n基本生产与消费生产创建Producer对象\n设置NameServer地址\n启动\n发送消息\n12345678910111213141516171819public class Producer &#123;    private static final String NAMESRV_ADDR = \"192.168.31.101:9876;192.168.31.102:9876\";    private static final String PRODUCER_GROUP_NAME = \"basic_producer_group\";    private static final String TOPIC = \"basic_topic\";    private static final String TAG = \"basic_tag\";    public static void main(String[] args) throws MQClientException, RemotingException, InterruptedException, MQBrokerException &#123;        DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP_NAME);        producer.setNamesrvAddr(NAMESRV_ADDR);        producer.start();        for (int i = 0; i &lt; 10; i++) &#123;            Message message = new Message(TOPIC, TAG, (\"你好\" + i).getBytes());            SendResult result = producer.send(message);            System.out.println(result);        &#125;        producer.shutdown();    &#125;&#125;\n\n消费创建Consumer对象\n设置NameServer地址\n注册消息监听器\n启动\n负载均衡模式每个Topic会创建多个消息队列，负载均衡模式下，会将消息队列均匀分配给每一个消费者进行消费（不会重复）。\n12345678910111213141516171819202122public class Consumer &#123;    private static final String NAMESRV_ADDR = \"192.168.31.101:9876;192.168.31.102:9876\";    private static final String CONSUMER_GROUP_NAME = \"basic_consumer_group\";    private static final String TOPIC = \"basic_topic\";    public static void main(String[] args) throws MQClientException &#123;        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP_NAME);        consumer.setNamesrvAddr(NAMESRV_ADDR);        consumer.subscribe(TOPIC, \"*\");        // **********************************************        consumer.setMessageModel(MessageModel.CLUSTERING);        // **********************************************        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;            @Override            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;                System.out.println(msgs);                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;            &#125;        &#125;);        consumer.start();    &#125;&#125;\n\n广播模式每个消费者都可收到订阅的Topic的所有消息。\n12345678910111213141516171819202122public class Consumer &#123;    private static final String NAMESRV_ADDR = \"192.168.31.101:9876;192.168.31.102:9876\";    private static final String CONSUMER_GROUP_NAME = \"basic_consumer_group\";    private static final String TOPIC = \"basic_topic\";    public static void main(String[] args) throws MQClientException &#123;        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP_NAME);        consumer.setNamesrvAddr(NAMESRV_ADDR);        consumer.subscribe(TOPIC, \"*\");        // **********************************************        consumer.setMessageModel(MessageModel.BROADCASTING);        // **********************************************        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;            @Override            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;                System.out.println(msgs);                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;            &#125;        &#125;);        consumer.start();    &#125;&#125;\n\n同步消息生产者发送完消息后，需要等到Broker存储完消息，收到Broker的ACK后才会返回。\n1234567891011121314151617181920public class Producer &#123;    private static final String NAMESRV_ADDR = \"192.168.31.101:9876;192.168.31.102:9876\";    private static final String PRODUCER_GROUP_NAME = \"sync_producer_group\";    private static final String TOPIC = \"sync_topic\";    private static final String TAG = \"sync_tag\";    public static void main(String[] args) throws MQClientException, RemotingException, InterruptedException, MQBrokerException &#123;        DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP_NAME);        producer.setNamesrvAddr(NAMESRV_ADDR);        producer.start();        for (int i = 0; i &lt; 10; i++) &#123;            Message message = new Message(TOPIC, TAG, (\"你好\" + i).getBytes());            // 阻塞，发送完收到ACK才返回            SendResult result = producer.send(message);            System.out.println(result);        &#125;        producer.shutdown();    &#125;&#125;\n\n异步消息生产者发送完消息后，马上返回，注册回调函数来接收发送的结果。\n12345678910111213141516171819202122232425262728293031public class Producer &#123;    private static final String NAMESRV_ADDR = \"192.168.31.101:9876;192.168.31.102:9876\";    private static final String PRODUCER_GROUP_NAME = \"async_producer_group\";    private static final String TOPIC = \"async_topic\";    private static final String TAG = \"async_tag\";    public static void main(String[] args) throws MQClientException, RemotingException, InterruptedException, MQBrokerException &#123;        DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP_NAME);        producer.setNamesrvAddr(NAMESRV_ADDR);        producer.start();        for (int i = 0; i &lt; 10; i++) &#123;            Message message = new Message(TOPIC, TAG, (\"你好\" + i).getBytes());            // ****************Callback****************            producer.send(message, new SendCallback() &#123;                @Override                public void onSuccess(SendResult sendResult) &#123;                    System.out.println(\"发送成功!\");                    System.out.println(sendResult);                &#125;                @Override                public void onException(Throwable e) &#123;                    System.out.println(\"发送失败!\");                &#125;            &#125;);            // ****************Callback****************        &#125;        producer.shutdown();    &#125;&#125;\n\n单向消息生产者只管发送，不关心发送是否成功。\n1234567891011121314151617181920public class Producer &#123;    private static final String NAMESRV_ADDR = \"192.168.31.101:9876;192.168.31.102:9876\";    private static final String PRODUCER_GROUP_NAME = \"oneway_producer_group\";    private static final String TOPIC = \"oneway_topic\";    public static void main(String[] args) throws MQClientException, RemotingException, InterruptedException, MQBrokerException &#123;        DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP_NAME);        producer.setNamesrvAddr(NAMESRV_ADDR);        producer.start();        for (int i = 0; i &lt; 10; i++) &#123;            Message message = new Message(TOPIC, TAG, (\"你好\" + i).getBytes());            // **************************            producer.sendOneway(message);            // **************************            System.out.println(\"发送成功!\");        &#125;        producer.shutdown();    &#125;&#125;\n\n顺序消息有时候我们需要一组消息按顺序被消费，此时可使用顺序消息。\n全局顺序即发送的所有消息都需要保证按顺序消费，RocketMQ不支持，但可以设置Topic的队列数目为1来实现（开销大）。\n局部顺序只保证一组消息按顺序被消费。\n实现生产者\n将需要顺序进行消费的消息放入同一个队列里，这样就可以达到先进先出的效果，保证消息被顺序消费。\n12345678910111213141516171819202122232425262728293031public class Producer &#123;    private static final String NAMESRV_ADDR = \"192.168.31.101:9876;192.168.31.102:9876\";    private static final String PRODUCER_GROUP_NAME = \"order_producer_group\";    private static final String TOPIC = \"order_topic\";    private static final String TAG = \"order_tag\";    public static void main(String[] args) throws MQClientException, RemotingException, InterruptedException, MQBrokerException &#123;        DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP_NAME);        producer.setNamesrvAddr(NAMESRV_ADDR);        producer.start();        for (int i = 0; i &lt; 10; i++) &#123;            Message message = new Message(TOPIC, TAG, (\"你好\" + i).getBytes());            // ***********业务表示*************            int id = i;            // ***********队列选择器***********            SendResult sendResult = producer.send(message, new MessageQueueSelector() &#123;                @Override                public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;                    int size = mqs.size();                    int id = (int) arg;                    // ***根据业务id来选择队列**                    return mqs.get(id % 2);                &#125;            &#125;, id);            System.out.println(sendResult);        &#125;        producer.shutdown();    &#125;&#125;\n\n\n\n消费者\n注册串行消息监听器，保证只有一个线程对消息进行消费。\n1234567891011121314151617181920public class Consumer &#123;    private static final String NAMESRV_ADDR = \"192.168.31.101:9876;192.168.31.102:9876\";    private static final String CONSUMER_GROUP_NAME = \"order_consumer_group\";    private static final String TOPIC = \"order_topic\";    private static final String TAG = \"order_tag\";    public static void main(String[] args) throws MQClientException &#123;        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP_NAME);        consumer.setNamesrvAddr(NAMESRV_ADDR);        consumer.setMessageModel(MessageModel.CLUSTERING);        consumer.registerMessageListener(new MessageListenerOrderly() &#123;            @Override            public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context) &#123;                System.out.println(msgs);                return ConsumeOrderlyStatus.SUCCESS;            &#125;        &#125;);        consumer.start();    &#125;&#125;\n\n延时消息延时等级RocketMQ不支持任意时间的延时，目前可设置的延迟等级有18个，分别为\n1s\n5s\n10s\n30s\n1m\n2m\n3m\n4m\n5m\n6m\n7m\n8m\n9m\n10m\n20m\n30m\n1h\n2h\n延时消息原理Broker对延时消息会将其放入SCHEDULE_TOPIC_XXXX的Topic中，而不是消息对应的Topic中，保证消费者无法消费。\n通过使用定时任务来恢复到达延时的消息，将其放入其对应的队列中\n实现12345678910111213141516171819202122public class Producer &#123;    private static final String NAMESRV_ADDR = \"192.168.31.101:9876;192.168.31.102:9876\";    private static final String PRODUCER_GROUP_NAME = \"delay_producer_group\";    private static final String TOPIC = \"delay_topic\";    private static final String TAG = \"delay_tag\";    public static void main(String[] args) throws MQClientException, RemotingException, InterruptedException, MQBrokerException &#123;        DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP_NAME);        producer.setNamesrvAddr(NAMESRV_ADDR);        producer.start();        for (int i = 0; i &lt; 10; i++) &#123;            Message message = new Message(TOPIC, TAG, (\"你好\" + i).getBytes());            // *********设置延时等级*********************            message.setDelayTimeLevel(2);            // ****************************************            SendResult result = producer.send(message);                        System.out.println(result);        &#125;        producer.shutdown();    &#125;&#125;\n\n批量消息批量发送消息可减少网络开销，提高性能。\n限制\n相同的Topic\n相同的waitStoreMsgOK\n不能为延时消息\n总大小不超过4MB\n123456789101112131415161718192021public class Producer &#123;    private static final String NAMESRV_ADDR = \"192.168.31.101:9876;192.168.31.102:9876\";    private static final String PRODUCER_GROUP_NAME = \"batch_producer_group\";    private static final String TOPIC = \"batch_topic\";    private static final String TAG = \"batch_tag\";    public static void main(String[] args) throws MQClientException, RemotingException, InterruptedException, MQBrokerException &#123;        DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP_NAME);        producer.setNamesrvAddr(NAMESRV_ADDR);        producer.start();        List&lt;Message&gt; messages = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 10; i++) &#123;            Message message = new Message(TOPIC, TAG, (\"你好\" + i).getBytes());            messages.add(message);        &#125;        SendResult result = producer.send(messages);        System.out.println(result);        producer.shutdown();    &#125;&#125;\n\n事务消息分布式事务通常如转账等业务需要用事务来保证数据的一致性。在单机环境下，我们可以很方便的实现事务管理，但是在分布式环境下，我们需要使用两阶段提交，三阶段提交等分布式事务协议来进行处理。但这些方案开销较大，影响性能。此时我们可以使用消息队列来使用最终一致性代替强一致性，提高性能。\n生动说明去面馆吃面，点完单后会给你一张小票，之后你拿着小票就可以去领到自己的面，虽然可能后厨现在特别的忙，或者暂时出去接电话不在，但是只要你有小票，最终就一定能拿到面。\n小票---&gt;消息\n最终拿到面---&gt;最终一致性\n事务消息流程\n\n正常流程发送事务消息\nBroker持久化消息\nBroker发送ACK\n执行本地事务\n根据本地事务执行结果Commit/Rollback\n\n\n事务补偿流程发送事务消息\nBroker持久化消息\nBroker发送ACK\n执行本地事务\n回复UNKNOWN或者不回复\nBroker未收到回复或者受到UNKNOWN对Producer进行事务回查\n返回Commit/Rollback\n\n\n\n\n实现12345678910111213141516171819202122232425262728293031public class Producer &#123;    private static final String NAMESRV_ADDR = \"192.168.31.101:9876;192.168.31.102:9876\";    private static final String PRODUCER_GROUP_NAME = \"trans_producer_group\";    private static final String TOPIC = \"trans_topic\";    private static final String TAG = \"trans_tag\";    public static void main(String[] args) throws MQClientException, RemotingException, InterruptedException, MQBrokerException &#123;        TransactionMQProducer producer = new TransactionMQProducer(PRODUCER_GROUP_NAME);        producer.setNamesrvAddr(NAMESRV_ADDR);        producer.setTransactionListener(new TransactionListener() &#123;            @Override            public LocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;                System.out.println(\"check status\");                System.out.println(\"execute local transaction\");                System.out.println(msg);                return LocalTransactionState.UNKNOW;            &#125;            @Override            public LocalTransactionState checkLocalTransaction(MessageExt msg) &#123;                System.out.println(\"check back\");                return LocalTransactionState.ROLLBACK_MESSAGE;            &#125;        &#125;);        producer.start();        Message message = new Message(TOPIC, TAG, \"你好\".getBytes());        SendResult result = producer.sendMessageInTransaction(message, null);        System.out.println(result);    &#125;&#125;\n\n过滤消息","thumbnail":"post/中间件/RocketMQ/RocketMQ各种消息/cover.png","plink":"https://beginc.github.io/post/中间件/RocketMQ/RocketMQ各种消息/"},{"title":"RocketMQ集群搭建","date":"2020-02-24T11:50:46.000Z","date_formatted":{"ll":"Feb 24, 2020","L":"02/24/2020","MM-DD":"02-24"},"updated":"2020-02-29T16:17:12.687Z","content":"环境节点使用两台CentOS7的虚拟机来部署双Name Server + 双主双从Broker\nName Server\n192.168.31.101\n192.168.31.102\nBroker Master\n192.168.31.103\nBroker Slave\n192.168.31.104\n防火墙\n这里选择直接将防火墙关闭\n1systemctl stop firewalld.service\n\n软件JDK1.8\nNameServer集群文件准备下载rocketmq-all-4.6.1-bin-release.zip\n解压到/usr/local/\n\n\n启动192.168.31.101\n12cd /usr/local/rocketmq-all-4.6.0-bin-release/bin/nohup ./mqnamesrv &gt; /dev/null 2&gt;&amp;1 &amp;\n\n192.168.31.102\n12cd /usr/local/rocketmq-all-4.6.0-bin-release/bin/nohup ./mqnamesrv &gt; /dev/null 2&gt;&amp;1 &amp;\n\nBroker集群文件准备下载rocketmq-all-4.6.1-bin-release.zip\n解压到/usr/local/\n\n\n配置文件Master配置文件\n/usr/local/rocketmq-all-4.6.0-bin-release/conf/myconf/broker-0.properties\n123456789101112131415161718192021222324252627282930313233343536373839# 集群名字brokerClusterName=cluster# broker名称，相同名称的broker为一组#\t- brokerId == 0 ---&gt; Master#\t- brokerId &gt; 0  ---&gt; SlavebrokerName=brokerabrokerId=0# NameServernamesrvAddr=192.168.31.101:9876;192.168.31.102:9876# 每个Topic对应的消息队列的数量defaultTopicQueueNums=4# 是否自动创建TopicautoCreateTopicEnable=True# 是否自动创建订阅组autoCreateSubscriptionGroup=True# 监听端口listenPort=10911# 何时删除文件deleteWhen=4# 消息保留时间（小时）fileReservedTime=120# 单个commitLog文件大小mapedFileSizeCommitLog=1073741824# 单个ConsumeQueue文件大小mapedFileSizeConsumeQueue=300000# 超过该磁盘使用比例，触发过期文件删除diskMaxUsedSpaceRatio=88storePathRootDir=/usr/local/rocketmq-all-4.6.0-bin-release/storestorePathCommitLog=/usr/local/rocketmq-all-4.6.0-bin-release/store/commitlogstorePathConsumeQueue=/usr/local/rocketmq-all-4.6.0-bin-release/store/consumequeuestorePathIndex=/usr/local/rocketmq-all-4.6.0-bin-release/store/indexstoreCheckpoint=/usr/local/rocketmq-all-4.6.0-bin-release/store/checkpointabortFile=/usr/local/rocketmq-all-4.6.0-bin-release/store/abort# 最大消息大小maxMessageSize=65536# 同步主从架构的MasterbrokerRole=SYNC_MASTER# 同步刷盘flushDiskType=SYNC_FLUSH\n\nSlave/usr/local/rocketmq-all-4.6.0-bin-release/conf/myconf/broker-1.properties\n123456789101112131415161718192021222324252627282930313233343536373839# 集群名字brokerClusterName=cluster# broker名称，相同名称的broker为一组#\t- brokerId == 0 ---&gt; Master#\t- brokerId &gt; 0  ---&gt; SlavebrokerName=brokerabrokerId=1# NameServernamesrvAddr=192.168.31.101:9876;192.168.31.102:9876# 每个Topic对应的消息队列的数量defaultTopicQueueNums=4# 是否自动创建TopicautoCreateTopicEnable=True# 是否自动创建订阅组autoCreateSubscriptionGroup=True# 监听端口listenPort=10911# 何时删除文件deleteWhen=4# 消息保留时间（小时）fileReservedTime=120# 单个commitLog文件大小mapedFileSizeCommitLog=1073741824# 单个ConsumeQueue文件大小mapedFileSizeConsumeQueue=300000# 超过该磁盘使用比例，触发过期文件删除diskMaxUsedSpaceRatio=88storePathRootDir=/usr/local/rocketmq-all-4.6.0-bin-release/storestorePathCommitLog=/usr/local/rocketmq-all-4.6.0-bin-release/store/commitlogstorePathConsumeQueue=/usr/local/rocketmq-all-4.6.0-bin-release/store/consumequeuestorePathIndex=/usr/local/rocketmq-all-4.6.0-bin-release/store/indexstoreCheckpoint=/usr/local/rocketmq-all-4.6.0-bin-release/store/checkpointabortFile=/usr/local/rocketmq-all-4.6.0-bin-release/store/abort# 最大消息大小maxMessageSize=65536# 同步主从架构的MasterbrokerRole=SLAVE# 同步刷盘flushDiskType=SYNC_FLUSH\n\n启动Master\n12cd /usr/local/rocketmq-all-4.6.0-bin-release/bin/nohup ./mqbroker -c /usr/local/rocketmq-all-4.6.0-bin-release/conf/myconf/broker-0.properties &gt; /dev/null 2&gt;&amp;1 &amp;\n\nSlave\n12cd /usr/local/rocketmq-all-4.6.0-bin-release/bin/nohup ./mqbroker -c /usr/local/rocketmq-all-4.6.0-bin-release/conf/myconf/broker-1.properties &gt; /dev/null 2&gt;&amp;1 &amp;\n\n监控平台TODO\n","thumbnail":"post/中间件/RocketMQ/RocketMQ集群搭建/cover.png","plink":"https://beginc.github.io/post/中间件/RocketMQ/RocketMQ集群搭建/"},{"title":"消息队列应用","date":"2020-02-24T11:30:35.000Z","date_formatted":{"ll":"Feb 24, 2020","L":"02/24/2020","MM-DD":"02-24"},"updated":"2020-02-29T16:17:05.072Z","content":"应用解耦一个系统中常常会出现不同服务之间的调用，此处会出现以下问题。这些都是服务之间耦合的表现。\n下游服务不可用\n\n\n在注册成功后，我们希望发送一封成功注册的通知邮件给用户，但是由于某些原因，邮件服务暂时不可用，此时会导致我们的注册服务也失败。\n下游服务变化\n\n\n有时候我们希望注册成功后，换成使用短信来通知用户注册成功，此时我们则需要变动注册服务的代码。\n消息队列解耦\n我们可以通过引入消息队列，注册成功后将消息推发布到消息队列中，让对应的下游服务进行订阅，此时就达到了解耦的目的。\n\n\n异步处理还是以注册为例，我们完成注册后，不需要等到邮件发送成功才通知用户注册成功，此时我们可以将发送邮件的消息发布到消息队列中，让邮件服务等到空闲时再读取消息，发送邮件，这样一来缓解了邮件服务的压力，二来提高了注册服务的反应速度。\n流量削峰对突增的流量进行进行削峰，减小服务器压力，其实就是做到了缓冲 + 速率转换。\n\n\n","thumbnail":"post/中间件/RocketMQ/消息队列应用/cover.png","plink":"https://beginc.github.io/post/中间件/RocketMQ/消息队列应用/"},{"title":"Java并发之两阶段终止模式","date":"2020-02-12T14:57:43.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-03-16T15:30:48.408Z","content":"简介该模式用于优雅的终止一个线程。\nstop方法的弊端\n调用该方法可以杀死一个线程，但是如果该线程锁住了某些共享资源，则可能导致死锁。\n两阶段终止模式实现线程运行时不断监控打断标记，若有打断标记，则处理完后事后终止线程。\n使用打断来终止线程而不是stop。\n123456789101112131415161718192021222324252627282930313233343536373839404142public class Main &#123;    public static void main(String[] args) throws InterruptedException &#123;        MyMonitor monitor = new MyMonitor();        monitor.start();        Thread.sleep(4500);        monitor.stop();    &#125;&#125;class MyMonitor &#123;    private Thread thread;    public void start()&#123;        thread = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                while(true)&#123;                    Thread current = Thread.currentThread();                    if(thread.isInterrupted())&#123;                        System.out.println(\"被打断了...\");                        System.out.println(\"做善后处理...\");                        break;                    &#125;else&#123;                        System.out.println(\"继续做我的事情...\");                        try &#123;                            Thread.sleep(1000);                        &#125; catch (InterruptedException e) &#123;                            System.out.println(\"睡眠的时候被打断了...\");                            System.out.println(\"使用打断来做善后处理...\");                            current.interrupt();                        &#125;                    &#125;                &#125;            &#125;        &#125;);        thread.start();    &#125;    public void stop()&#123;        thread.interrupt();    &#125;&#125;\n\n","plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之两阶段终止模式/"},{"title":"Java并发之ReentrantLock","date":"2020-02-12T14:25:38.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-03-16T15:30:48.412Z","content":"ReentrantLock特性可重入\n\n可打断\nlockInterruptibly()\n\n12345678910111213141516171819202122232425262728293031public class TestThread &#123;    private static ReentrantLock lock = new ReentrantLock();    @Test    public void test1() throws ExecutionException, InterruptedException &#123;        Thread thread = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    System.out.println(\"等待获取锁...\");                    lock.lockInterruptibly();                    System.out.println(\"获取到了锁\");                &#125; catch (InterruptedException e) &#123;                    System.out.println(\"被打断了\");                &#125;            &#125;        &#125;);        lock.lock();        thread.start();        TimeUnit.SECONDS.sleep(3);        thread.interrupt();        TimeUnit.SECONDS.sleep(3);        System.out.println(\"解锁\");        lock.unlock();    &#125;&#125;\n\n锁超时\n123456789101112131415161718192021222324252627282930public class TestThread &#123;    private static ReentrantLock lock = new ReentrantLock();    @Test    public void test1() throws ExecutionException, InterruptedException &#123;        Thread thread = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    System.out.println(\"等待获取锁...\");                    if(lock.tryLock(2, TimeUnit.SECONDS))                        System.out.println(\"2秒内获取到了锁\");                    else                        System.out.println(\"2秒过去了还没获得锁\");                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;);        lock.lock();        thread.start();        TimeUnit.SECONDS.sleep(5);        System.out.println(\"解锁\");        lock.unlock();    &#125;&#125;\n\n公平/非公平锁公平锁：按顺序获得锁，先来先得\n非公平锁：竞争锁时，不管谁先来，谁先抢到算谁的\n\n1234// 非公平锁private static ReentrantLock lock = new ReentrantLock();// 公平锁private static ReentrantLock lock = new ReentrantLock(true);\n\n阻塞/非阻塞获取锁阻塞：lock()\n非阻塞：tryLock()\n\n条件变量newCondition()\nawait()\nsignal()\nsignalAll()\n\n1234567891011121314151617181920212223242526272829303132public class TestThread &#123;    private static ReentrantLock lock = new ReentrantLock();    private static Condition condition = lock.newCondition();    @Test    public void test1() throws ExecutionException, InterruptedException &#123;        Thread thread = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    lock.lock();                    System.out.println(\"等待条件\");                    condition.await();                    System.out.println(\"条件满足了\");                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125; finally &#123;                    lock.unlock();                &#125;            &#125;        &#125;);        thread.start();        TimeUnit.SECONDS.sleep(5);        lock.lock();        System.out.println(\"给出信号\");        condition.signal();        lock.unlock();    &#125;&#125;\n\nReentrantLock原理ReentrantLock底层使用了AQS来实现。\n公平/非公平锁原理ReentrantLock内部使用了两个同步器\nNonfairSync实现非公平锁\nFairSync实现公平锁\n\n\n非公平锁调用流程\nReentrantLock.lock()调用同步器的acquire\n\n123public void lock() &#123;    sync.acquire(1);&#125;\n\nAbstractQueuedSynchronizer.acquire()调用tryAcquire()\nNonfairSync中调用了nonfairTryAcquire()\n123456static final class NonfairSync extends Sync &#123;    private static final long serialVersionUID = 7316153563782823691L;    protected final boolean tryAcquire(int acquires) &#123;        return nonfairTryAcquire(acquires);    &#125;&#125;\n\n非公平的原因就是判断锁可获取时不管自己是不是在等待队列的队头，都直接获取锁，即不按照排队顺序，允许插队\n123456789101112131415161718192021222324252627@ReservedStackAccessfinal boolean nonfairTryAcquire(int acquires) &#123;    // 获取当前线程    final Thread current = Thread.currentThread();    // 获取当前状态    int c = getState();    // c == 0说明没有加锁    if (c == 0) &#123;        // CAS设置state为1，进行加锁        if (compareAndSetState(0, acquires)) &#123;            // 设置当前排他锁拥有者为当前线程            setExclusiveOwnerThread(current);            return true;        &#125;    &#125;    // 已经加锁了    else if (current == getExclusiveOwnerThread()) &#123;        // 当前排他锁拥有者为当前线程，这里进行锁重入        // state改成重入数        int nextc = c + acquires;        if (nextc &lt; 0) // overflow            throw new Error(\"Maximum lock count exceeded\");        setState(nextc);        return true;    &#125;    return false;&#125;\n\n公平锁调用流程\nReentrantLock.lock()调用同步器的acquire\n\nAbstractQueuedSynchronizer.acquire()调用tryAcquire()\nFairSync.tryAcquire()加锁前先看队列中是否有在排队的前驱结点，不插队\n\n1234567891011121314151617181920212223242526@ReservedStackAccessprotected final boolean tryAcquire(int acquires) &#123;    // 当前线程    final Thread current = Thread.currentThread();    // 获取状态    int c = getState();    // 未加锁    if (c == 0) &#123;        // 判断队列中是否有在排队的前驱节点        if (!hasQueuedPredecessors() &amp;&amp;            // 没人排队，这时候才进行加锁            compareAndSetState(0, acquires)) &#123;            setExclusiveOwnerThread(current);            return true;        &#125;    &#125;    else if (current == getExclusiveOwnerThread()) &#123;        // 锁重入        int nextc = c + acquires;        if (nextc &lt; 0)            throw new Error(\"Maximum lock count exceeded\");        setState(nextc);        return true;    &#125;    return false;&#125;\n\n可重入原理用state代表重入数。\n重入：state数量加1\n重入的时候解锁流程\n重入数减1，当重入数为0时才解锁。\n12345678910111213141516@ReservedStackAccessprotected final boolean tryRelease(int releases) &#123;    // 重入次数减1    int c = getState() - releases;    // 非排他锁拥有者不能解锁    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free = false;    // 当重入数减为0的时候才释放锁    if (c == 0) &#123;        free = true;        setExclusiveOwnerThread(null);    &#125;    setState(c);    return free;&#125;\n\n可打断原理见AQS中对可打断的分析。\n锁超时原理见AQS中对锁超时的分析。\n阻塞/非阻塞获取锁阻塞调用lock时会调用acquire方法，此时若获取不到锁会进入到AQS的方法acquireQueued中的死循环，并且阻塞住。\n非阻塞调用tryLock时会调用tryAcquire方法，判断当前获取不到锁直接返回。\n条件变量原理利用AQS中的Condition等待队列。\n","plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之ReentrantLock/"},{"title":"Java并发之死锁","date":"2020-02-12T14:25:23.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-03-16T15:30:48.408Z","content":"","plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之死锁/"},{"title":"Java并发之生产者消费者模式","date":"2020-02-12T14:25:02.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-03-16T15:30:48.408Z","content":"生产者消费者模式简介生产者消费者模式下，生产者和消费者共用一个有限容量的缓冲区，生产者负责生产数据，存入缓冲区，而消费者负责从缓冲区中拿出数据。\n\n\n阻塞\n缓冲区满时：生产者尝试添加数据时会阻塞，一直到缓冲区有空位\n缓冲区空时：消费者尝试从缓冲区中取数据会阻塞，一直到缓冲区有数据\n生产者消费者模式实现其实就是要实现一个阻塞队列，支持带阻塞的入队和出队操作。\n无超时阻塞队列该实现下，会一直阻塞直到操作成功。\n使用synchronized对缓冲区elementData加锁\n使用了保护性暂停模式，防止虚假唤醒\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class BlockingQueue&lt;T&gt; &#123;    private static final int DEFAULT_CAPACITY = 10;    private Queue&lt;T&gt; elementData;    private int capacity;    public BlockingQueue() &#123;        this(DEFAULT_CAPACITY);    &#125;    public BlockingQueue(int capacity) &#123;        this.capacity = capacity;        this.elementData = new LinkedList&lt;&gt;();    &#125;    public void offer(T data) &#123;        synchronized (elementData) &#123;            while (elementData.size() &gt;= capacity) &#123;                try &#123;                    elementData.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            elementData.offer(data);            elementData.notifyAll();        &#125;    &#125;    public T poll() &#123;        synchronized (elementData) &#123;            while (elementData.size() &lt;= 0) &#123;                try &#123;                    elementData.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            T data = elementData.poll();            elementData.notifyAll();            return data;        &#125;    &#125;&#125;\n\n带超时阻塞队列使用带超时的保护性暂停模式\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798class BlockingQueue&lt;T&gt; &#123;    private static final int DEFAULT_CAPACITY = 10;    private Queue&lt;T&gt; elementData;    private int capacity;    public BlockingQueue() &#123;        this(DEFAULT_CAPACITY);    &#125;    public BlockingQueue(int capacity) &#123;        this.capacity = capacity;        this.elementData = new LinkedList&lt;&gt;();    &#125;    public void offer(T data) &#123;        synchronized (elementData) &#123;            while (elementData.size() &gt;= capacity) &#123;                try &#123;                    elementData.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            elementData.offer(data);            elementData.notifyAll();        &#125;    &#125;    public void offer(T data, long mills) throws InterruptedException &#123;        long startMills = System.currentTimeMillis();        long millsWaited = 0;        synchronized (elementData) &#123;            while (elementData.size() &gt;= capacity) &#123;                long millsToWait = mills - millsWaited;                try &#123;                    if (millsToWait &gt; 0)                        elementData.wait(millsToWait);                    else                        throw new InterruptedException();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                millsWaited = System.currentTimeMillis() - startMills;            &#125;            elementData.offer(data);            elementData.notifyAll();        &#125;    &#125;    public T poll() &#123;        synchronized (elementData) &#123;            while (elementData.size() &lt;= 0) &#123;                try &#123;                    elementData.wait();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            T data = elementData.poll();            elementData.notifyAll();            return data;        &#125;    &#125;    public T poll(long mills) throws InterruptedException &#123;        long startMills = System.currentTimeMillis();        long millsWaited = 0;        synchronized (elementData) &#123;            while (elementData.size() &lt;= 0) &#123;                long millsToWait = mills - millsWaited;                try &#123;                    if (millsToWait &gt; 0)                        elementData.wait(millsToWait);                    else                        throw new InterruptedException();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                millsWaited = System.currentTimeMillis() - startMills;            &#125;            T data = elementData.poll();            elementData.notifyAll();            return data;        &#125;    &#125;&#125;","plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之生产者消费者模式/"},{"title":"Java并发之变量的线程安全分析","date":"2020-02-12T14:24:30.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-03-16T15:30:48.408Z","content":"","plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之变量的线程安全分析/"},{"title":"Java并发之Synchronized","date":"2020-02-12T14:24:04.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-03-16T15:30:48.408Z","content":"临界区程序运行时会有许多的共享资源，有些线程需要对资源进行读，有些线程需要对线程进行写，此时需要一种互斥机制来限制对共享资源的访问。在操作系统中我们学习了使用信号量来对临界区进行上锁，还学习了管程的一些知识，本篇介绍Java中的synchronized关键字，其底层便是使用管程进行实现。\n1234567891011121314151617181920212223242526public class Main &#123;    private static int counter = 0;    public static void main(String[] args) throws InterruptedException &#123;        // 开启十个线程        for (int i = 0; i &lt; 10; i++) &#123;            // 每个线程把counter加10次1            new Thread(() -&gt; &#123;                for (int j = 0; j &lt; 10; j++) &#123;                    //--------临界区------------                    counter++;                    //-------------------------                    try &#123;                        Thread.sleep(500);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;).start();        &#125;        Thread.sleep(6000);        // 最终结果大部分时候小于100        System.out.println(counter);    &#125;&#125;\n\n\n\nSynchronized使用方法同步代码块语法\n123synchronized(对象)&#123;    临界区&#125;\n\n在counter例子中，由于在访问共享资源counter时没有进行互斥处理，所以导致出现了线程安全问题，这里我们使用synchronized关键字来保护临界区。\n12345678910111213141516171819202122232425262728public class Main &#123;    private static int counter = 0;    // 锁对象    private static Object lock = new Object();    public static void main(String[] args) throws InterruptedException &#123;        for (int i = 0; i &lt; 10; i++) &#123;            new Thread(() -&gt; &#123;                for (int j = 0; j &lt; 10; j++) &#123;                    //--------临界区------------                    synchronized (lock)&#123;                        counter++;                    &#125;                    //-------------------------                    try &#123;                        Thread.sleep(500);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;).start();        &#125;        Thread.sleep(6000);        // 最终结果为100        System.out.println(counter);    &#125;&#125;\n\n同步方法非静态方法\n非静态同步方法使用本类实例作为锁对象。\n12345678910111213public class Main &#123;    public synchronized void method()&#123;            &#125;&#125;// 相当于public class Main &#123;    public void method()&#123;        synchronized(this)&#123;                    &#125;    &#125;&#125;\n\n静态方法\n静态同步方法使用本类Class对象作为锁对象。\n12345678910111213public class Main &#123;    public synchronized static void method()&#123;            &#125;&#125;// 相当于public class Main &#123;    public void method()&#123;        synchronized(Main.class)&#123;                    &#125;    &#125;&#125;\n\nSynchronized使用案例一个卖票的窗口总共十张票，我们让十五个线程来每个线程买一张票。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Main &#123;    public static void main(String[] args) throws InterruptedException &#123;        // 一共十张票        TicketWindow window = new TicketWindow(10);        // 十五个线程每个线程买一张        for (int i = 0; i &lt; 15; i++) &#123;            new Thread(new Runnable() &#123;                @Override                public void run() &#123;                    int num = window.sell(1);                    System.out.println(\"[\" + Thread.currentThread().getName() + \"]: 买到了\" + num + \"张票\");                &#125;            &#125;, \"Thread\" + i).start();        &#125;        Thread.sleep(1000);    &#125;&#125;class TicketWindow&#123;    private int numTickets;    public TicketWindow(int numTickets) &#123;        this.numTickets = numTickets;    &#125;    public int getNumTickets() &#123;        return numTickets;    &#125;    /**     * 买票     * @param num 买多少张票     * @return - &gt; 0：买到的票的数目     *         - = 0：没买到票     */    public synchronized int sell(int num)&#123;        if(numTickets &gt; 0)&#123;            int sold = Math.min(numTickets, num);            numTickets -= sold;            return sold;        &#125;        return 0;    &#125;&#125;\n\nSynchronized原理Java对象头普通对象\n\n数组对象\n\nKclass Word这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。\nMark Word用于存储对象的一些运行时信息，如hashcode，gc分代年龄，锁信息等。\n\n\n重量级锁管程Monitor每个Java对象都可以通过将对象头的Mark Word的前30位替换成指向Monitor的指针来关联一个Monitor对象。\n\n\nOwner\n当一个线程对该对象进行了synchronized(obj)操作后，该线程就成为了该Monitor中的Owner，可以进入临界区。\nEntryList\n当Monitor已经有Owner后，若另外一个线程执行synchronized(obj)操作，则线程会发生阻塞，进入EntryList进行等待。\n当Owner执行完临界区的代码或进入WaitSet后，此时会唤醒EntryList中的线程来竞争锁。\nWaitSet\n当一个线程是该Monitor的Owner，并且它调用了wait方法等待其他资源，则该线程会放弃Owner身份，进入WaitSet等待notify唤醒。\n\n\n自旋优化自旋其实意思就是重复尝试，当线程获取不到重量级锁时，可进行几次自旋（再次尝试获取锁），如果获取成功，则避免了进入阻塞，等待唤醒，减少了上下文切换，若自旋失败则进入EntryList阻塞。\n\n\n注意事项\n自旋要是和Owner线程一起执行的才有意义，即只有在多核CPU上自旋才有意义。\nJava 6 之后自旋的次数是自适应的。\nJava 7 之后不能控制是否开启自旋功能。\n轻量级锁应用场景但一个对象虽然有多个线程要加锁，但是加锁的时间大部分是错开的，若每次都使用重量级锁进行加锁，则无用的开销太大，此时可以使用轻量级锁来进行优化。轻量级锁对用户是透明的。\n加锁当使用synchronized(obj)操作后，该线程的帧栈中会创建一个锁记录，其中包含了\n锁记录的地址\n锁对象的地址\n\n\n此时会尝试使用CAS将锁记录地址与锁对象Mark Word的前30个字节进行交换。\nCAS成功\n对象头中存储了锁记录的地址和00，表示该线程给该对象加上了轻量级锁。\n\n\n\n\nCAS失败\n若其他线程已经对该对象加了轻量级锁，则进入锁膨胀过程。\n若是自己已经对该对象加了轻量级锁，则发生锁重入过程。\n解锁尝试使用CAS恢复锁对象的Mark Word\nCAS成功\n解锁成功。\nCAS失败\n说明已经发生了锁膨胀，进入重量级锁解锁流程。\n锁膨胀为锁对象申请Monitor，让锁对象指向Monitor。\n\n\n自己进入Monitor的EntryList等待锁。\n\n\n锁重入再添加一条Lock Record，其中锁记录地址为null，用来作为重入计数\n当解锁时若有锁记录地址为null的Lock Record则删除它，重入数减1。\n若Lock Record的锁记录地址不为null，则使用CAS将锁对象的Mark Word恢复。\n\n\n\n偏向锁应用场景当一个对象有多个线程要加锁，但是大部分时候只有一个线程使用，此时若每次还进行CAS操作加轻量级锁，则也有很多无用的开销，此时可使用偏向锁进行优化。偏向锁需要开启之后使用，开启后对象头Mark Word的biased_lock位为1。\n\n\n延迟开启偏向锁\n偏向锁默认是延迟开启的，可使用-XX:BiasedLockingStartupDelay=0来关闭延迟。\n加锁","plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之Synchronized/"},{"title":"Java并发之保护性暂停模式","date":"2020-02-12T14:23:30.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-03-16T15:30:48.408Z","content":"","plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之保护性暂停模式/"},{"title":"Java并发之线程状态","date":"2020-02-12T14:22:22.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-03-16T15:30:48.408Z","content":"","plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之线程状态/"},{"title":"Java并发之线程的常用方法","date":"2020-02-12T14:22:11.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-03-16T15:30:48.411Z","content":"总结\n方法名static功能注意\n\nstart()启动新线程，调用run方法不能多次start\n\nrun()不会启动新线程，执行run方法不会启动新线程\n\njoin()t.join()，则当前线程等待t线程运行结束\n\njoin(long)t.join()，则当前线程等待t线程运行结束，最多等待n毫秒\n\ngetId()获取线程idid唯一\n\ngetName()获取线程名称\n\nsetName(String)修改线程名称\n\ngetPriority()获取线程优先级1-10，从低到高\n\nsetPriority(int)设置线程优先级1-10，从低到高，但是这个没有绝对作用。\n\ngetState()获取线程状态。NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED\n\nisInterrupted()判断线程是否被打断不会清除打断标记\n\ninterrupted()static判断当前线程是否被打断会清除打断标记\n\ninterrupt()打断该线程打断join，wait，sleep方法的线程会抛出InterruptedException，并且会清除打断标记。打断正常运行的线程会设置打断标记\n\nisAlive()判断线程是否存活\n\ncurrentThread()static获取当前线程\n\nsleep(long n)static休眠n毫秒，让出CPU\n\nyield()static让出CPU不一定真的会让出，若无其他线程要运行\n\nisDaemon()判断当前线程是否为守护线程\n\nsetDaemon(boolean)设置是否为守护线程\n","thumbnail":"post/Java/Java语言/Java并发/Java并发之线程的常用方法/cover.png","plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之线程的常用方法/"},{"title":"Java并发之线程的创建与运行","date":"2020-02-12T14:21:55.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-03-16T15:30:48.408Z","content":"继承Thread继承Thread类\n重写run方法\n用start方法开启线程\n12345678910111213public class Main &#123;    public static void main(String[] args) &#123;        Thread t = new MyThread();        t.start();    &#125;&#125;class MyThread extends Thread &#123;    @Override    public void run() &#123;        System.out.println(\"run\");    &#125;&#125;\n\n实现Runnable接口实现Runnable接口\n重写run方法\n用start方法开启线程\n1234567891011121314public class Main &#123;    public static void main(String[] args) &#123;        Thread t = new Thread(new MyRunnable());        t.start();    &#125;&#125;class MyRunnable implements Runnable&#123;    @Override    public void run() &#123;        System.out.println(\"run\");    &#125;&#125;\n\n匿名内部类方式一\n1234567891011public class Main &#123;    public static void main(String[] args) &#123;        Thread t = new Thread()&#123;            @Override            public void run() &#123;                System.out.println(\"run\");            &#125;        &#125;;        t.start();    &#125;&#125;\n\n方式二\n1234567891011public class Main &#123;    public static void main(String[] args) &#123;        Thread t = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(\"run\");            &#125;        &#125;);        t.start();    &#125;&#125;\n\nFutureTask配合Thread该方式可以获得线程运行返回的结果。\n创建FutureTask对象\n使用FutureTask对象创建线程\n用start方法开启线程\n用FutureTask对象的get方法获取结果\n12345678910111213141516public class Main &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123;            @Override            public Integer call() throws Exception &#123;                System.out.println(\"run\");                return 1;            &#125;        &#125;);        Thread t = new Thread(task);        t.start();        Integer result = task.get();        System.out.println(result);    &#125;&#125;\n\n","thumbnail":"post/Java/Java语言/Java并发/Java并发之线程的创建与运行/cover.png","plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之线程的创建与运行/"},{"title":"MySQL主从复制","date":"2020-02-12T08:31:43.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-02-12T13:19:15.969Z","content":"MySQL主从复制原理工作线程Binary Log Dump线程\n主节点上的该线程用于将数据更改写到本机上的二进制日志bin-log中。\nI/O线程\n从节点上的该线程用于从主节点上读取二进制日志，并写入本机的中继日志relay log中。\nSQL线程\n从节点上的该线程用于读取中继日志，解析数据更改，并在从节点上进行重放。\n\n\n复制模式异步模式slave主动连接master，获取bin-log，不能保证数据的强一致性。该模式为默认的模式。\n同步模式主节点和从节点全部commit之后才会向客户端返回成功，可保证数据的强一致性。\n半同步模式主节点只要等到一个从节点的commit之后就会执行commit，否则会等到超时之后切换成异步模式再提交。该模式不是内置的，需要安装插件。\nMySQL主从复制配置主节点配置文件重启服务。\n1234567891011[mysqld]# idserver-id=1# 二进制日志文件log-bin=/var/lib/mysql/mysql-bin# 错误记录文件log-error=/var/lib/mysql/mysql-error# 主从复制时同步的数据库binlog-do-db=test# 主从复制时忽略的数据库# binlog-ignore-db=mysql\n\n授权从节点1GRANT REPLICATION SLAVE ON *.* TO 'root'@'192.168.31.202' IDENTIFIED BY 'Lq18851195070.';\n\n查看主节点状态记录下两个字段，配置从节点需要用。\nFile\nPosition\n1show master status;\n\n\n\n防火墙配置这里直接关闭防火墙。\n1systemctl stop firewalld.service\n\n\n\n从节点配置文件重启服务。\n123456789[mysqld]# idserver-id=2# 二进制日志文件log-bin=/var/lib/mysql/mysql-bin# 错误记录文件log-error=/var/lib/mysql/mysql-error# 主从复制时同步的数据库replicate-do-db=test\n\n授权主节点1234567CHANGE MASTER TOMASTER_HOST = '192.168.31.201',MASTER_USER = 'root',MASTER_PASSWORD = 'Lq18851195070.',MASTER_PORT = 3306,master_log_file = 'mysql-bin.000001',master_log_pos = 154;\n\n开启主从同步1start slave;\n\n查看同步状态主要看两个属性是否为yes\nSlave_IO_Running\nSlave_SQL_Running\n1show slave status \\G;\n\n\n\n处理错误观察到Last_IO_Error说主从节点有一样的UUID，查看/usr/lib/mysql.auto.cnf发现果然一样（由于是复制的虚拟机）。解决办法为停止从节点的mysqld服务，删除它的auto.cnf文件，再启动数据库服务即可。\n","thumbnail":"post/数据库/MySQL/MySQL主从复制/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/MySQL主从复制/"},{"title":"MySQL锁机制","date":"2020-02-12T08:31:24.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-03-11T16:08:41.973Z","content":"锁分类根据操作读锁\n即共享锁，锁定时其他会话可以进行读，但不能写。\n写锁\n即排他锁，锁定时其他会话不能进行读，也不能进行写。\n根据范围表锁\n锁定一张表。开销小，加锁快，不会出现死锁，锁定的粒度大，容易发生冲突，并发度低。\n行锁\n只锁定一行数据。开销大，加锁慢，会出现死锁，锁定的粒度小，不容易发生冲突，并发度高。\n页锁\nTODO\n表锁加锁后的行为若对表T进行加锁的会话是A。\n读锁\n\n读：表T写：表T读：其他表写：其他表\n\n会话A允许不允许不允许不允许\n\n其他会话允许不允许允许允许\n写锁\n\n读：表T写：表T读：其他表写：其他表\n\n会话A允许允许不允许不允许\n\n其他会话不允许不允许允许允许\n锁操作读锁加锁\n1lock table 表名 read;\n\n解锁\n1unlock tables;\n\n写锁加锁\n1lock table 表名 write;\n\n解锁\n1unlock tables;\n\n查看锁定状态查看哪些表加了锁\n1show open tables;\n\n\n\n查看锁定表数量\nTable_locks_immediate未被上锁的表的数量\nTable_locks_waited被上锁的表的数量\n1show status like 'table%';\n\n\n\n行锁加锁后的行为若对行T进行加锁的会话是A。\n读锁\n\n读：行T写：行T读：其他行写：其他行\n\n会话A允许允许允许允许\n\n其他会话允许不允许允许允许\n写锁\n\n读：行T写：行T读：其他行写：其他行\n\n会话A允许允许允许允许\n\n其他会话允许不允许允许允许\n锁操作加锁隐式加锁\n自动加锁。\n显示加锁\nfor update\n上排他锁。\n1select * from 表名 for update\n\nlock in share mode\n上共享锁。\n1select * from 表名 lock in share mode\n\n解锁提交事务或者回滚事务时解除锁定。\n不同存储引擎的锁模式MyISAM采用表锁。\n查询时自动给涉及的所有表加读锁。\n更新时自动给涉及的表加写锁。\n因为是一次性获取所需要的全部锁，所以不会产生死锁。\nInnoDB锁种类InnoDB使用行锁与表锁共存。\n行锁\n共享锁\n排他锁\n表锁\n意向共享锁事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。\n\n意向排他锁事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。\n\n锁模式兼容意向锁之间不冲突。\n表被意向共享锁锁定后不能加排他锁。\n表被意向排他锁锁定后不能加排他锁和共享锁。\n\n\n锁操作加锁隐式加锁\n意向锁由InnoDB自动加。\nUPDATE, DELETE, INSERT操作InnoDB自动加排他锁。\nSELECT语句InnoDB不会自动加任何锁。\n显示加锁\nfor update\n上排他锁。\n1select * from 表名 for update\n\nlock in share mode\n上共享锁。\n1select * from 表名 lock in share mode\n\n解锁锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。\n间隙锁当语句带有范围时，如update people set name = &#39;p&#39; where id &lt; 4, 此时若加行锁，则id为1,2,3的行都会加上行锁，若id为2的行不存在，也会加上行锁。\n目的\n解决幻读\nInnoDB行锁实现InnoDB行锁是通过给索引上的索引项加锁来实现的。\n只有通过索引检索数据时才加行锁，否则直接用表锁\n死锁问题TODO\n","thumbnail":"post/数据库/MySQL/MySQL锁机制/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/MySQL锁机制/"},{"title":"5-SQL优化之索引优化","date":"2020-02-12T08:30:35.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-03-05T10:14:55.751Z","content":"建立索引的原则建立索引\n主键自动建立索引\n频繁作为查询条件的字段应该创建索引\n查询中与其他表关联的字段应该创建索引\n不建立索引\n频繁更新的字段不建立索引\nWhere条件用不到的字段不建立索引\n表记录太少不建立索引\n索引优化的一些原则复合索引最佳左前缀原则使用复合索引时不要跳列进行查询，否则会导致需要回表查询。\n建表\n123456create table people(\tid int primary key auto_increment,    name varchar(50) not null,    age int not null,    hobby varchar(50) not null)engine=innodb default charset=utf8;\n\n插入数据\n12345insert into people(name, age, hobby) values('p1', 18, 'soccer'),('p2', 19, 'tennis'),('p3', 20, 'swimming'),('p4', 21, 'bike');\n\n建立复合索引\n1create index ind on people(name, age, hobby);\n\n符合最佳左前缀原则进行查询\n1explain select id from people where name = 'p1' and age = 18 and hobby='soccer';\n\ntype为ref，rows为1，Extra为using index，索引全部用上，效果很好。\n\n\n1explain select id from people where hobby='soccer' and name = 'p1' and age = 18;\n\n打乱顺序也没有关系。\n\n\n不符合最佳左前缀原则进行查询\n1explain select id from people where age = 18 and hobby='soccer';\n\n缺了带头大哥name，出现了using where回表查询，rows为4。\n\n\n1explain select id from people where name = 'p1' and hobby='soccer';\n\n却了中间的跟班小弟age，出现了using where回表查询。\n\n\nOrder By优化order by和where保持一致保持一致可以避免using filesort。\n1explain select id from people where id = 1 order by name;\n\n此处where中使用的是id，然而排序使用的是name，带来了using filesort。\n\n\n1explain select id from people where id = 1 order by id;\n\n此处where中使用的是id，排序也使用的是id，无using filesort。\n\n\nusing filesort优化using filesort有两种算法，当max_length_for_sort_data太低时，MySQL会切换到双路排序，因此可以调大max_length_for_sort_data。\n双路排序：MySQL4.1之前默认使用\n单路排序：MySQL4.1之后默认使用\n多表查询优化小表驱动大表MySQL连接模式\nMySQl使用的连接算法为Nest Loop Join，伪代码如下\n123456789# Pesudo code for# select A.text, B.text where A.ID = B.IDforeach (rowA in A)&#123;    if (existsInBRowWithID(rowA.id)    &#123;        ...    &#125;&#125;\n\n驱动表\n在循环外层的表称为驱动表。\n驱动表选择\nLeft Join时左表为驱动表\nRight Join时右表为驱动表\nJoin时MySQL会选择小表作为驱动表查看explain第一张被查询的表就是驱动表\n\n连接优化\n小表驱动大表时，效果最好。\n连接次数少\n表锁定次数少\n表连接时的索引\n驱动表不会使用索引\n驱动表有索引的话会用到索引\n外连接索引对于左外连接，给左表加索引。\n对于右外连接，给右表加索引。\n子查询优化exists与in对于\n1select ... from table where exists/in (子查询)\n\n主查询数据较多，使用in。\n子查询数据较多，使用exists。\n覆盖索引所谓覆盖索引就是要查询的字段全部都在索引之中，无需回表查询。\n1234# 回表select * from people where id = 1;# 不覆盖索引select id from people where id = 1;\n\n索引失效情况避免在索引上进行计算在索引上进行任何计算（计算，函数，类型转换）都会导致索引失效。\n先删除people表的复合索引。\n1drop index ind on people;\n\n1explain select id from people where id + 1 = 2;\n\n对主键索引id进行计算，索引失效。\n\n\n避免在索引上使用不等于1explain select id from people where id != 1;\n\n对主键索引id进行不等于操作，索引失效。\n\n\n避免在索引上使用判空12explain select id from people where id is null;explain select id from people where id is not null;\n\n\n\n避免在索引上使用范围查询和in12explain select id from people where id &gt; 2;explain select id from people where id in (1, 2);\n\n\n\n避免在索引上使用以%开头的模糊查询在name上建立索引。\n1create index ind on people(name);\n\n12explain select id from people where name like '%p%';drop index ind on people;\n\n\n\n避免在索引上使用or1explain select id from people where id = 1 or id = 2;\n\n","thumbnail":"post/数据库/MySQL/5-SQL优化之索引优化/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/5-SQL优化之索引优化/"},{"title":"4-SQL优化之排查方法","date":"2020-02-12T08:30:19.000Z","date_formatted":{"ll":"Feb 12, 2020","L":"02/12/2020","MM-DD":"02-12"},"updated":"2020-03-05T10:08:06.045Z","content":"慢查询日志MySQL提供了慢查询日志来记录响应时间超过阈值的SQL语句，默认是关闭的。\n查询是否打开\n1show variables like '%slow_query_log%';\n\n\n\n查询阈值\n默认为10秒。\n1show variables like '%long_query_time%';\n\n\n\n临时开启开启\n1set global slow_query_log = 1;\n\n\n\n设置阈值\n需要重新登录后生效。\n1set global long_query_time = 3;\n\n测试\n1select sleep(4);\n\n\n\n永久开启永久开启需要改写配置文件/etc/my.cnf，重启服务。\n1234[mysqld]slow_query_log = 1slow_query_log_file = /var/lib/mysql/localhost-slow.loglong_query_time = 3\n\n\n\nProfile使用MySQL的profile可以记录所有SQL语句的记录，并进行消耗时间的查看，默认是关闭的。\n查询是否打开\n1show variables like '%profiling%';\n\n\n\n打开\n1set global profiling = 1;\n\n\n\n查看\nQuery_ID\nDuration\nQuery\n1show profiles;\n\n\n\n精确分析\n精确分析每一条语句耗时的详情。\n1show profile all for query 查询的ID（Query_ID）;\n\n\n\n全局查询日志记录开启之后的全部SQL语句，默认关闭。\n查看是否开启\n1show variables like '%general_log%';\n\n\n\n打开\n1set global general_log = 1;\n\n设置记录在表中\n查询记录会记录在mysql.general_log表中\n1set global log_output = 'table';\n\n\n\n设置记录在文件中\n12set global log_output = 'file';set global general_log_file = '/tmp/general.log';\n\n","thumbnail":"post/数据库/MySQL/4-SQL优化之排查方法/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/4-SQL优化之排查方法/"},{"title":"Flexbox布局","date":"2020-02-11T13:43:37.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-02-11T14:08:12.398Z","content":"结构\n\nContainer属性display指定布局为flexbox布局。\n123.container &#123;  display: flex;&#125;\n\nflex-direction指定item排布的顺序。\n123.container &#123;  flex-direction: row | row-reverse | column | column-reverse;&#125;\n\nrow\n从左到右。默认。\n\n\nrow-reverse\n从右到左。\n\n\ncolumn\n从上到下。\n\n\ncolumn-reverse\n从下到上。\n\n\nflex-wrap指定如何换行。\n123.container&#123;  flex-wrap: nowrap | wrap | wrap-reverse;&#125;\n\nnowrap\n不换行。默认\n\n\nwrap\n换行，新的一行在下面。\n\n\nwrap-reverse\n\n\n换行，新的一行在上面。\njustify-content123.container &#123;  justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly | start | end | left | right ... + safe | unsafe;&#125;\n\n指定行内item在水平方向上如何排布。\n\n\nspace-around\n弹性盒子元素会平均地分布在行里，两端保留子元素与子元素之间间距大小的一半。\nspace-evenly\n弹性盒子元素会平均地分布在行里，没两个子元素间的距离都一样。\nalign-items指定行内item在垂直方向上如何排布。\n123.container &#123;  align-items: stretch | flex-start | flex-end | center | baseline | first baseline | last baseline | start | end | self-start | self-end + ... safe | unsafe;&#125;\n\n\n\nalign-content指定不同行之间如何排布。\n123.container &#123;  align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch | start | end | baseline | first baseline | last baseline + ... safe | unsafe;&#125;\n\n\n\nItem属性order用于指定子元素排布在行内的顺序。数值小的排在前面，可以为负值。\n123.item &#123;  order: &lt;integer&gt;; /* default is 0 */&#125;\n\nflex-growTODO\nflex-shrinkTODO\nflex-basisTODO\nalign-self用于覆盖父容器指定的align-items。\n参考文档A Complete Guide to Flexbox\n\nFlexbox布局详解\n\n","plink":"https://beginc.github.io/post/Web/CSS/Flexbox布局/"},{"title":"3-SQL优化之Explain","date":"2020-02-11T06:59:12.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-03-05T10:13:25.044Z","content":"Explain使用方法explain SQL语句，如explain select * from account\n\n\n字段id该字段用于表示多张表被处理的顺序。\nid相同\n处理顺序由上至下。数据库小的表会优先处理，因为优先处理小表产生的中间表较小，占用内存少。\n\n\n\n\nid不同\nid越大越先被处理。\n\n\nselect_type表示查询的种类。\nSIMPLE\n简单查询，无子查询，无Union。\n\n\nPRIMARY\n带子查询的主查询。\n\n\nDERIVED\n衍生查询，在查询的时候用到了临时表。\n在from子查询中只有一张表。\n在from子查询中只有一张表，如果有table1 union table2，则table1就是DERIVED。\n此查询本应该是DERIVED，但在MySQL5.7中对SQL进行了改写，消除了子查询。\n\n\n可用show warnings查看。\n\n\n\n\nUNION\n\n\nUNION RESULT\n\n\ntable表名。\npartitionsTODO\ntype指示索引使用的情况。性能排序为:\n1system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all\n\nsystem\n只有一条数据的系统表的查询。\n\n衍生表只有一条记录的主查询。\n\n这里本来应该是system，但是由于MySQL5.7消除了子查询，所以为const。\n\n\nconst\n仅仅能查到一条数据的查询。用于Primary Key或者Unique索引。\n\n\n注意需要是在主键索引或唯一索引上的查询。\n\n\neq_ref\n当该表为被驱动表时，对于驱动表返回的每一行数据在该表中都有且只有一条数据与其匹配\n在比较的字段上必须建立了唯一性索引或者主键索引。\n123456789foreach (rowA in A)&#123;    if (existsInBRowWithID(rowA.id)    &#123;        // 直接按索引查找对应行        addToResult(rowA.text, getRowInBWithID(rowA.id).text);        break;    &#125;&#125;\n\n在aid字段上建立唯一索引。\n\n\n此时，对于people中每个aid都在account中有唯一匹配，所以是eq_ref。\n\n\n\n\n\n\n但是，如果people中如果多了一条数据，在account中没有匹配，则不是eq_ref。先在aid字段上换成普通索引。然后插入一条aid为3的数据，最后进行查询。\n\n\nref\n当该表为被驱动表时，对于驱动表返回的每一行数据在该表中都可能有多条数据与其匹配。\n在比较的字段上建立的是非唯一索引或者使用到了联合索引的最左前缀\n\n\nrange\n范围查询。\n!=也可以\n\n\n当in后包含所有的索引键，则失效。\n\n\nindex\n查询全部索引中的数据，不需要查表。\n\n\nall\n查询全部表中的数据。\n\n\npossible_keys可能用到的索引，不准确。\n\n\nkey实际用到的索引。\n\n\nkey_len索引的长度。用于判断复合索引是否被完全使用。\n给people表添加复合索引。\n\n\n计算方式\n考虑编码UTF-8:：1个字符3个字节\nGBK：1个字符2个字节\nLatin：1个字符1个字节\n\n考虑是否可以为NULL可以为NULL则添加1个字节用于标识\n\n考虑是否长度可变若长度可变则添加2个字节标识\n\n按uname进行查询。varchar(50) + UTF-8 + 非空，则为3 * 50 + 2 = 152\n\n\n按uname和aid进行查询。aid为int，占用4个字节。\n\n\n未按最左前缀原则进行书写，只用到了aid索引。\n\n\nref指明当前表所参照的字段。\n\n\n参照常量。\n\n\nrows MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数，越低越好。\n根据主键id对account进行查询，有索引，只需扫描一条记录。\n\n\n根据balance对account进行查询，无索引，需扫描全部两条记录。\n\n\nfilteredTODO\nExtrausing filesort\n需要额外的一次排序，性能消耗较大。\n对于单索引，如果排序和查找用的是同一个字段，则无需额外的一次排序。\n对于复合索引，若查找和排序符合最佳左前缀原则，则无需额外的一次排序。\nwhere和order by不用同一个字段\n\n\nwhere和order by用同一个字段\n\n\n创建(id, uname, aid)上的复合索引\n\n\n按最佳左前缀原则查询\n1explain select id from people where id = 1 order by uname;\n\n不按最佳左前缀原则查询\n1explain select id from people where id = 1 order by aid;\n\nusing index\n覆盖索引，不用读取数据文件，只从索引文件中获取数据。\n\n\nusing where\n需要回表查询。\n","thumbnail":"post/数据库/MySQL/3-SQL优化之Explain/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/3-SQL优化之Explain/"},{"title":"2-SQL优化之索引原理","date":"2020-02-11T06:58:57.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-03-05T08:16:25.637Z","content":"索引分类单列索引单列索引即在单个字段上建立索引。\n普通索引允许有重复值\n允许有NULL\n主键索引不允许有重复值\n不允许有NULL\n唯一索引不允许有重复值\n允许有NULL\n复合索引在表中的多个字段组合上创建的索引。\n全文索引MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引。\nMySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引。\n只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。\n空间索引MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。必须使用 GIS 相关的函数来维护数据。\n索引结构B+TreeM阶B-Tree特点\n若根节点不是终端节点，则至少有两颗子树（即至少一个关键字）。\n每个结点至多有M棵子树（即至多M - 1个关键字）。\n除根节点外的所有非叶节点至少有ceil(M / 2)棵子树（即至少包含ceil(M / 2) - 1个关键字）。\n所有非叶节点的结构类似如下:\n123 |P1|K1|P2|K2|P3|  &#x2F;     |      \\Child  Child  Child\n\n所有叶子节点出现在同一层次，不带任何信息，表示查找失败。\n\n\n\n\nM阶B+Tree特点\n与B-Tree不同的点有：\n结点中每个关键字 对应一颗子树。\n\n每个结点至多有M棵子树（即至多M个关键字）。\n\n除根节点外的所有非叶节点至少有ceil(M / 2) 棵子树（即至少包含ceil(M / 2)个关键字）。\n\n所有非叶节点不包含信息，只包含对应子树的最大关键字和指向该子树的指针，仅仅起索引作用。\n\n叶节点包含了全部关键字，叶子节点的指针指向记录存储的地址。\n\n所有叶子节点连接成一个单链表，有一个指针指向关键字最小的叶子节点。\n\n\n\n\n\nB+Tree的优点\n查找效率高。\n相对于B-Tree，B+Tree具有有序性，适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。\n复合索引下B+Tree的结构\nTODO\nHashHash索引优点\n查找效率高，O(1)。\nHash索引缺点\n无法用于排序和分组。\n无法用于区间查找。\nMySQL索引索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。\nMyISAM非聚簇索引非聚簇索引指指索引项的排序方式和表中数据记录排序方式不一致的索引。\n一张表分三个文件存储。数据和索引分开存储。\n\n文件内容\n\n表名.frm存储表结构\n\n表名.MYD存储行数据\n\n表名.MYI存储索引\n索引结构MyISAM使用B+Tree作为索引结构，在叶子结点上存储指向记录的指针。\n\n\n\n\nInnoDB聚簇索引非聚簇索引指指索引项的排序方式和表中数据记录排序方式一致的索引。\n一张表分两个文件存储。数据和索引存储在一个文件中。\n\n文件内容\n\n表名.frm存储表结构\n\n表名.idb存储行数据和索引\n如果一个主键被定义了，那么这个主键就是作为聚集索引。\n如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引。\n如果没有主键也没有合适的唯一索引，那么InnoDB内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，该列的值会随着数据的插入自增。\n索引结构InnoDB使用B+Tree作为索引结构，在叶子结点上直接存储了行数据。\n\n\n\n\nMySQL索引操作建立索引普通索引\n123CREATE INDEX 索引名称 ON 表名(列名);或者ALTER TABLE 表名 ADD INDEX 索引名称(列名);\n\n唯一索引\n123CREATE UNIQUE INDEX 索引名称 ON 表名(列名);或者ALTER TABLE 表名 ADD UNIQUE INDEX 索引名称(列名);\n\n主键索引\n1ALTER TABLE 表名 ADD PRIMARY KEY (列名)\n\n删除索引删除普通/唯一索引\n123DROP INDEX 索引名称 ON 表名;或ALTER TABLE 表名 DROP INDEX 索引名称;\n\n删除主键\n1ALTER TABLE 表名 DROP PRIMARY KEY;\n\n查看索引1SHOW INDEX FROM 表名;\n\n\n\n","thumbnail":"post/数据库/MySQL/2-SQL优化之索引原理/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/2-SQL优化之索引原理/"},{"title":"1-SQL优化之SQL解析顺序","date":"2020-02-11T06:58:35.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-02-11T07:41:24.189Z","content":"手写SQL顺序1234567select &lt;&gt;from &lt;&gt;on &lt;&gt;where &lt;&gt;group by &lt;&gt;having &lt;&gt;order by &lt;&gt;\n\nSQL解析顺序","thumbnail":"post/数据库/MySQL/1-SQL优化之SQL解析顺序/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/1-SQL优化之SQL解析顺序/"},{"title":"MySQL存储引擎","date":"2020-02-11T06:57:49.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-02-11T07:36:34.014Z","content":"存储引擎简介MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。\nMySQL支持的所有引擎\n\n\n\nInnoDB\n功能支持\n\n外键完整性约束支持\n\n事务支持\n\n锁行锁\n\n缓存缓存索引和表数据\n支持高并发。\nMyISAM\n功能支持\n\n外键完整性约束不支持\n\n事务不支持\n\n锁表锁\n\n缓存缓存索引\n","thumbnail":"post/数据库/MySQL/MySQL存储引擎/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/MySQL存储引擎/"},{"title":"MySQL常用命令","date":"2020-02-11T06:57:39.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-03-05T10:09:11.512Z","content":"show databases查询所有数据库\n\nuse dbName使用数据库\n\nshow engines查询所有存储引擎\n\nset global设置全局变量\n重启服务后失效\n新开的会话有效\n\nset session当前会话有效\n\n","thumbnail":"post/数据库/MySQL/MySQL常用命令/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/MySQL常用命令/"},{"title":"Linux下MySQL核心目录","date":"2020-02-11T06:57:09.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-02-12T12:56:03.615Z","content":"数据库目录\n/var/lib/mysql/\n配置文件\n/etc/my.cnf\n日志文件\n/var/log/mysqld.log\n","thumbnail":"post/数据库/MySQL/Linux下MySQL核心目录/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/Linux下MySQL核心目录/"},{"title":"CentOS7下MySQL5.7安装","date":"2020-02-11T06:55:21.000Z","date_formatted":{"ll":"Feb 11, 2020","L":"02/11/2020","MM-DD":"02-11"},"updated":"2020-02-11T07:14:44.209Z","content":"下载安装文件下载链接\n下载链接\n\n\n\n\n核心组件\ncommon\nlibs\nclient\nserver\n\n\n\n\n解决包冲突12rpm -e postfixrpm -e mariadb-libs\n\n安装安装顺序\ncommon\nlibs\nclient\nserver\n1234567rpm -ivh /opt/mysql-community-common-5.7.29-1.el7.x86_64.rpm  rpm -ivh /opt/mysql-community-libs-5.7.29-1.el7.x86_64.rpmrpm -ivh /opt/mysql-community-client-5.7.29-1.el7.x86_64.rpmrpm -ivh /opt/mysql-community-server-5.7.29-1.el7.x86_64.rpm\n\n更改Root密码查看初始临时密码\n1cat &#x2F;var&#x2F;log&#x2F;mysqld.log  | grep &quot;temporary password&quot;\n\n\n\n/var/log/mysqld.log无内容解决方法\n删除原来安装过的mysql残留的数据\n1rm -rf /var/lib/mysql\n\n\n\n重启mysqld服务\n1systemctl restart mysqld.service\n\n更改Root密码\n1set password=password(\"密码\")\n\n开启MySQL远程连接注意防火墙端口是否开放。\n123mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'USERNAME'@'%' IDENTIFIED BY 'PASSWORD' WITH GRANT OPTION;mysql&gt; FLUSH PRIVILEGES;\n\n","thumbnail":"post/数据库/MySQL/CentOS7下MySQL5-7安装/cover.png","plink":"https://beginc.github.io/post/数据库/MySQL/CentOS7下MySQL5-7安装/"},{"title":"Vagrant自动虚拟机部署","date":"2020-02-08T09:25:26.000Z","date_formatted":{"ll":"Feb 8, 2020","L":"02/08/2020","MM-DD":"02-08"},"updated":"2020-02-08T09:32:09.938Z","content":"Vagrantfile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- mode: ruby -*-# vi: set ft=ruby :# 三台虚拟机boxes = [  &#123;    # 主机名    :hostname =&gt; \"master\",    # IP地址    :ip =&gt; \"192.168.31.201\",    # 分配的内存    :mem =&gt; \"2048\",    # CPU核心    :cpu =&gt; \"1\"  &#125;,  &#123;    :hostname =&gt; \"node1\",    :ip =&gt; \"192.168.31.103\",    :mem =&gt; \"2048\",    :cpu =&gt; \"1\"  &#125;,  &#123;    :hostname =&gt; \"node2\",    :ip =&gt; \"192.168.31.104\",    :mem =&gt; \"2048\",    :cpu =&gt; \"1\"  &#125;]Vagrant.configure(\"2\") do |config|  # 使用centos/7 Box  config.vm.box = \"centos/7\"  # Box版本  config.vm.box_version = \"1905.1\"  boxes.each do |opts|    config.vm.define opts[:hostname] do |config|      config.vm.hostname = opts[:hostname]      config.vm.provider \"virtualbox\" do |v|        v.customize [\"modifyvm\", :id, \"--memory\", opts[:mem]]        v.customize [\"modifyvm\", :id, \"--cpus\", opts[:cpu]]      end      # 设置共有网络，静态IP      config.vm.network \"public_network\", ip: opts[:ip]    end  end  # 安装wget工具  config.vm.provision \"shell\", privileged: true, inline: \"yum install wget -y\"end\n\n虚拟机管理\n命令作用\n\nvagrant up部署启动虚拟机\n\nvagrant suspend挂起虚拟机\n\nvagrant halt关机\n\nvagrant destroy撤销虚拟机一切资源\n存在的问题 TODO目前只能用vagrant ssh进行登录，不能通过正常的SSH进行登录，这样就无法使用Ansible进行自动化运维。\n","thumbnail":"post/自动化运维/Vagrant自动虚拟机部署/cover.png","plink":"https://beginc.github.io/post/自动化运维/Vagrant自动虚拟机部署/"},{"title":"7-Ansible执行速度优化","date":"2020-02-07T13:24:27.000Z","date_formatted":{"ll":"Feb 7, 2020","L":"02/07/2020","MM-DD":"02-07"},"updated":"2020-02-08T02:54:03.698Z","content":"优化一：开启SSH长连接Ansible使用SSH和远程主机进行通信, 所以Ansible对SSH的依赖性非常强, 在OpenSSH 5.6版本以后SSH就支持了Multiplexing。所以如果Ansible中被控端的SSH 版本高于5.6时, 我们可以直接在ansible.cfg文件中设置SSH长连接。\n123[ssh_connection]# ControlPersist=5d意思为SSH长连接持续5天ssh_args = -C -o ControlMaster=auto -o ControlPersist=5d\n\n优化二：开启PipeliningPipelining也是OpenSSH的一个特性, 在Ansible的整个执行流程中, 把生成好的本地Python脚本PUT到远程服务器. 如果开启了Pipelining, 这个过程将在SSH会话中进行, 这样可以大大提高整个执行效率.当然开启Pipelining, 需要被控机/etc/sudoers文件编辑当前Ansible的SSH用户的配置为requiretty. 否则在执行Ansible的时候会提示报错.\n优化三：开启accelerate模式已经废弃了。\n","thumbnail":"post/自动化运维/Ansible/8-Ansible执行速度优化/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/8-Ansible执行速度优化/"},{"title":"6-Ansible常用Playbook关键字","date":"2020-02-07T12:59:22.000Z","date_formatted":{"ll":"Feb 7, 2020","L":"02/07/2020","MM-DD":"02-07"},"updated":"2020-02-08T02:58:38.816Z","content":"用于Playhosts指定主机列表。\n123---# 指定主机列表为mq组内所有主机- hosts: mq\n\nremote_user指定远程执行命令的用户。\n12345---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root\n\ngather_facts指定是否收集主机信息。\n12345678---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  vars_files:    - vars.yml  gather_facts: no\n\npre_tasks在tasks之前执行的task。\n12345678---- hosts: all  gather_facts: no  pre_tasks:    - debug: msg=pre  tasks:    - debug: msg=task\n\npost_tasks在tasks之后执行的task。\n12345678910---- hosts: all  gather_facts: no  pre_tasks:    - debug: msg=pre  tasks:    - debug: msg=task  post_tasks:    - debug: msg=post\n\n用于Taskchanged_when用于设置何时任务“发生了改变”，需要重新执行。\n1234567891011---- hosts: all  gather_facts: no    tasks:    - debug: msg=task    - name: check if $ROCKET_HOME exists      shell: cat /etc/bashrc      register: bashrc      # 指定该任务总是需要执行      changed_when: True\n\ncheck_mode设置了该模式的命令只会预测在主机上执行结果，而不会真正的执行。\n1234567---- hosts: all  gather_facts: no    tasks:    - shell: echo hello      check_mode: yes\n\nenvironment可用来设置环境变量。\n1234567- hosts: all  gather_facts: no    tasks:    - shell: echo $var &gt; ~/test.txt      environment:        var: 123\n\nignore_errors指定是否忽略命令出错，继续向下执行。\n123- name: this will not be counted as a failure  command: /bin/false  ignore_errors: yes\n\nfailed_when指定命令什么情况下算执行失败。\n1234- name: Fail task when the command error output prints FAILED  command: /usr/bin/example-command -x -y -z  register: command_result  failed_when: \"'FAILED' in command_result.stderr\"\n\nregister将命令执行的返回值注册成一个变量。可在后续使用。\n123456789---- name: check if $ROCKET_HOME exists  shell: cat /etc/bashrc  register: bashrc  changed_when: True- name: append $ROCKET_HOME  shell: echo ROCKET_HOME=/usr/local/&#123;&#123; unarchive_filename &#125;&#125; &gt;&gt; /etc/bashrc; echo PATH='$PATH:$ROCKET_HOME'/bin &gt;&gt; /etc/bashrc  when: not bashrc.stdout is search(\"ROCKET_HOME\")\n\nloop用于执行循环。和with_*不同，该循环不依赖插件。\n12345678- name: add several users  user:    name: \"&#123;&#123; item &#125;&#125;\"    state: present    groups: \"wheel\"  loop:     - testuser1     - testuser2\n\nwith_items用于执行循环。\n1234- name: with_items  debug:    msg: \"&#123;&#123; item &#125;&#125;\"  with_items: \"&#123;&#123; items &#125;&#125;\"\n\nwith_indexed_items带索引的循环。item.0为索引，item.1为值。\n1234- name: with_indexed_items  debug:    msg: \"&#123;&#123; item.0 &#125;&#125; - &#123;&#123; item.1 &#125;&#125;\"  with_indexed_items: \"&#123;&#123; items &#125;&#125;\"","thumbnail":"post/自动化运维/Ansible/7-Ansible常用Playbook关键字/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/7-Ansible常用Playbook关键字/"},{"title":"5-Ansible之Jinja2语法","date":"2020-02-07T12:34:09.000Z","date_formatted":{"ll":"Feb 7, 2020","L":"02/07/2020","MM-DD":"02-07"},"updated":"2020-02-08T02:53:58.099Z","content":"变量12345# 直接使用&#123;&#123; var &#125;&#125;# 做运算&#123;&#123; var * 2 &#125;&#125;\n\n控制结构判断12345&#123;%if var == 10 %&#125;    等于10&#123;% else %&#125;    不等于10&#123;% endif %&#125;\n\n去除前导空字符\n使用-去除前导空字符\n12345&#123;%- if var == 10 -%&#125;    等于10&#123;%- else -%&#125;    不等于10&#123;%- endif -%&#125;\n\n循环123&#123;% for i in range(var) %&#125;    &#123;&#123; i &#125;&#125;&#123;% endfor %&#125;\n\n过滤器使用过滤器可对变量或常量做一些处理。使用管道符|进行传递。\n123456# Abc&#123;&#123; \"abc\" | capitalize   &#125;&#125;# 1&#123;&#123; [1, 2, 3] | first &#125;&#125;# 12&#123;&#123; \"12\" | int &#125;&#125;\n\nAnsible中所有的过滤器见Filter。\n测试过滤器会对变量做一些处理后返回，而测试主要是进行一些判断，返回布尔值。\n1234# True&#123;&#123; 1 is eq 1 &#125;&#125;# False&#123;&#123; var is defined &#125;&#125;\n\nAnsible中所有的测试见Test。\nAnsible之When在when中我们可以使用Jinja2语法进行模板书写，但是要注意的是，我们引用变量不用写{{}}。通常我们可以搭配register注册变量进行使用。register将命令的返回值存储到注册的变量当中。\n123456789---- name: check if $ROCKET_HOME exists  shell: cat /etc/bashrc  register: bashrc  changed_when: True- name: append $ROCKET_HOME  shell: echo ROCKET_HOME=/usr/local/&#123;&#123; unarchive_filename &#125;&#125; &gt;&gt; /etc/bashrc; echo PATH='$PATH:$ROCKET_HOME'/bin &gt;&gt; /etc/bashrc  when: not bashrc.stdout is search(\"ROCKET_HOME\")\n\n","thumbnail":"post/自动化运维/Ansible/6-Ansible之Jinja2语法/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/6-Ansible之Jinja2语法/"},{"title":"4-Ansible之导入","date":"2020-02-07T11:57:43.000Z","date_formatted":{"ll":"Feb 7, 2020","L":"02/07/2020","MM-DD":"02-07"},"updated":"2020-02-08T02:53:55.231Z","content":"Ansible复用在ansible中，task, var, handler到playbook和role都是可以进行复用的，因此我们需要类似于Java中import的机制来对复用组件进行导入。\n动态导入与静态导入在Ansible中include_*为动态导入，import_*为静态导入。\n区别\n静态导入相当于C语言中的预处理，它在解析Playbook时进行处理，而不是在运行时。\n动态导入在运行时进行处理时才进行导入。\n在使用when对include_*和import_*处理时，行为有些许不同。\n12345# common_tasks.yml- name: placeholder foo  command: /bin/foo- name: placeholder bar  command: /bin/bar\n\nimport_tasks静态导入。\n123456789# main.yml- import_tasks: other_tasks.yml  when: x is not defined # other_tasks.yml- set_fact:    x: foo- debug:    var: x\n\n在预处理后相当于给other_tasks.yml中的每一个task都加上了when语句，造成只有一个任务执行了，不符合我们的预期。\n12345678# 该任务会执行，因为初始情况下x未定义- set_fact:    x: foo  when: x is not defined# 该任务不会执行，因为执行了上面的任务后，x已经定义了- debug:    var: x  when: x is not defined\n\ninclude_tasks动态导入\n该处的when只控制导入的这个行为是否发生，因此第一个任务和第二个任务都会得到执行。\n123456789# main.yml- include_tasks: other_tasks.yml  when: x is not defined # other_tasks.yml- set_fact:    x: foo- debug:    var: x\n\n各种导入include_*include_tasks动态导入任务。\n12345678- hosts: all  tasks:\t# 和普通命令一样使用    - name: Include task list in play      include_tasks: stuff.yaml    # 可使用vars传入变量      vars:      \tname: lhw\n\ninclude_role动态导入角色。\n1234567891011---- hosts: all  tasks:    # 和普通命令一样使用    - include_role: name=role_A    # 可使用vars传入变量      vars:        name: maurice        age: 100    - import_role:        name: role_B\n\nimport_*import_tasks用法同include_tasks\nimport_role用法同include_role\nimport_playbook用于在一个Playbook中导入另一个Playbook的Play，且只能在顶层Playbook中导入，不能在tasks中导入\n12345678910111213141516- hosts: localhost  tasks:    - debug:        msg: play1# 导入Playbook- name: Include a play after another play  import_playbook: otherplays.yaml# 错误导入方法，不能在tasks中导入- name: This DOES NOT WORK  hosts: all  tasks:    - debug:        msg: task1    - name: This fails because I'm inside a play already      import_playbook: stuff.yaml\n\n\n\n","thumbnail":"post/自动化运维/Ansible/5-Ansible之导入/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/5-Ansible之导入/"},{"title":"3-Ansible之Roles","date":"2020-02-06T14:06:26.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:53:52.261Z","content":"Roles简介Roles可以层次性、结构化地组织Playbook，对重复的部分进行复用，实现更为复杂的任务。\nRoles目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051site.ymlwebserver.ymldbserver.ymlgroup_vars/\tall/\tgroup1/\tgroup2/host_vars/\t192.168.31.101/\t192.168.31.102/roles/    dbserver/        # 存放各种任务        tasks/        \tmain.yml        # 存放各种handler        handlers/        \tmain.yml        # 存放文件        files/        # 存放模板文件        templates/        # 存放变量定义文件        vars/        \tmain.yml        # 存放默认变量        defaults/        \tmain.yml        # 存放角色依赖关系        meta/        \tmain.yml    webserver/        # 存放各种任务        tasks/        \tmain.yml        # 存放各种handler        handlers/        \tmain.yml        # 存放文件        files/        # 存放模板文件        templates/        # 存放变量定义文件        vars/        \tmain.yml        # 存放默认变量        defaults/        \tmain.yml        # 存放角色依赖关系        meta/        \tmain.yml\n\nTasks该目录可以存放各种任务文件，还必须包含一个main.yml来组织起目录下各个任务的执行。\n使用include_tasks来导入。\ntasks/task1.yml\n123---- name: task1  shell: echo hello\n\ntasks/task2.yml\n123---- name: task1  shell: echo hello\n\ntasks/main.yml\n12- include_tasks: task1.yml- include_tasks: task2.yml\n\n\n\nHandlers该目录可以存放各种包含handler的文件，还必须包含一个main.yml。\n使用include来导入\nhandlers/handler1.yml\n123---- name: handler1  shell: echo handler1\n\nhandlers/handler2.yml\n123---- name: handler2  shell: echo handler2\n\nhandlers/main.yml\n123---- include: handler1.yml- include: handler2.yml\n\nfiles该目录用于存放文件，放在该文件夹里的文件可以使用文件名直接引用。\ntemplates该目录用于存放模板文件，放在该文件夹里的模板文件可以使用文件名直接引用。\nvars该目录用于存放变量定义文件，在此处定义过的变量可以直接引用。\n方式一：所有变量定义都放在vars/main.yml中123---name: lhwage: 18\n\n方式二：变量定义在vars/main目录下的YAML文件中该方式可以将变量分成多个文件进行定义。\nvars/main/var1.yml\n1name: lhw\n\nvars/main/var2.yml\n1age: 18\n\ndefaults该目录用于存放默认变量定义文件，在此处定义过的默认变量可以直接引用。默认变量不同的地方是，它的优先级最低，任何其他地方定义的变量优先级都高于它。\n方式一：所有变量定义都放在defaults/main.yml中同vars\n方式二：变量定义在vars/main目录下的YAML文件中同vars\nmeta用于存放角色间的依赖关系，例如rocketmq-broker角色要想执行其任务，必须先有Java的环境，因此该角色依赖于Java角色。\n在dependencies中定义，可为依赖的角色传入参数。\n123---dependencies:  - &#123; role: java arg1: \"123\", arg2: \"456\"&#125;\n\ngroup_vars该方式用于定义组变量，效果和在/etc/ansible/hosts中定义组变量效果相同，但是其优先级高于/etc/ansible/hosts中的组变量。\n方式一：组变量定义在group_vars/组名.yml中group_vars/broker.yml\n该文件里定义的变量只能由broker组使用。\n12---brokerName: broker\n\ngroup_vars/namesrv.yml\n该文件里定义的变量只能由namesrv组使用。\n12---port: 9876\n\ngroup_vars/all.yml\n该文件里定义的变量可由所有组使用。\n12---msg: global\n\n\n\n方式二：组变量定义在group_vars/组名/目录下的YAML文件中这种方式允许我们将一个组的变量定义在不同的文件中。\nhost_vars该方式用于定义主机变量，效果和在/etc/ansible/hosts中定义主机变量效果相同，但是其优先级高于/etc/ansible/hosts中的主机变量。\n方式一：主机变量定义在host_vars/主机名.yml中同group_vars。\n方式二：主机变量定义在host_vars/主机名/目录下的YAML文件中同group_vars。\n使用Roles在与roles目录同级的地方定义Playbook，使用定义好的角色。\ndbserver.yml\n12345678---- hosts: dbserver  remote_user: root  gather_facts: no  roles:  \t# 直接使用    - dbserver\n\nwebserver.yml\n123456789101112---- hosts: webserver  remote_user: root  gather_facts: no  roles:  \t# 使用多个角色  \t# 传参给角色    - role: dbserver      port: 3306    - role: webserver      port: 8080\n\n","thumbnail":"post/自动化运维/Ansible/4-Ansible之Roles/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/4-Ansible之Roles/"},{"title":"3-Ansible之Playbook","date":"2020-02-06T10:30:24.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:53:49.407Z","content":"Playbook简介Playbook通过YAML配置的方式，组织多个命令的执行，完成一系列复杂的任务。\nPlaybook核心元素常用通用信息hosts指定主机列表。\n123---# 指定主机列表为mq组内所有主机- hosts: mq\n\nremote_user指定远程执行命令的用户。\n12345---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root\n\ngather_facts指定是否收集主机信息。\n12345678---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  vars_files:    - vars.yml  gather_facts: no\n\n\n\n任务指定一系列任务。\n123456789101112131415161718192021---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  task:      # name指定任务名称    - name: Create a file      # 模块名：参数      file: path=~/hello.txt state=touch      # 指定sudo用户      sudo_user: test      # 使用sudo执行      sudo: yes      # 若执行错误，是否忽略，继续往下执行      ignore_errors: True      # 指定标签      tags:        - tag1        - tag2\n\n变量Playbook变量来源命令行中定义变量使用-e定义变量。此种方式定义的变量优先级最高。\n1ansible-playbook -e 'filename=hello.txt' playbook.yml\n\nhosts文件中定义变量组变量\n123456[mq]192.168.31.101192.168.31.102[mq:vars]filename=hello.txt\n\n主机变量\n优先级高于组变量。\n123456[mq]192.168.31.101 filename=another.txt192.168.31.102[mq:vars]filename=hello.txt\n\n独立的变量YAML文件中定义变量标准的变量定义文件应该放在vars目录下，则可以直接引用。\nvars/vars.yml\n1filename: hello.txt\n\nplaybook.yml\n12345678910111213---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  vars_files:    - vars.yaml  task:      # name指定任务名称    - name: Create a file      # 模块名：参数      file: path=~/&#123;&#123; filename &#125;&#125; state=touch\n\nPlaybook中定义变量使用vars定义变量。\n12345678910111213---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  vars:    filename: hello.txt  task:      # name指定任务名称    - name: Create a file      # 模块名：参数      file: path=~/&#123;&#123; filename &#125;&#125; state=touch\n\n调用setup模块的变量setup模块用于收集远程机器信息，可直接使用其变量，这种变量称为facts。\n1234567891011---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  task:      # name指定任务名称    - name: Create a file      # 模块名：参数      file: path=~/&#123;&#123; ansible_fqdn &#125;&#125; state=touch\n\n处理器有些时候我们希望一些命令执行后才通知其他一些命令执行，如配置文件发生改变，重新进行了分发时，我们希望重启服务。此时我们需要使用handlers和notify\n1234567891011121314151617# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  vars:    filename: hello.txt  task:      # name指定任务名称    - name: Create a file      # 模块名：参数      file: path=~/&#123;&#123; filename &#125;&#125; state=touch      notify:        - Create another file  handlers:    - name: create another file      file: path=~/another_&#123;&#123; filename &#125;&#125; state=touch\n\n模板有时候我们希望根据主机的一些信息动态进行配置文件编写，此时我们需要使用模板技术，Ansible使用Jinja2语言提供模板技术。\n模板文件template命令来分发配置文件src模板文件路径\ndest目标路径\nbackup是否备份\ngroup\nowner\nmode\n\n模板文件应以.j2结尾\nplaybook.yml\n123456789101112131415---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  vars:    items:      - C      - Java      - Python  task:      # name指定任务名称    - name: Distribute conf file      template: src=conf.j2 dest=~/conf\n\n模板文件templates/conf.j2\n模板文件放在标准目录templates下，可直接引用。\nfor进行循环\nif进行判断\n1234567# 若定义了该变量则执行&#123;% if items is defined %&#125;  # 循环写入  &#123;% for item in items %&#125;    &#123;&#123; item &#125;&#125;  &#123;% endfor%&#125;&#123;% endif %&#125;\n\nwhen条件测试，当为真时才执行命令。\n在任务中指定when, when支持Jinja2语法\n123456789101112---# 指定主机列表为mq组内所有主机- hosts: mq  # 远程以root用户运行  remote_user: root  task:      # name指定任务名称    - name: Create a file      file: path=~/hello.txt state=touch      # 当主机ip为192.168.31.101时，才创建文件      when: ansible_all_ipv4_addresses == \"192.168.31.101\"\n\nansible-playbook命令使用直接运行一个Playbook\n1ansible-playbook playbook.yml\n\n检查运行一个Playbook\n只检测可能会发生的改变，但不真正执行操作。\n1ansible-playbook -C playbook.yml\n\n指定其他参数\n--list-hosts列出运行任务的主机\n--list-tags列出playbook文件中定义所有的tags\n--list-tasks列出playbook文件中定义的所有task\n--limit只针对主机列表中的某个主机或者某个组执行\n-f指定并发数，默认为5个\n-t指定tags运行，运行某一个或者多个tags的任务\n-v显示过程-vv, -vvv更详细\nPlaybook示例运行RocketMQ NameServer集群\n1234567891011121314151617181920212223242526272829---- hosts: mq  remote_user: root  vars:    archive_filename: rocketmq-all-4.6.0-bin-release.zip    unarchive_filename: rocketmq-all-4.6.0-bin-release    tasks:    - name: copy      copy: src=&#123;&#123; archive_filename &#125;&#125; dest=/opt    - name: unzip      unarchive:        src: /opt/&#123;&#123; archive_filename &#125;&#125;        dest: /usr/local        creates: /usr/local/&#123;&#123; unarchive_filename &#125;&#125;        remote_src: yes    - name: rename      shell:        cmd: mv /usr/local/&#123;&#123; unarchive_filename &#125;&#125; /usr/local/rocketmq        creates: /usr/local/rocketmq    - name: check env      shell: ls /etc/bashrc      register: bashrc      changed_when: True    - name: set env      shell: echo PATH='$PATH':/usr/local/rocketmq/bin &gt;&gt; /etc/bashrc      when: not bashrc.stdout is search('PATH=$PATH:/usr/local/rocketmq/bin')    - name: start name server      shell: nohup mqnamesrv &gt; /dev/null 2&gt;&amp;1 &amp;\n\n","thumbnail":"post/自动化运维/Ansible/3-Ansible之Playbook/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/3-Ansible之Playbook/"},{"title":"2-Ansible模块","date":"2020-02-06T08:39:32.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:53:46.404Z","content":"模块概述Ansible内置了许多模块，每一个模块都对应着在被控端的一些操作。\nAnsible可使用ansible来调用模块。\n调用格式1ansible 主机模式 -m 模块名 -a 参数 ansible参数\n\nansible参数\n--version显示版本\n1ansible --version\n\n-k提示输入SSH连接密码\n\n-K提示输入sudo的密码\n\n-C进行检查，并不真实执行模块\n\n-T执行命令的超时时间\n\n-u远程执行的用户\n\n主机模式\n192.168.31.101单独一个主机\n组名组内所有主机\nall所有主机\n192.168.31.10*通配符\ngroup1:group2组1或组2内的主机都匹配\ngroup1:&amp;group2同时在组1和组2的主机匹配\ngroup1:!group2在组1但不在组2的主机匹配\n192.168.10[1:2]正则表达式\n常用模块command默认模块，若不加-m 模块名，则默认执行该模块。\n该模块用于执行一些Shell命令，但该模块不能执行一些带有特殊符号的命令，如|, &lt;, &gt;, ;, &amp;等。\n参数\nchdir执行命令前先进入某个目录\ncreates判断文件是否存在，若存在则不执行\nremoves判断文件是否存在，若存在则执行\n示例\n1ansible mq -m command -a 'removes=/etc/hosts chdir=/etc/ cat ./hosts'\n\n\n\nShellcommand模块的升级版，支持特殊符号。\nCopy用于将文件从主控端复制到被控端。\n参数\nsrc源文件（软连接文件会复制源文件）\ndest目的文件\nbackup若目的文件存在是否进行备份\ncontent手动指定内容\ngroup文件属组\nowner文件所有者\nmode文件权限（如0777，前面需要加0）\nremote_srcno将本机上的文件分发到远程主机\nyes复制远程主机上的文件\n\n示例\n1ansible mq -m copy -a 'src=./hello.txt dest=~/hello.txt mode=0777'\n\nFetch用于抓取远程机器上的文件。\n参数\nsrc要复制的文件\ndest本机用于保存文件的目录\n示例\n1ansible mq -m fetch -a 'src=~/hello.txt dest=./fetch'\n\nFile创建、删除文件 对文件权限进行修改。\n参数\npath要操作的文件路径\ngroup文件属组\nowner文件所有者\nmode文件权限\nrecurse是否递归设置\nsrc创建软连接的源\nstateabsent删除文件\ndirectory创建目录\nfile即使文件不存在，也不会创建\nlink软链接\nhard硬链接\ntouch如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间\n\n示例\n1234567891011121314151617181920ansible mq -m file -a 'path=~/hello.txt state=absent'``` ## Yum用于使用包管理器`yum`**参数**- `name`软件包名称- `state`  - `removed`删除  - `installed`安装  - `latest`升级到最新**示例**```bashansible mq -m yum -a 'name=vim state=removed'\n\nService用于管理服务。\n参数\nname服务名称\nenabled是否开机启动\nstatereloaded平滑重启\nrestarted重启\nstarted启动\nstopped停止\n\nCron管理定时任务。\n参数\nname注释信息\nminute/hour/day/month/weekday设置时间* 取值范围内的所有数字\n/ 每过多少个数字\n-从X到Z\n，并列\n\njob要执行的任务\ndisabled是否注释定时任务\nstatepresent创建定时任务\nabsent删除定时任务\n\n示例\n1ansible mq -m cron -a 'name=echo minute=*/1 hour=* day=* month=* weekday=* job=\"echo hello &gt;&gt; ~/cron.txt\" state=present'\n\nGroup创建或删除用户组信息。\n参数\nname组名称\ngid组id\nstatepresent创建组\nabsent删除组\n\nUser创建或删除用户信息。\n参数\nname用户名\npassword密码\nuid用户id\ngroup用户基本组\ngroups用户附加组\nhome用户的家目录\nsystem是否建立系统用户\nshell/bin/bash可以登陆\n/sbin/nologin无法登陆\n\nstatepresent创建\nabsent删除\n\nUnarchive用于解压。\n参数\nsrc压缩包路径\ndest远程主机上的一个路径，即文件解压的路径\ncreates若指定的文件存在，则不解压\ncopy解压前是否将文件复制到远程主机（若为no，则压缩包必须存在于远程主机上）\ngroup解压文件的属组\nowner解压文件的属主\nmode解压文件的权限\n","thumbnail":"post/自动化运维/Ansible/2-Ansible模块/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/2-Ansible模块/"},{"title":"1-Ansible入门","date":"2020-02-06T08:21:31.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:53:40.519Z","content":"环境准备主控端主控端只能是Linux主机，我们准备了一个CentOS7的虚拟机，配置IP地址为192.168.31.200\n被控端node01\nOS: CentOS7\nIP: 192.168.31.101\n\nnode02\nOS: CentOS7\nIP: 192.168.31.102\n\n配置无密SSH登录在主控端执行：\n1234ssh-key-genssh-copy-id root@192.168.31.101ssh-copy-id root@192.168.31.102\n\n\nAnsible安装Ansible属于Agentless，采用SSH协议进行工作，无需在被控端主机上安装任何软件，只要支持SSH协议即可，在主控端我们需要安装Ansible。\n安装1pip3 install ansible\n\n配置ansible.cfg\n下载https://github.com/ansible/ansible/tree/devel/examples下的ansible.cfg放到/etc/ansible目录下。\ninventory主机列表配置文件\nlibrary库文件位置\nremote_tmp执行操作时被控端暂存文件目录\nlocal_tmp执行操作时主控端暂存文件目录\nforks执行操作时的并发数\nask_pass是否每次执行都询问SSH密码\nremote_user远程登录的用户\nlog_path日志文件路径\nsudo_user默认sudo用户\nremote_port主机端口号\nhost_key_checking是否每次执行都检查key\npipeling是否打开SSH Pipeling，可大幅提高性能\nhosts\n在/etc/ansible目录下新建hosts文件。\nAnsible入门配置Inventory将两台被控机加入到/etc/ansible/hosts中\n12[mq]192.168.31.10[1:2]\n\n测试1ansible mq -m ping\n\n","thumbnail":"post/自动化运维/Ansible/1-Ansible入门/cover.png","plink":"https://beginc.github.io/post/自动化运维/Ansible/1-Ansible入门/"},{"title":"8-shiro集成Spring","date":"2020-02-06T07:29:59.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-03-06T13:44:42.727Z","content":"环境准备Maven123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;Test&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.8.0&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;11&lt;/source&gt;                    &lt;target&gt;11&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;port&gt;8080&lt;/port&gt;                    &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n依赖spring-context\nspring-web\nshiro-web\nshiro-spring\nServlet + JSP API\ncommons-logging\n1234567891011121314151617181920212223242526272829303132333435363738394041&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;        &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-logging&lt;/groupId&gt;        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;        &lt;version&gt;1.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;        &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;        &lt;version&gt;1.4.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;        &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;        &lt;version&gt;1.4.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;        &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;        &lt;version&gt;2.2.1&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;        &lt;version&gt;3.1.0&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n配置配置ShiroFilter的代理FilterDelegatingFilterProxyfilter-name为要代理的Filter在IoC容器中的名字\ntargetFilterLifecycle由于真正实现功能的Filter并未加入Servlet容器，所以生命周期方法如init, destroy也要决定是否进行代理执行\n若targetFilterLifecycle为True则会代理其进行生命周期方法的执行\n若targetFilterLifecycle为False则不会执行\n\n\n1234567891011121314151617181920212223242526&lt;!DOCTYPE web-app PUBLIC        \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"        \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;filter&gt;        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;            &lt;param-value&gt;true&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;\n\n配置SecurityManagerWeb环境下使用DefaultWebSecurityManager\n12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"&gt;    &lt;/bean&gt;    &lt;bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"&gt;        &lt;property name=\"securityManager\" ref=\"securityManager\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n配置ShiroFilterFactoryBean用于产生ShiroFilter\n12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"&gt;    &lt;/bean&gt;    &lt;bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"&gt;        &lt;property name=\"securityManager\" ref=\"securityManager\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n配置LifecycleBeanPostProcessor为DestructionAwareBeanPostProcessor，用于执行IoC容器中实现了Initializable接口或Destroyable接口的Shiro类的生命周期方法。\nInitializable：在postProcessBeforeInitialization中执行init\nDestroyable：在postProcessBeforeDestruction中执行destroy\n配置拦截规则在ShiroFilterFactoryBean中进行配置\n12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"&gt;    &lt;/bean&gt;    &lt;bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"&gt;        &lt;property name=\"securityManager\" ref=\"securityManager\"/&gt;        &lt;property name=\"filterChainDefinitionMap\"&gt;            &lt;map&gt;                &lt;entry key=\"/index.jsp\" value=\"anon\"/&gt;                &lt;entry key=\"/user.jsp\" value=\"authc, roles[user]\"/&gt;                &lt;entry key=\"/admin.jsp\" value=\"authc, perms['user:delete']\"/&gt;            &lt;/map&gt;        &lt;/property&gt;        &lt;property name=\"loginUrl\" value=\"/login.jsp\"/&gt;        &lt;property name=\"successUrl\" value=\"success.jsp\"/&gt;        &lt;property name=\"unauthorizedUrl\" value=\"/unauthorized.jsp\"/&gt;    &lt;/bean&gt;    &lt;bean class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\"&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n","thumbnail":"post/Java/Shiro/8-shiro集成Spring/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/8-shiro集成Spring/"},{"title":"7-shiro集成Web","date":"2020-02-06T07:29:51.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-03-06T13:45:01.690Z","content":"环境准备Maven配置1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;Test&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.8.0&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;11&lt;/source&gt;                    &lt;target&gt;11&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;port&gt;8080&lt;/port&gt;                    &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n导入依赖shiro-web包含shiro-core\n\nServlet + JSP API\n123456789101112131415161718192021222324&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;        &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;        &lt;version&gt;1.4.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;            &lt;groupId&gt;commons-logging&lt;/groupId&gt;            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;        &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;        &lt;version&gt;2.2.1&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;        &lt;version&gt;3.1.0&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\nShiro配置配置EnvironmentLoaderListenershiroConfigLocations指定配置文件路径\n功能\n创建唯一的Environment\n加载配置文件\n创建，配置，绑定WebSecurityManager\n1234567891011121314&lt;!DOCTYPE web-app PUBLIC        \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"        \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt;    &lt;context-param&gt;        &lt;param-name&gt;shiroConfigLocations&lt;/param-name&gt;        &lt;param-value&gt;classpath:shiro.ini&lt;/param-value&gt;    &lt;/context-param&gt;        &lt;listener&gt;        &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;&lt;/web-app&gt;\n\n配置核心ShiroFilter1234567891011121314151617181920212223&lt;!DOCTYPE web-app PUBLIC        \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"        \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt;    &lt;context-param&gt;        &lt;param-name&gt;shiroConfigLocations&lt;/param-name&gt;        &lt;param-value&gt;classpath:shiro.ini&lt;/param-value&gt;    &lt;/context-param&gt;        &lt;listener&gt;        &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;filter&gt;        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;\n\n配置拦截规则URL拦截规则\n跳转路径authc.loginUrl登录的路径\nauthc.successUrl登录成功后他的路径\nperms.unauthorizedUrl未授权时的路径\n\n1234567891011121314[users]user=123,useradmin=123,admin[roles]user=user:queryadmin=*[urls]/index.jsp=anon/user.jsp=authc, roles[user]/admin.jsp=authc, perms[\"user:delete\"][main]authc.loginUrl=/login.jspauthc.successUrl=/success.jspperms.unauthorizedUrl=/unauthorized.jsp\n\nURL拦截URL规则明确路径\n?匹配一个字符\n*匹配一级\n**匹配多级\nFilterauthc类\n org.apache.shiro.web.filter.authc.FormAuthenticationFilter\n功能\n未登陆则跳转到loginUrl\n登陆成功跳转到successUrl\n若当前未登陆且当前请求为loginUrl发来的POST请求，则尝试从request中取出如下参数尝试进行登录usernameParam：默认为username\npasswordParam：默认为password\nrememberMeParam：默认为rememberMe\n\n尝试登录成功则跳转到successUrl\n尝试登录失败则抛出异常\nuser有rememberMe的请求可通过\n否则跳转到loginUrl\nanon无需登录即可访问\nroles验证用户是否有对应角色若已经登录但无角色，则跳转到unauthorizedUrl\n若未登陆，则跳转到loginUrl\n\nperms验证用户是否有对应权限若已经登录但无角色，则跳转到unauthorizedUrl\n若未登陆，则跳转到loginUrl\n\nnoSessionCreation不创建Session\nFilter原理继承体系NamebleFilter拥有名字的过滤器\nOncePerRequestFilterpublic void setEnabled(boolean enabled)可设置是否启用该过滤器\n保证过滤器只被执行一次（执行后再request域中设置一个标记）\n\nAdviceFilter实现了AOP风格的过滤器preHandle\nexecuteChain\npostHandle\nafterCompletion\n\nPathMatchingFilter当路径匹配时才执行的过滤器\nAccessControlFilter带访问控制的过滤器\n认证过滤器\n\n授权过滤器\n\n\n\n认证过滤器原理AccessControlFilterisAccessAllowed控制是否有权限放行\n\n无权限访问则执行onAccessDenied方法\n\n都为抽象方法，这里为重要扩展点\n\n\n\n\n\n\n\n\n\nAuthenticationFilter扩展isAccessAllowed方法，只有当登陆了才有权限访问\n\n\nAuthenticatingFilter扩展了isAccessAllowed方法\n\n\n定义了executeLogin方法onLoginSuccess为扩展点\nonLoginFailure为扩展点\ncreateToken为扩展点\n\n\n\nFormAuthenticationFilter扩展了onAccessDenied，提供了登陆能力\n\n\n扩展了onLoginSuccess，登陆成功进行跳转successUrl\n\n\n扩展了onLoginFailure，登陆失败设置异常信息到request中\n\n\n扩展了createToken，从request中获取创建Token的信息\n\n\n授权过滤器原理AuthorizationFilter\n\nRolesAuthorizationFilter","thumbnail":"post/Java/Shiro/7-shiro集成Web/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/7-shiro集成Web/"},{"title":"6-shiro之Session","date":"2020-02-06T06:32:18.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:51:47.279Z","content":"Shiro Session特点Shiro采用SessionDAO来对Session进行存储，可以通过自定义SessionDAO将Session存储到不同的位置，如数据库，文件系统等。\nShiro完全实现了一套Sesssion机制，不依赖任何运行时容器，如Servlet Container。\nShiro提供了Session Listener来监听Session生命周期的各个事件。\n...\nShiro Session API1234567891011121314151617181920212223242526public interface Session &#123;    // 获取Session ID    Serializable getId();    // 获取启动Session的时间    Date getStartTimestamp();    // 获取上次交互的时间    Date getLastAccessTime();    // 获取剩余超时时间    long getTimeout() throws InvalidSessionException;    // 设置Session最大存活时间    void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException;    // 获取创建Session的主机的Host    String getHost();    // 更新lastAccessTime    void touch() throws InvalidSessionException;    // 销毁Session    void stop() throws InvalidSessionException;     // 获取属性键集合    Collection&lt;Object&gt; getAttributeKeys() throws InvalidSessionException;    // 获取属性    Object getAttribute(Object key) throws InvalidSessionException;    // 设置属性    void setAttribute(Object key, Object value) throws InvalidSessionException;    // 移除所有属性    Object removeAttribute(Object key) throws InvalidSessionException;&#125;\n\nSessionManagerShiro提供了SessionManager来对Session做统一管理，同时SessionManager又由SecurityManager进行管理。\n默认的SessionManager为DefaultSessionManager\nWeb环境下应该使用DefaultWebSessionManager\n配置globalSessionTimeout会话超时时间，默认为30分钟\nsessionListeners会话监听器\nsessionDAO会话存储DAO，默认存在内存里\nsessionValidationScheduler会话检测调度器，负责按一定规律验证并清理孤儿会话(Orphan Session)\nsessionValidationSchedulerEnabled决定会话检测调度器是否启用\ndeleteInvalidSessions决定是否删除无效的会话\nsessionValidationInterval会话检测调度器检测的时间间隔\n组件SessionListener监听的事件onStart开启Session\nonStop关闭Session\nonExpiration会话过期\n实现SessionListener实现SessionListener接口，重写三个方法。\n12345678910111213141516public class SessionListener1 implements SessionListener &#123;    @Override    public void onStart(Session session) &#123;        System.out.println(\"Session\" + session.getId() + \" started on \" + session.getHost());    &#125;    @Override    public void onStop(Session session) &#123;        System.out.println(\"Session\" + session.getId() + \" stopped on \" + session.getHost());    &#125;    @Override    public void onExpiration(Session session) &#123;        System.out.println(\"Session\" + session.getId() + \" expired on \" + session.getHost());    &#125;&#125;\n\n配置SessionListener123456789101112[users]user1=123,useruser2=456,admin[roles]user=user:queryadmin=user:*[main]listener1=cn.edu.njust.listener.SessionListener1securityManager.sessionManager.globalSessionTimeout=10000securityManager.sessionManager.sessionListeners=$listener1\n\nSessionValidationSchedulerTODO\nSessionDAOTODO\n","thumbnail":"post/Java/Shiro/6-shiro之Session/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/6-shiro之Session/"},{"title":"5-shiro加密","date":"2020-02-06T04:38:18.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:51:44.253Z","content":"敏感信息存储在数据库中存储用户的敏感信息时我们不能直接存储明文，否则万一数据库信息泄露，则用户的敏感信息会被直接窃取。\n因此我们需要将用户的敏感信息进行加密后，再存储到数据库中。而加密又可分为可逆加密和不可逆加密，我们应使用不可逆加密算法来对用户的信息进行加密。\n带加密的注册过程\n\n\n带加密的登录过程\n\n\nShiro加密方式直接加密直接对信息使用加密算法进行加密，该方式易受到暴力破解。\ninfo = encrypt(info)\n加盐加密加上一个Salt之后再进行加密。\ninfo = encrypt(info + salt)\n加盐多次迭代加密多次进行加盐和加密。\n12for _ in range(iter):    info = encrypt(info + salt)\n\nShiro加密APIMd5Hash\nSha256Hash\nSha512Hash\n123456789101112131415161718192021222324252627282930313233String password = \"123\";String salt = UUID.randomUUID().toString();int iter = 50;// 简单加密// 简单加密 ---&gt; 16进制String pwd = new Md5Hash(password).toHex();// 简单加密 ---&gt; Base64编码pwd = new Md5Hash(password).toBase64();// 加盐加密 ---&gt; Base64编码pwd = new Md5Hash(password, salt).toBase64();// 加盐多次迭代加密 ---&gt; Base64编码pwd = new Md5Hash(password, salt, iter).toBase64();// 简单加密// 简单加密 ---&gt; 16进制pwd = new Sha256Hash(password).toHex();// 简单加密 ---&gt; Base64编码pwd = new Sha256Hash(password).toBase64();// 加盐加密 ---&gt; Base64编码pwd = new Sha256Hash(password, salt).toBase64();// 加盐多次迭代加密 ---&gt; Base64编码pwd = new Sha256Hash(password, salt, iter).toBase64();// 简单加密// 简单加密 ---&gt; 16进制pwd = new Sha512Hash(password).toHex();// 简单加密 ---&gt; Base64编码pwd = new Sha512Hash(password).toBase64();// 加盐加密 ---&gt; Base64编码pwd = new Sha512Hash(password, salt).toBase64();// 加盐多次迭代加密 ---&gt; Base64编码pwd = new Sha512Hash(password, salt, iter).toBase64();\n\nShiro加密认证对密码进行加密后，则在认证时无法直接使用默认的密码比对器进行密码比对，需要使用HashedCredentialsMatcher。\n对密码进行加盐加密后，则Realm在返回AuthenticationInfo时，还需要传入加密时所加的salt。\n配置hashAlgorithmName加密算法\nhashIterations迭代次数\nhashSalted是否加盐\nstoredCredentialsHexEncoded是否是16进制编码toBase64: false\ntoHex: true\n\n12345678910[main]credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatchercredentialsMatcher.hashAlgorithmName=MD5credentialsMatcher.hashIterations=50credentialsMatcher.hashSalted=truecredentialsMatcher.storedCredentialsHexEncoded=falserealm3 = cn.edu.njust.realm.Realm3realm3.credentialsMatcher=$credentialsMatchersecurityManager.realms = $realm3\n\nRealm12345678910111213141516171819202122232425262728293031323334public class Realm3 extends AuthorizingRealm &#123;    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;        String username = (String) principals.getPrimaryPrincipal();        SimpleAuthorizationInfo info = null;        // 直接Hard Code        //  可替换成数据库操作        if (username.equals(\"user3\")) &#123;            Set&lt;String&gt; roles = new HashSet&lt;&gt;();            roles.add(\"user\");            Set&lt;String&gt; permissions = new HashSet&lt;&gt;();            permissions.add(\"user:query\");            info = new SimpleAuthorizationInfo(roles);            info.addStringPermissions(permissions);        &#125;        return info;    &#125;    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;        String username = (String) token.getPrincipal();        SimpleAuthenticationInfo info = null;        if (username.equals(\"user3\"))&#123;            // 传入salt            String salt = \"salt\";            info = new SimpleAuthenticationInfo(\"user3\", \"zjnFk4aKrdISF6OTslZKCQ==\", ByteSource.Util.bytes(salt), getName());        &#125;        return info;    &#125;&#125;\n\n测试12345678910111213141516171819202122public class Test03 &#123;    @Test    public void test03()&#123;        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");        SecurityManager securityManager = factory.getInstance();        SecurityUtils.setSecurityManager(securityManager);        Subject subject = SecurityUtils.getSubject();        UsernamePasswordToken token = new UsernamePasswordToken();        token.setUsername(\"user3\");        token.setPassword(\"123\".toCharArray());        try&#123;            subject.login(token);            System.out.println(\"登录成功\");        &#125; catch (AuthenticationException e)&#123;            System.out.println(\"登录失败\");            e.printStackTrace();        &#125;    &#125;&#125;","thumbnail":"post/Java/Shiro/5-shiro加密/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/5-shiro加密/"},{"title":"4-shiro授权","date":"2020-02-06T03:07:41.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2020-02-08T02:51:41.532Z","content":"权限管理模型权限管理模型一般抽象为User, Role, Permission模型。\nUser可以有多个Role\nRole可以有多个Permission\nPermission代表了对资源访问的权限\nPermission表示方式\n资源:操作:实例\nuser:query用户的查询权限\n\nuser:add添加用户的权限\n\nuser:query:1查询用户1的权限\n\n*:query任何资源的查询权限(只能匹配前面一级)\n\nuser:*任何用户实例的任何权限(可匹配多级)\n\n*所有权限\n\nShiro授权API角色检查返回boolean\nSubject.hasRole\nSubject.hasRoles\nSubject.hasAllRoles\n抛异常\nSubject.checkRole\nSubject.checkRoles\n权限检查返回boolean\nSubject.isPermitted\nSubject.isPermittedAll\n抛异常\nSubject.checkPermission\nSubject.checkPermissions\nShiro授权流程Subject.hasRole(&quot;user&quot;)进行认证\n\nSecurityManager调用Authorizer进行认证\n\nAuthorizer调用Realm进行授权信息查询\n\nAuthorizer根据查询到的信息判断是否有权限\n\n源码分析DelegatingSubject调用hasRole方法进行角色查询。\n\n\n没有认证则直接返回false，否则DelegatingSubject调用DefaultSecurityManager的hasRole方法进行角色查询。\n\n\nhasRole方法定义在AuthorizingSecurityManager中，调用authorizer的hasRole方法进行角色查询。\n\n\nDefaultSecurityManager的默认authorizer为ModularRealmAuthorizer，它调用所有实现了Authorizer接口的Realm的hasRole方法进行角色查询，只要有一个Realm返回true，则hasRole返回true。\n\n\nAuthorizingRealm实现了Authorizer接口，实现了hasRole方法，它调用getAuthorizationInfo进行授权信息查询，随后将信息交由hasRole的重载方法进行角色查询。\n\n\ngetAuthorizationInfo方法最终又会调用doGetAuthorizationInfo方法进行授权信息查询。\n\n\ndoGetAuthorizationInfo为抽象方法，子类需要实现该方法进行授权信息查询。\n\n\n\n授权相关组件AuthorizerAuthorizer的主要职责就是实现hasRole等方法进行权限验证。\nRealm作用由源码分析可知，只有实现了Authorizer接口的Realm才会在授权时起作用，它主要负责根据Principal进行授权信息查询。\n扩展继承AuthorizingRealm，实现doGetAuthenticationInfo方法进行认证信息查询，实现doGetAuthorizationInfo方法进行授权信息查询。\n配置同中Realm的配置。\n自定义Realm实现授权扩展Realm12345678910111213141516171819202122232425262728293031323334353637383940public class Realm2 extends AuthorizingRealm &#123;    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;        String username = (String) principals.getPrimaryPrincipal();        SimpleAuthorizationInfo info = null;        // 直接Hard Code        //  可替换成数据库操作        if (username.equals(\"user1\")) &#123;            Set&lt;String&gt; roles = new HashSet&lt;&gt;();            roles.add(\"user\");            Set&lt;String&gt; permissions = new HashSet&lt;&gt;();            permissions.add(\"user:query\");            info = new SimpleAuthorizationInfo(roles);            info.addStringPermissions(permissions);        &#125; else if (username.equals(\"user2\"))&#123;            Set&lt;String&gt; roles = new HashSet&lt;&gt;();            roles.add(\"admin\");            Set&lt;String&gt; permissions = new HashSet&lt;&gt;();            permissions.add(\"user:*\");            info = new SimpleAuthorizationInfo(roles);            info.addStringPermissions(permissions);        &#125;        return info;    &#125;    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;        String username = (String) token.getPrincipal();        SimpleAuthenticationInfo info = null;        if (username.equals(\"user1\"))            info = new SimpleAuthenticationInfo(\"user1\", \"123\", getName());        else if (username.equals(\"user2\"))            info = new SimpleAuthenticationInfo(\"user2\", \"456\", getName());        return info;    &#125;&#125;\n\n配置Realm123[main]realm2 = cn.edu.njust.realm.Realm2securityManager.realms = $realm2\n\n测试123456789101112131415161718192021222324public class Test02 &#123;    @Test    public void test01() &#123;        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");        SecurityManager securityManager = factory.getInstance();        SecurityUtils.setSecurityManager(securityManager);        Subject subject = SecurityUtils.getSubject();        UsernamePasswordToken token = new UsernamePasswordToken();        token.setUsername(\"user1\");        token.setPassword(\"123\".toCharArray());        try&#123;            subject.login(token);            System.out.println(subject.hasRole(\"user\"));            System.out.println(subject.hasRole(\"admin\"));            System.out.println(subject.isPermitted(\"user:query\"));            System.out.println(subject.isPermitted(\"user:add\"));        &#125; catch (AuthenticationException e)&#123;            System.out.println(\"登录失败\");            e.printStackTrace();        &#125;    &#125;&#125;\n\n","thumbnail":"post/Java/Shiro/4-shiro授权/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/4-shiro授权/"},{"title":"3-shiro认证","date":"2020-02-05T14:04:33.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2020-02-08T02:51:38.356Z","content":"Shiro认证APISubject.login\nSubject.logout\nShiro认证流程Subject.login(token)进行认证\n\nSecurityManager调用Authenticator进行认证\n\nAuthenticator调用Realm进行认证信息查询与比对\n\nAuthenticator根据AuthenticationStrategy决定认证是否通过\n\n源码分析DelegatingSubject调用login方法进行认证。\n\n\nDelegatingSubject调用DefaultSecurityManager的login方法进行认证。\n\n\nlogin方法定义在AuthenticatingSecurityManager中，调用authenticate方法进行认证。\n\n\nauthenticate方法定义在父类AuthenticatingSecurityManager中，调用自身的authenticator的authenticate方法进行认证。\n\n\nDefaultSecurityManager的默认authenticator为ModularRealmAuthenticator，其authenticate方法定义在父类AbstractAuthenticator中，该方法调用doAuthenticate方法进行认证。\n\n\ndoAuthenticate方法为抽象方法，要由子类实现。\n\n\nModularRealmAuthenticator重写了doAuthenticate方法，根据Realms的数量调用doSingleRealmAuthentication方法或doMultiRealmAuthentication方法。\n\n\ndoSingleRealmAuthentication直接调用Realm的getAuthenticationInfo方法进行认证信息查询和比对。\n\n\ndoMultiRealmAuthentication对多个Realm进行认证信息查询和比对，根据AuthenticationStrategy对多个结果进行聚合，决定认证是否通过。\n\n\nRealm的getAuthenticationInfo在AuthenticatingRealm中进行了实现，该方法调用doGetAuthenticationInfo方法进行认证信息查询，然后通过CredentialsMatcher进行认证信息比对，决定认证是否通过。\n\n\ndoGetAuthenticationInfo为抽象方法，子类需要实现该方法进行认证信息查询。\n\n\n认证相关组件Authenticator作用由源码分析可知，Authenticator主要职责就是实现authenticate方法进行认证。\n扩展可通过继承AbstractAuthenticator，重写doAuthenticate方法来自定义Authentiactor。\n配置123[main]authenticator = cn.edu.njust.authenticator.CustomAuthenticatorsecurityManager.authenticator = $authenticator\n\nAuthenticationStrategy作用由源码分析可知，AuthenticationStrategy主要是在有多个Realm的情况下发挥作用。\n实现AtLeastOneSuccessfulStrategy只要有一个Realm认证成功就算成功。\nFirstSuccessfulStrategy第一个Realm认证成功就算成功。\nAllSuccessfulStrategy全部Realm认证成功就算成功。\n扩展TODO\nRealm作用由源码分析可知，Realm作用就是根据查询认证信息，和token进行比对。\n扩展继承AuthenticatingRealm，实现doGetAuthenticationInfo方法。\n配置配置主要牵涉到Realm的查询顺序问题\n隐式顺序\n按声明的顺序, realm1, realm2, realm3。\n1234[main]realm1 = cn.edu.njust.realm.Realm1realm2 = cn.edu.njust.realm.Realm1realm3 = cn.edu.njust.realm.Realm1\n\n显式顺序\n按设置的顺序, realm2, realm1, realm3。\n12345[main]realm1 = cn.edu.njust.realm.Realm1realm2 = cn.edu.njust.realm.Realm1realm3 = cn.edu.njust.realm.Realm1securityManager.realms = $realm2, $realm1, $realm3\n\n\n自定义Realm实现认证扩展Realm123456789101112131415public class Realm1 extends AuthenticatingRealm &#123;    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;        String username = (String) token.getPrincipal();        SimpleAuthenticationInfo info = null;        // 此处直接Hard Code        // 可以换成数据库查询操作        if (username.equals(\"user1\"))            info = new SimpleAuthenticationInfo(\"user1\", \"123\", getName());        else if(username.equals(\"user2\"))            info = new SimpleAuthenticationInfo(\"user2\", \"456\", getName());        return info;    &#125;&#125;\n\n配置Realm123[main]realm1 = cn.edu.njust.realm.Realm1securityManager.realms = $realm1\n\n测试123456789101112131415161718192021public class Test01 &#123;    @Test    public void test01() &#123;        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");        SecurityManager securityManager = factory.getInstance();        SecurityUtils.setSecurityManager(securityManager);        Subject subject = SecurityUtils.getSubject();        UsernamePasswordToken token = new UsernamePasswordToken();        token.setUsername(\"user1\");        token.setPassword(\"456\".toCharArray());        try&#123;            subject.login(token);            System.out.println(\"登录成功\");        &#125; catch (AuthenticationException e)&#123;            System.out.println(\"登录失败\");            e.printStackTrace();        &#125;    &#125;&#125;\n","thumbnail":"post/Java/Shiro/3-shiro认证/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/3-shiro认证/"},{"title":"2-shiro架构概述","date":"2020-02-05T13:56:01.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2020-02-08T02:51:35.544Z","content":"Shiro架构图\n\n核心组件Subject可以理解为抽象的用户。\nSecurityManager核心组件，协调所有组件。\nAuthenticator认证器，负责进行认证（登录）。\nAuthorizer授权器，控制访问权限。\nSessionManager会话管理器，Shiro自己实现了会话机制，不依赖于任何容器环境（如Servlet Container）。\nRealm认证和授权信息的数据源。\nSessionDAO对会话进行持久化操作。\nCacheManager对缓存进行管理。\nCryptography加密组件。\n","thumbnail":"post/Java/Shiro/2-shiro架构概述/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/2-shiro架构概述/"},{"title":"1-shiro入门","date":"2020-02-05T13:35:03.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2020-02-08T02:51:28.385Z","content":"创建Maven项目编译设置12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;shiro01&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;project.sourceEncoding&gt;UTF-8&lt;/project.sourceEncoding&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;    &lt;/properties&gt;&lt;/project&gt;\n\n导入依赖shiro-core\njunit\nlogback\njcl-over-slf4j(commons-logging到slf4j的bridge)\n123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;shiro01&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;project.sourceEncoding&gt;UTF-8&lt;/project.sourceEncoding&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;            &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;            &lt;version&gt;1.4.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;            &lt;version&gt;1.7.25&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;            &lt;version&gt;1.2.3&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\n编写配置文件[users]配置用户（用户名=密码，角色1，角色2...）\n[roles]配置角色（角色名=权限1，权限2...）\n12345678[users]user1=123user2=123,useruser3=123,admin[roles]user=user:queryadmin=user:*\n\n编写测试读取配置文件\n创建SecurityManager\n创建Subject\n设置Token\n认证\n12345678910111213141516171819202122public class Test01 &#123;    @Test    public void test01() &#123;        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");        SecurityManager securityManager = factory.getInstance();        SecurityUtils.setSecurityManager(securityManager);        Subject subject = SecurityUtils.getSubject();        UsernamePasswordToken token = new UsernamePasswordToken();        token.setUsername(\"user1\");        token.setPassword(\"123\".toCharArray());        try&#123;            subject.login(token);        &#125; catch (AuthenticationException e)&#123;            System.out.println(\"登录失败\");            e.printStackTrace();        &#125;        System.out.println(\"登录成功\");    &#125;&#125;\n","thumbnail":"post/Java/Shiro/1-shiro入门/cover.jpg","plink":"https://beginc.github.io/post/Java/Shiro/1-shiro入门/"},{"title":"6-SpringMVC实现Restful","date":"2020-02-05T11:21:52.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2020-02-08T02:43:29.595Z","content":"依赖要将JSON字符串和pojo对象互相转化必须引入jackson-databind包。\n方式一：@Controller + @RequestMapping + @RequestBody + @ResponseBody编写pojo类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class User &#123;    private Integer id;    private String name;    private List&lt;String&gt; hobbies;    public User(Integer id, String name, List&lt;String&gt; hobbies) &#123;        this.id = id;        this.name = name;        this.hobbies = hobbies;    &#125;    public User() &#123;    &#125;    @Override    public String toString() &#123;        return \"User&#123;\" +                \"id=\" + id +                \", name='\" + name + '\\'' +                \", hobbies=\" + hobbies +                '&#125;';    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public List&lt;String&gt; getHobbies() &#123;        return hobbies;    &#125;    public void setHobbies(List&lt;String&gt; hobbies) &#123;        this.hobbies = hobbies;    &#125;&#125;\n\nRestful API设计GET /users/查找所有用户\nGET /users/1/查找id为1的用户\nPOST /users/添加用户\nDELETE /users/删除所有用户\nDELETE /users/1/删除id为1的用户\nPUT /users/1/更新id为1的用户\n编写Controller类@RequestMethod指定请求方法（下列DELETE方法和PUT方法会返回403错误，稍后解决）\n@RequestBody解析JSON参数转化成对象\n@ResponseBody将返回值转化成JSON\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Controllerpublic class PlainController &#123;    @RequestMapping(path=\"/users/\", method = RequestMethod.GET)    @ResponseBody    public List&lt;User&gt; findAll()&#123;        List&lt;User&gt; users = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 5; i++) &#123;            User user = new User();            List&lt;String&gt; hobbies = new ArrayList&lt;&gt;();            hobbies.add(\"打球\");            hobbies.add(\"吃火锅\");            user.setHobbies(hobbies);            user.setId(i);            user.setName(\"罗浩文\");            users.add(user);        &#125;        return users;    &#125;    @RequestMapping(path = \"/users/&#123;id&#125;/\", method = RequestMethod.GET)    @ResponseBody    public User findById(@PathVariable(name = \"id\", required = true) int id)&#123;        User user = new User();        List&lt;String&gt; hobbies = new ArrayList&lt;&gt;();        hobbies.add(\"打球\");        hobbies.add(\"吃火锅\");        user.setHobbies(hobbies);        user.setId(id);        user.setName(\"罗浩文\");        return user;    &#125;    @RequestMapping(path = \"/users/\", method = RequestMethod.POST)    public void add(@RequestBody User user)&#123;        System.out.println(user);    &#125;    // 返回403 Forbidden    @RequestMapping(path = \"/users/\", method = RequestMethod.DELETE)    public void deleteAll()&#123;        System.out.println(\"delete all\");    &#125;    // 返回403 Forbidden    @RequestMapping(path = \"/users/&#123;id&#125;/\", method = RequestMethod.DELETE)    public void deleteById(@PathVariable(name = \"id\", required = true) int id)&#123;        System.out.println(\"delete user \" + id);    &#125;    // 返回403 Forbidden    @RequestMapping(path = \"/users/&#123;id&#125;/\", method = RequestMethod.PUT)    public void updateById(@PathVariable(name = \"id\", required = true) int id, @RequestBody User user)&#123;        System.out.println(\"update user \" + id + \"  \" + user);    &#125;&#125;\n\n状态码在请求成功和出错时应该返回适当的状态码。\n@ResponseStatus指定状态码\n请求成功Controller方法上使用@ResponseStatus可指定请求成功时返回的状态码。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Controllerpublic class PlainController &#123;    @RequestMapping(path=\"/users/\", method = RequestMethod.GET)    @ResponseBody    @ResponseStatus(HttpStatus.OK)    public List&lt;User&gt; findAll()&#123;        List&lt;User&gt; users = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 5; i++) &#123;            User user = new User();            List&lt;String&gt; hobbies = new ArrayList&lt;&gt;();            hobbies.add(\"打球\");            hobbies.add(\"吃火锅\");            user.setHobbies(hobbies);            user.setId(i);            user.setName(\"罗浩文\");            users.add(user);        &#125;        return users;    &#125;    @RequestMapping(path = \"/users/&#123;id&#125;/\", method = RequestMethod.GET)    @ResponseBody    @ResponseStatus(HttpStatus.OK)    public User findById(@PathVariable(name = \"id\", required = true) int id)&#123;        User user = new User();        List&lt;String&gt; hobbies = new ArrayList&lt;&gt;();        hobbies.add(\"打球\");        hobbies.add(\"吃火锅\");        user.setHobbies(hobbies);        user.setId(id);        user.setName(\"罗浩文\");        return user;    &#125;    @RequestMapping(path = \"/users/\", method = RequestMethod.POST)    @ResponseStatus(HttpStatus.OK)    public void add(@RequestBody User user)&#123;        System.out.println(user);    &#125;    @RequestMapping(path = \"/users/\", method = RequestMethod.DELETE)    @ResponseStatus(HttpStatus.OK)    public void deleteAll()&#123;        System.out.println(\"delete all\");    &#125;    @RequestMapping(path = \"/users/&#123;id&#125;/\", method = RequestMethod.DELETE)    @ResponseStatus(HttpStatus.OK)    public void deleteById(@PathVariable(name = \"id\", required = true) int id)&#123;        System.out.println(\"delete user \" + id);    &#125;    @RequestMapping(path = \"/users/&#123;id&#125;/\", method = RequestMethod.PUT)    @ResponseStatus(HttpStatus.OK)    public void updateById(@PathVariable(name = \"id\", required = true) int id, @RequestBody User user)&#123;        System.out.println(\"update user \" + id + \"  \" + user);    &#125;&#125;\n\n请求失败方式一：自定义异常类指定状态码抛出自定义异常类\n在自定义异常类上用@ResponseStatus指明异常时返回的状态码\n自定义异常\n1234567891011@ResponseStatus(HttpStatus.BAD_REQUEST)public class CustomException extends RuntimeException &#123;    public CustomException() &#123;        super();    &#125;    public CustomException(String s) &#123;        super(s);    &#125;&#125;\nController\n123456789@Controllerpublic class PlainController &#123;    @RequestMapping(path = \"/error/\", method = RequestMethod.GET)    @ResponseStatus(HttpStatus.OK)    public void error()&#123;        throw new CustomException(\"custom exception\");    &#125;&#125;\n\n方式二：@ControllerAdvice处理异常指定状态码使用@ControllerAdvice和@ExceptionHandler进行异常处理，并指定状态码。\n123456789@ControllerAdvicepublic class MyControllerAdvice &#123;    @ResponseStatus(HttpStatus.BAD_REQUEST)    @ExceptionHandler(CustomException.class)    public void handleCustomException(CustomException e)&#123;        System.out.println(e.getMessage());    &#125;&#125;\n\n方式二：@RestController + @XXXMapping + @RequestBody@RestController的所有方法都使用@ResponseBody返回JSON\nXXXMappingGetMapping\nPostMapping\nPutMapping\nDeleteMapping\n...\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@RestControllerpublic class RestfulController &#123;    @GetMapping(\"/rest/users/\")    @ResponseStatus(HttpStatus.OK)    public List&lt;User&gt; findAll() &#123;        List&lt;User&gt; users = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 5; i++) &#123;            User user = new User();            List&lt;String&gt; hobbies = new ArrayList&lt;&gt;();            hobbies.add(\"打球\");            hobbies.add(\"吃火锅\");            user.setHobbies(hobbies);            user.setId(i);            user.setName(\"罗浩文\");            users.add(user);        &#125;        return users;    &#125;    @GetMapping(\"/rest/users/&#123;id&#125;/\")    @ResponseStatus(HttpStatus.OK)    public User findById(@PathVariable(name = \"id\", required = true) int id) &#123;        User user = new User();        List&lt;String&gt; hobbies = new ArrayList&lt;&gt;();        hobbies.add(\"打球\");        hobbies.add(\"吃火锅\");        user.setHobbies(hobbies);        user.setId(id);        user.setName(\"罗浩文\");        return user;    &#125;    @PostMapping(\"/rest/users/\")    @ResponseStatus(HttpStatus.OK)    public void add(@RequestBody User user) &#123;        System.out.println(user);    &#125;    @DeleteMapping(\"/rest/users/\")    @ResponseStatus(HttpStatus.OK)    public void deleteAll() &#123;        System.out.println(\"delete all\");    &#125;    @DeleteMapping(\"/rest/users/&#123;id&#125;/\")    @ResponseStatus(HttpStatus.OK)    public void deleteById(@PathVariable(name = \"id\", required = true) int id) &#123;        System.out.println(\"delete user \" + id);    &#125;    @PutMapping(\"/rest/users/&#123;id&#125;/\")    @ResponseStatus(HttpStatus.OK)    public void updateById(@PathVariable(name = \"id\", required = true) int id, @RequestBody User user) &#123;        System.out.println(\"update user \" + id + \"  \" + user);    &#125;    @GetMapping(\"/rest/error\")    @ResponseStatus(HttpStatus.OK)    public void error() &#123;        throw new CustomException(\"custom exception\");    &#125;&#125;","thumbnail":"post/Java/SpringMVC/6-SpringMVC实现Restful/cover.png","plink":"https://beginc.github.io/post/Java/SpringMVC/6-SpringMVC实现Restful/"},{"title":"5-SpringMVC拦截器","date":"2020-02-05T10:23:17.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2020-02-08T02:43:26.289Z","content":"拦截器概述SpringMVC中的拦截器可用于拦截处理器方法执行，用于对其进行预处理和后处理。\n拦截器实现编写拦截器类实现HandlerInterceptor接口\n根据需要改写三个方法：preHandle调用处理器方法之前执行\npostHandle调用处理器方法之后执行\nafterCompletion当DispatcherServlet处理完请求后执行\n\n1234567891011121314public class MyInterceptor1 implements HandlerInterceptor &#123;    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(\"Interceptor1 preHandle\");        return true;    &#125;    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123;        System.out.println(\"Interceptor1 postHandle\");    &#125;    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123;        System.out.println(\"Interceptor1 afterCompletion\");    &#125;&#125;\n\n1234567891011121314public class MyInterceptor2 implements HandlerInterceptor &#123;    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(\"Interceptor2 preHandle\");        return true;    &#125;    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123;        System.out.println(\"Interceptor2 postHandle\");    &#125;    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123;        System.out.println(\"Interceptor2 afterCompletion\");    &#125;&#125;\n\n配置拦截器mapping指定要拦截的路径\nexclude-mapping指定不拦截的路径\n配置的先后顺序决定了调用的顺序\n123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;context:component-scan base-package=\"controller\"/&gt;    &lt;context:component-scan base-package=\"exception\"/&gt;    &lt;!--注册类型转换器--&gt;    &lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt;    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;        &lt;property name=\"prefix\" value=\"/\"&gt;&lt;/property&gt;        &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--注册类型转换器--&gt;    &lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt;        &lt;property name=\"converters\"&gt;            &lt;array&gt;                &lt;bean class=\"converter.StringToDateConverter\"&gt;                &lt;/bean&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置拦截器--&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;mvc:mapping path=\"/inter/\"/&gt;        &lt;!--&lt;mvc:exclude-mapping path=\"\"/&gt;--&gt;            &lt;bean class=\"interceptor.MyInterceptor1\"&gt;            &lt;/bean&gt;        &lt;/mvc:interceptor&gt;        &lt;mvc:interceptor&gt;            &lt;mvc:mapping path=\"/inter/\"/&gt;            &lt;!--&lt;mvc:exclude-mapping path=\"\"/&gt;--&gt;            &lt;bean class=\"interceptor.MyInterceptor2\"&gt;            &lt;/bean&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;&lt;/beans&gt;\n\n拦截器调用顺序preHandle按配置的顺序先后执行。\npostHandle按配置的顺序逆序执行。\nafterCompletion按配置的顺序逆序执行。\n拦截器与过滤器区别过滤器是ServletAPI的一部分，任何Web应用都能使用；拦截器只有SpringMVC项目才能使用。\n过滤器可以过滤任何资源；拦截器只能拦截处理器方法。\n顺序当同事配置了拦截器和过滤器，执行顺序为：\n过滤器\n拦截器\n","thumbnail":"post/Java/SpringMVC/5-SpringMVC拦截器/cover.png","plink":"https://beginc.github.io/post/Java/SpringMVC/5-SpringMVC拦截器/"},{"title":"4-SpringMVC异常处理","date":"2020-02-05T09:05:59.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2020-02-08T02:43:23.604Z","content":"异常处理概述在三层项目中，若我们在每一层都对发生的异常进行try catch单独处理，则会导致代码异常处理十分混乱不易于管理。因此较好的做法是，在DAO层和Service层以及Controller层产生的异常我们都不做处理，而是直接向上抛出，最后再为Controller层配置一个统一的异常处理器，对异常进行集中处理。\n方式一：HandlerExceptionResolver自定义异常处理器实现HandlerExceptionResolver接口\n重写resolveException方法\n123456789101112public class ExceptionResolver implements HandlerExceptionResolver &#123;    @Override    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler, Exception e) &#123;        if(e instanceof ArithmeticException)&#123;            System.out.println(\"处理了算术异常\");        &#125;        ModelAndView mv = new ModelAndView();        // 转向错误页面        mv.setViewName(\"error\");        return mv;    &#125;&#125;\n\n注册异常处理器直接实例化即可。\n1234567891011121314151617181920212223242526272829303132&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;context:component-scan base-package=\"controller\"/&gt;    &lt;!--注册类型转换器--&gt;    &lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt;    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;        &lt;property name=\"prefix\" value=\"/\"&gt;&lt;/property&gt;        &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--注册类型转换器--&gt;    &lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt;        &lt;property name=\"converters\"&gt;            &lt;array&gt;                &lt;bean class=\"converter.StringToDateConverter\"&gt;                &lt;/bean&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--注册异常处理器--&gt;    &lt;bean class=\"resolver.ExceptionResolver\"&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nControllerController发生异常后，会交由我们自定义的异常处理器进行处理。\n12345678910@Controller@RequestMapping(\"/exception\")public class ExceptionController &#123;    @RequestMapping    public String exceptionView()&#123;        int i = 1 / 0;        return \"success\";    &#125;&#125;\n\n方式二：@ControllerAdvice + @ExceptionHandler被@ControllerAdvice注解的类可以理解为增强的Controller。\n参数basePackages指定要通知的包\nbasePackageClasses用包中的一个类来指定要通知的包\nassignableTypes指定要通知的类\n\n可实现功能全局异常处理\n全局数据绑定\n全局数据预处理\n\n全局异常处理使用@ExceptionHandler注解在方法上，指定要处理的异常。\n12345678910@ControllerAdvicepublic class MyControllerAdvice &#123;    @ExceptionHandler(ArithmeticException.class)    public String handleArithmeticException(Exception e)&#123;        e.printStackTrace();        System.out.println(\"算术异常\");        return \"error\";    &#125;  &#125;\n\n全局数据绑定使用@ModelAttribute注解在方法上，可为所有的Controller预先绑定参数到ModelMap中（不限于在@ControllerAdvice中指定的类中的Controller）。\nControllerAdvice中的@ModelAttribute注解的方法要先于Controller的@ModelAttribute注解的方法执行(即MyControllerAdvice.bindModelMap要先于ExceptionController.bindModelMap执行)\n123456789@ControllerAdvicepublic class MyControllerAdvice &#123;    @ModelAttribute    public void bindModelMap(ModelMap map)&#123;        System.out.println(\"bind global\");        map.addAttribute(\"global\", new Date());    &#125;&#125;\n\n123456789101112131415161718@Controller@RequestMapping(\"/exception\")public class ExceptionController &#123;    @RequestMapping    public String exceptionView(@ModelAttribute(\"date\")Date global, @ModelAttribute(\"local\") Date local)&#123;        System.out.println(global);        System.out.println(local);        int i = 1 / 0;        return \"success\";    &#125;    @ModelAttribute    public void bindModelMap(ModelMap map)&#123;        System.out.println(\"bind local\");        map.addAttribute(\"local\", new Date());    &#125;&#125;\n\n全局数据预处理使用@InitBinder。\n","thumbnail":"post/Java/SpringMVC/4-SpringMVC异常处理/cover.png","plink":"https://beginc.github.io/post/Java/SpringMVC/4-SpringMVC异常处理/"},{"title":"3-SpringMVC请求响应","date":"2020-02-05T03:02:14.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2020-02-08T02:43:20.856Z","content":"返回字符串字符串指定试图名称。\n默认默认为请求转发\n12345678910@Controller@RequestMapping(\"/response\")public class ResponseController &#123;    @RequestMapping(\"defaultString\")    public String defaultStringResponse()&#123;        System.out.println(\"defaultStringResponse\");        return \"success\";    &#125;&#125;\n\n转发用forward指定转发\n视图名称必须用全名称\n12345678910@Controller@RequestMapping(\"/response\")public class ResponseController &#123;    @RequestMapping(\"forwardString\")    public String forwardStringResponse()&#123;        System.out.println(\"forwardStringResponse\");        return \"forward:/success.jsp\";    &#125;&#125;\n\n重定向用redirect指定重定向\n视图名称必须用全名称\n12345678910@Controller@RequestMapping(\"/response\")public class ResponseController &#123;    @RequestMapping(\"redirectString\")    public String redirectStringResponse()&#123;        System.out.println(\"redirectStringResponse\");        return \"redirect:/success.jsp\";    &#125;&#125;\n\n返回ModelAndViewaddObject绑定数据到requestScope中\nsetViewName指定视图名称\n12345678910111213@Controller@RequestMapping(\"/response\")public class ResponseController &#123;    @RequestMapping(\"modelAndView\")    public ModelAndView modelAndViewResponse()&#123;        ModelAndView mv = new ModelAndView();        mv.addObject(\"now\", new Date());        mv.setViewName(\"success\");        return mv;    &#125;&#125;\n\n返回void绑定HttpServletRequest进行转发\n绑定HttpServletResponse进行重定向\n获取PrintWriter直接输出\n1234567891011@Controller@RequestMapping(\"/response\")public class ResponseController &#123;    @RequestMapping(\"void\")    public void voidResponse(HttpServletResponse response) throws IOException &#123;        response.setContentType(\"text/html;charset=utf-8\");        response.setCharacterEncoding(\"utf-8\");        response.getWriter().write(\"success\");    &#125;&#125;\n\n返回Json见\n","thumbnail":"post/Java/SpringMVC/3-SpringMVC请求响应/cover.png","plink":"https://beginc.github.io/post/Java/SpringMVC/3-SpringMVC请求响应/"},{"title":"maven多模块构建","date":"2020-01-29T05:40:52.000Z","date_formatted":{"ll":"Jan 29, 2020","L":"01/29/2020","MM-DD":"01-29"},"updated":"2020-02-08T02:48:26.156Z","content":"","thumbnail":"post/Java/Maven/maven多模块构建/cover.jpg","plink":"https://beginc.github.io/post/Java/Maven/maven多模块构建/"},{"title":"maven基本使用","date":"2020-01-29T04:41:35.000Z","date_formatted":{"ll":"Jan 29, 2020","L":"01/29/2020","MM-DD":"01-29"},"updated":"2020-02-08T02:48:29.813Z","content":"Maven的功能依赖管理\n一键构建\nMaven配置本地仓库conf/settings.xml\n1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\"          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt;  &lt;localRepository&gt;F:\\repository&lt;/localRepository&gt;&lt;/settings&gt;\n\n中央仓库配置阿里云的镜像。\nconf/settings.xml\n1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\"          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt;  &lt;localRepository&gt;F:\\repository&lt;/localRepository&gt;  &lt;mirrors&gt;     &lt;mirror&gt;          &lt;id&gt;alimaven&lt;/id&gt;          &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          &lt;name&gt;aliyun maven&lt;/name&gt;          &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;      &lt;/mirror&gt;   &lt;/mirrors&gt;&lt;/settings&gt;\n\nMaven项目结构1234567891011121314151617181920Project/    # 源码    src/        main/          # 源码          java/          # 资源、配置文件等(编译后会放入target/classes目录下)          resources/        test/          # 测试代码          java/    # 构建出来的文件    target/        # 编译src/main/java生成的字节码文件        classes/        # 编译src/test/java生产的字节码文件        test-classes/        ...    # Maven项目配置文件    pom.xml\n\nMaven常用命令命令mvn clean\n清除target文件夹。\nmvn compile\n编译src/main/java。\nmvn test\n运行src/test/java下的测试。\nmvn package\n将项目打包成jar/war放到target目录下。\nmvn install\n将项目安装到本地仓库。\n流程执行一个命令时都会从头开始执行。如mvn test会运行mvn clean, mvn compile,mvn test。\n\n\nMaven生命周期清除生命周期\n默认生命周期\n站点生命周期\n\n\nMaven项目配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;!--maven项目对象模型版本--&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;!--组织名--&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;!--项目名--&gt;    &lt;artifactId&gt;spring-03&lt;/artifactId&gt;    &lt;!--版本号--&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;!--定义属性--&gt;    &lt;properties&gt;        &lt;spring.version&gt;5.2.1.RELEASE&lt;/spring.version&gt;    &lt;/properties&gt;    &lt;!--依赖版本锁定--&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-test&lt;/artifactId&gt;              &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;              &lt;scope&gt;test&lt;/scope&gt;          &lt;/dependency&gt;          &lt;dependency&gt;              &lt;groupId&gt;org.springframework&lt;/groupId&gt;              &lt;artifactId&gt;spring-context&lt;/artifactId&gt;              &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;              &lt;scope&gt;test&lt;/scope&gt;          &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;!--项目依赖--&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.15&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;!--插件--&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                    &lt;source&gt;11&lt;/source&gt;                    &lt;target&gt;11&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n项目信息modelVersion\nmaven项目对象模型的版本。\ngroupId\n组织名。\nartifactId\n项目名。\nversion\n版本号。\nPropertyproperties\n定义一些属性。\n依赖dependencies\n项目依赖。\ngroupId\nartifactId\nversion\nscope\n版本锁定dependencyManagement\n将依赖的版本进行锁定，该项目的子模块无法进行替换。\n插件plugins\n依赖管理依赖定位groupId\nartifactId\nversion\n依赖作用范围compile\n编译、测试、运行时都需要。\nruntime\n只有测试、运行时需要。\ntest\n只有\nprovided\n","thumbnail":"post/Java/Maven/maven基本使用/cover.jpg","plink":"https://beginc.github.io/post/Java/Maven/maven基本使用/"},{"title":"Jave内置日志介绍","date":"2020-01-28T09:16:19.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:39:22.684Z","content":"主要组件Logger实际使用的日志类。\nHandler接收日志，并输出到目的地。\nFilter过滤器，决定一个日志记录是否可以输出。\nErrorManager错误管理器，负责处理Handler处理日志时发生的错误。\nLogRecord日志记录，每次调用方法输出日志会产生一个该类实例。\nLogManager日志管理器。\n将所有Logger组织成一个层次结构\n维护一些配置信息\nLevel日志级别。\nOFF\nSEVERE\nWARNING\nINFO\nCONFIG\nFINE\nFINER\nFINEST\nALL\n基本使用创建和输出12345678910public void testJavaLogging()&#123;    Logger logger = Logger.getLogger(getClass().getName());    logger.severe(\"log\");    logger.warning(\"log\");    logger.info(\"log\");    logger.config(\"log\");    logger.fine(\"log\");    logger.finer(\"log\");    logger.finest(\"log\");&#125;\n\nTODO由于JUL使用不多，不做深入研究。\n","thumbnail":"post/Java/日志/Jave内置日志介绍/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/Jave内置日志介绍/"},{"title":"日志框架迁移","date":"2020-01-28T09:05:52.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:38:46.260Z","content":"Spring替换commons-logging为slf4j排除spring-core.jar对commons-logging的依赖\n1234567891011&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;commons-logging&lt;/groupId&gt;            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;\n\n引入slf4j\n12345&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;    &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;\n\n引入辅助包进行适配\n12345&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;    &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;\n\n\nMyBatis指定日志框架在SqlMapConfig.xml中settings配置logImpl\n    可为SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING\n12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;properties resource=\"jdbc.properties\"/&gt;    &lt;settings&gt;        &lt;setting name=\"logImpl\" value=\"slf4j\"/&gt;    &lt;/settings&gt;    &lt;typeAliases&gt;        &lt;package name=\"bean\"/&gt;    &lt;/typeAliases&gt;    &lt;environments default=\"dev\"&gt;        &lt;environment id=\"dev\"&gt;            &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt;            &lt;dataSource type=\"POOLED\"&gt;                &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt;                &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt;                &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt;                &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=\"sqlmap/ManagerMapper.xml\"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;","thumbnail":"post/Java/日志/日志框架迁移/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/日志框架迁移/"},{"title":"logback介绍","date":"2020-01-28T09:05:39.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:39:33.705Z","content":"包介绍logback-core.jar基础核心包\nlogback-classic.jar对slf4j API的直接实现\nlogback-access.jar实现在HTTP环境中进行日志\n架构组件基本和Java日志框架概况中说明的组件相同（名称等略有不同）。\n层次性遵从Java日志框架概况说明的层次性。\n配置配置文件查找顺序找clasapath:logback-test.xml\n找clasapath:logback.groovy\n找clasapath:logback.xml\n找META-INF\\services\\ch.qos.logback.classic.spi中指定的类(ServiceProvider)\n使用BasicConfigurator进行基本配置，默认输出到控制台\n配置模板1234567891011121314151617&lt;configuration&gt;  &lt;property name=\"属性名称\" value=\"属性值\" /&gt;  &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;    &lt;encoder&gt;      &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;    &lt;/encoder&gt;  &lt;/appender&gt;  &lt;logger name=\"logger\" level=\"info\" additivity=\"false\"&gt;  &lt;/logger&gt;  &lt;root level=\"debug\"&gt;    &lt;appender-ref ref=\"STDOUT\" /&gt;  &lt;/root&gt;&lt;/configuration&gt;\n\n常用AppenderConsoleAppender输出到控制台。\ntarget\nSystem.out\nSystem.error\nFileAppender输出到文件。\nappend\n是否追加。\nfile\n文件名\nprudent\n是否安全写入文件（并发写情况下有用，若为true默认为追加）\nimmediateFlush\n是否写的时候立即刷新缓冲区。\nRollingFileAppender滚动追加。（有FileAppender所有属性）\nrollingPolicy\n指定如何滚动。\ntriggeringPolicy\n指定何时触发滚动。\n","thumbnail":"post/Java/日志/logback介绍/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/logback介绍/"},{"title":"log4j介绍","date":"2020-01-28T09:05:32.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:39:29.955Z","content":"Deprecatedlog4j已经被弃用，现在被log4j2代替\n","thumbnail":"post/Java/日志/log4j介绍/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/log4j介绍/"},{"title":"log4j2介绍","date":"2020-01-28T09:05:24.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:39:27.130Z","content":"包介绍log4j-api包含了API\nlog4j-core核心包（根据不同的需求有额外的依赖）\n\n\n架构组件基本和Java日志框架概况中说明的组件相同（名称等略有不同）。\n\n\n层次性遵从Java日志框架概况说明的层次性。\n配置配置文件查找顺序查找名为log4j.configurationFile的System Property对应的配置文件。\n\n查找classpath:log4j2-test.properties\n\n查找classpath:log4j2-test.yaml或classpath:log4j2-test.yaml\n\n查找classpath:log4j2-test.json或classpath:log4j2-test.jsn\n\n查找classpath:log4j2-test.xml\n\n查找classpath:log4j2.properties\n\n查找classpath:log4j2.yaml或classpath:log4j2.yaml\n\n查找classpath:log4j2.json或classpath:log4j2.jsn\n\n查找classpath:log4j2.xml\n\n使用默认配置\n\nConsoleAppender添加到RootLogger\nPatternLayout添加到RootLogger\nRootLogger的Level为ERROR\n配置模板1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;;&lt;Configuration&gt;  &lt;!--定义变量--&gt;  &lt;Properties&gt;    &lt;Property name=\"变量名\"&gt;变量值&lt;/property&gt;  &lt;/Properties&gt;  &lt;Filter名 属性1=\"值\" 属性2=\"值\"&gt;  &lt;/Filter名&gt;  &lt;Appenders&gt;    &lt;Appender名 属性1=\"值\" 属性2=\"值\"&gt;      &lt;Filter名 属性1=\"值\" 属性2=\"值\"&gt;      &lt;/Filter名&gt;      &lt;Layout名 属性1=\"值\" 属性2=\"值\"&gt;      &lt;/Layout名&gt;    &lt;/Appender名&gt;  &lt;/Appenders&gt;  &lt;Loggers&gt;    &lt;Logger name=\"logger\" level=\"info\" addictivity=\"false\"&gt;      &lt;Filter名 属性1=\"值\" 属性2=\"值\"&gt;      &lt;/Filter名&gt;      &lt;AppenderRef ref=\"name\"&gt;        &lt;Filter名 属性1=\"值\" 属性2=\"值\"&gt;        &lt;/Filter名&gt;      &lt;/AppenderRef&gt;    &lt;/Logger&gt;    &lt;Root level=\"error\"&gt;      &lt;AppenderRef ref=\"name\"/&gt;    &lt;/Root&gt;  &lt;/Loggers&gt;&lt;/Configuration&gt;\n\n常用AppenderConsoleAppender输出到控制台。\ntarget\nSYSTEM_OUT\nSYSTEM_ERROR\nFileAppender输出到文件。\nappend\n是否追加。\nbufferedIO\n是否写日志先写到缓冲区，满了再写到磁盘，可提高性能。\nbufferSize\n缓冲区大小。\ncreateOnDemand\n是否在真正写日志时再创建文件。\nfileName\n文件名。\nimmediateFlush\n每次写到缓冲区都会马上刷新。\nlocking\n是否写时上锁。会极大影响性能。\nRollingFileAppender输出到文件，可指定何时进行滚动。（FileAppender的属性都有）\npolicy\n决定是否发生滚动。\nstrategy\n决定滚动产生的文件的位置和名称。\n常用FilterBurstFilter控制每秒打印的日志数量。\nlevel\n低于或等于该级别的日志会被过滤。\nrate\n允许的日志输出速率。\nmaxBurst\n最大排队日志数量，默认为rate * 10, 当超过该数量时，日志将会被丢弃。\nonMatch\n符合条件时的行为\nACCEPT通过\nDENY拒绝（过滤掉）\nNEUTRAL（交给其他过滤器继续决定）\nonMismatch\n不符合条件时的行为\nACCEPT通过\nDENY拒绝（过滤掉）\nNEUTRAL（交给其他过滤器继续决定）\n常用LayoutHTML Layout输出成HTML的形式，每条日志都在一个table中。\ncharset\n字符集。\ntitle\n标题。\nfontName\n字体名。\nfontSize\n字体大小。\nJSON Layout输出成JSON格式。\ncharset\n字符集。\ncompact\n紧凑形式，设置compact和eventEol都为true，则为一条记录占一行。\ncomplete\n若为false，将省略数组的[]和隔开字段的,。\nobjectMessageAsJsonObject\n若为true，则ObjectMessage将会被序列化成JSON。\nPattern Layout格式化输出。\ncharset\n字符集。\npattern\n指定格式。\n%logger{precision}\n输出Logger名称\n\n\n%class{precision}\n输出调用者全限定类名\n\n%date{pattern}\n输出日期\n\n\n%msg\n日志信息。\n\n%method\n方法名\n\n%pid\n进程id\n\n%tid\n线程id\n\n%level\n\n日志级别\n","thumbnail":"post/Java/日志/log4j2介绍/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/log4j2介绍/"},{"title":"commons-logging介绍","date":"2020-01-28T09:01:49.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:38:51.336Z","content":"","thumbnail":"post/Java/日志/commons-logging介绍/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/commons-logging介绍/"},{"title":"slf4j介绍","date":"2020-01-28T09:01:39.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:39:37.690Z","content":"SLF4J包介绍slf4j-api-1.7.27.jar核心包，只要使用slf4j则必须引入\nslf4j-log4j12-1.7.27.jar绑定log4j1.2版本的包\nslf4j-jdk14-1.7.27.jar绑定使用java.util.logging的包\nslf4j-nop-1.7.27.jar不进行任何日志操作\nslf4j-simple-1.7.27.jar使用简单的日志框架实现的包\nslf4j-jcl-1.7.27.jar绑定使用Jakarta Commons Logging的包\nlogback-classic-1.2.3.jar绑定使用logback的包\n绑定具体日志框架引入slf4j-api-1.7.27.jar\n引入日志框架的包\n引入对应的绑定日志框架的包\n使用\nLoggerFactory.getLogger(logger名字)\nlogger.trace()\nlogger.debug()\nlogger.info()\nlogger.warn()\nlogger.error()\n12345678910111213141516import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class TestLog &#123;    @Test    public void test01() &#123;        Logger logger = LoggerFactory.getLogger(\"test\");        logger.trace(\"From slf4j, from class &#123;&#125;\", getClass().getName());        logger.debug(\"From slf4j, from class &#123;&#125;\", getClass().getName());        logger.info(\"From slf4j, from class &#123;&#125;\", getClass().getName());        logger.warn(\"From slf4j, from class &#123;&#125;\", getClass().getName());        logger.error(\"From slf4j, from class &#123;&#125;\", getClass().getName());    &#125;&#125;","thumbnail":"post/Java/日志/slf4j介绍/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/slf4j介绍/"},{"title":"2-SpringMVC参数绑定","date":"2020-01-28T02:33:22.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2020-02-08T02:43:17.238Z","content":"表单参数绑定绑定规则变量名与表单名的name相同则可直接绑定\n\n变量名与表单名的name不相同\n @RequestParam注解：\nname:名称\nrequired:必须有值\ndefaultValue：默认值\n\n基本类型与String基本类型123456&lt;div class=\"form\"&gt;    &lt;form action=\"bind/int\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"int\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\n123456@RequestMapping(path = \"/int\")public String intView(int var)&#123;    System.out.println(var);    return \"success\";&#125;\n\nString123456&lt;div class=\"form\"&gt;    &lt;form action=\"bind/string\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"String\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\n12345@RequestMapping(path = \"/string\")public String stringView(String var)&#123;    System.out.println(var);    return \"success\";&#125;\n\n集合类型Array都填相同的名字\n12345678&lt;div class=\"form\"&gt;    &lt;form action=\"bind/array\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"array\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"array\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"array\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\n12345@RequestMapping(path = \"/array\")public String arrayView(int[] var)&#123;    System.out.println(Arrays.toString(var));    return \"success\";&#125;\n\nList都填相同的名字\n参数必须用@RequestParam修饰\n12345678&lt;div class=\"form\"&gt;    &lt;form action=\"bind/list\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"list\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"list\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"list\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\n1234567@RequestMapping(path = \"/list\")public String listView(@RequestParam(\"var\") List&lt;Integer&gt; var)&#123;    for (Integer integer : var) &#123;        System.out.println(integer);    &#125;    return \"success\";&#125;\n\nSet都填相同的名字\n参数必须用@RequestParam修饰\n12345678&lt;div class=\"form\"&gt;    &lt;form action=\"bind/set\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"set\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"set\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"var\" placeholder=\"set\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\n1234567@RequestMapping(path = \"/set\")public String setView(@RequestParam(\"var\") Set&lt;Integer&gt; var)&#123;    for (Integer integer : var) &#123;        System.out.println(integer);    &#125;    return \"success\";&#125;\n\n对象类型属性名必须和参数名相同\nPojo对象12345678public class People &#123;    private String name;    private Integer age;    private List&lt;Account&gt; accounts;    private Map&lt;String, Phone&gt; phoneMap;&#125;\n\n12345public class Phone &#123;    private String name;    private Float price;&#125;\n\n1234public class Account &#123;    private Float money;&#125;\n\n属性绑定12345@RequestMapping(path = \"/object\")public String objectView(People people)&#123;    System.out.println(people);    return \"success\";&#125;\n\n基本类型和String1234567&lt;div class=\"form\"&gt;    &lt;form action=\"bind/object\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"name\" placeholder=\"name\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"age\" placeholder=\"age\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\n对象集合List1234567&lt;div class=\"form\"&gt;    &lt;form action=\"bind/object\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"accounts[0].money\" placeholder=\"account.money\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"accounts[1].money\" placeholder=\"account.money\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\nMap123456789&lt;div class=\"form\"&gt;    &lt;form action=\"bind/object\" method=\"get\"&gt;        &lt;input type=\"text\" name=\"phoneMap['android'].name\" placeholder=\"phone.name\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"phoneMap['android'].price\" placeholder=\"phone.price\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"phoneMap['iphone'].name\" placeholder=\"phone.name\"&gt; &lt;br/&gt;        &lt;input type=\"text\" name=\"phoneMap['iphone'].price\" placeholder=\"phone.price\"&gt; &lt;br/&gt;        &lt;input type=\"submit\" name=\"提交\"&gt;    &lt;/form&gt;&lt;/div&gt;\n\n自定义类型转换SpringMVC对于日期的类型转换只支持2018/8/8格式，不支持2018-8-8格式，此时我们可以自定义类型转换器来对日期做转换。\n类型转换器实现Converter&lt;S, T&gt;接口, S为参数类型，T为目标类型。\n重写convert方法。\n12345678910111213141516171819public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123;    @Override    public Date convert(String s) &#123;        String pattern;        if (s.contains(\"/\"))            pattern = \"yyyy/MM/dd\";        else            pattern = \"yyyy-MM-dd\";        SimpleDateFormat format = new SimpleDateFormat(pattern);        try &#123;            return format.parse(s);        &#125; catch (ParseException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;\n\n注册ConversionService1234567891011121314151617181920212223242526272829&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;context:component-scan base-package=\"controller\"/&gt;    &lt;!--注册类型转换器--&gt;    &lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt;    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;        &lt;property name=\"prefix\" value=\"/\"&gt;&lt;/property&gt;        &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--注册类型转换器--&gt;    &lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt;        &lt;property name=\"converters\"&gt;            &lt;array&gt;                &lt;bean class=\"converter.StringToDateConverter\"&gt;                &lt;/bean&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n异步请求JSON数据绑定必须引入依赖\njackson-core\njackson-annotation\njackson-databind\n\n必须使用@RequestBody注解方法参数\n\n12345@RequestMapping(path = \"/json\")public String jsonView(@RequestBody Phone phone)&#123;    System.out.println(phone);    return \"success\";&#125;\n\n\nServletAPI对象绑定HttpServletRequest\nHttpServletResponse\nHttpSession\n123456@RequestMapping(path = \"/object\")public void servletView(HttpServletResponse response) throws IOException &#123;    response.setContentType(\"text/html;charset=utf-8\");    response.setCharacterEncoding(\"utf-8\");    response.getWriter().write(\"success\");&#125;\n\nHTTP其他相关数据绑定@PathVariable获取路径中占位符的值\nURL中指定占位符\nname指定名称\nrequired指定是否必须\n12345@RequestMapping(path = \"/path/&#123;id&#125;\")public String pathView(@PathVariable(name = \"id\", required = true) Integer id)&#123;    System.out.println(id);    return \"success\";&#125;\n@RequestHeader获取请求头\nname指定名称\nrequired指定是否必须\n12345@RequestMapping(path = \"/header\")public String headerView(@RequestHeader(name = \"Accept\", required = true) String contentType)&#123;    System.out.println(contentType);    return \"success\";&#125;\n@CookieValue获取cookie\nname指定名称\nrequired指定是否必须\n12345@RequestMapping(path = \"/cookie\")public String cookieView(@CookieValue(name = \"JSESSIONID\", required = true) String jsessionId)&#123;    System.out.println(jsessionId);    return \"success\";&#125;\n\n\n域参数绑定利用如下一些API我们可以利用Spring提供的抽象，不依赖ServletAPI来将参数绑定到requestScope和sessionScope中。\nModelMap用于将参数绑定到requestScope中。\n1234@RequestMapping(path = \"/modelmap\")public void modelMapView(ModelMap map) throws IOException &#123;    map.addAttribute(\"date\", new Date());&#125;\n\n@ModelAttibute加在方法上被注解的方法将会在所有mapping方法执行前执行。可用于在所有mapping方法执行前执行对ModelMap进行参数绑定，后续的mapping方法可从ModelMap中取出对应参数。\n被注解的方法可以绑定mapping方法能绑定的参数。\n带返回值--直接返回\n默认以返回值的类名（首字母小写）作为key，将返回值存入ModelMap中。\n12345678910// 相当于modelMap.addAttribute(\"string\", \"123\")@ModelAttributepublic String beforeAll()&#123;    return \"123\";&#125;// 相当于modelMap.addAttribute(\"people\", new People())@ModelAttributepublic People beforeAll()&#123;    return new People();&#125;\n\n带返回值--指定key返回\n在注解中指明。\n1234@ModelAttribute(\"str\")public String beforeAll()&#123;    return \"123\";&#125;\n\n不带返回值--绑定到ModelMap\n直接绑定到ModelMap中。\n1234@ModelAttributepublic void beforeAll(ModelMap map)&#123;    map.addAttribute(\"str\", \"123\");&#125;\n\n加在参数上用于取出存在ModelMap中的参数。\n12345@ModelAttribute(\"str\")public String getModelMapParam(@ModelAttribute(\"str\") msg)&#123;    System.out.println(msg);    return \"success\";&#125;\n\n@SessionAttributes将ModelMap中的参数绑定到sessionScope中，用于在多个请求之间传递参数\n绑定过程在mapping方法执行过后进行\n使用@SessionAttribute注释方法参数可取出sessionScope中的参数\n1234567891011121314151617@Controller@RequestMapping(\"/bind\")@SessionAttributes(&#123;\"date\"&#125;)public class BindController &#123;    @RequestMapping(path = \"/getmodelmap\")    public String getModelMapView(@SessionAttribute(\"date\") Date date)&#123;        System.out.println(date);        return \"success\";    &#125;    @RequestMapping(path = \"/modelmap\")    public String modelMapView(ModelMap map) throws IOException &#123;        map.addAttribute(\"date\", new Date());        return \"success\";    &#125;&#125;\n","thumbnail":"post/Java/SpringMVC/2-SpringMVC参数绑定/cover.png","plink":"https://beginc.github.io/post/Java/SpringMVC/2-SpringMVC参数绑定/"},{"title":"7-Spring之XML配置加注解开发","date":"2020-01-26T15:43:27.000Z","date_formatted":{"ll":"Jan 26, 2020","L":"01/26/2020","MM-DD":"01-26"},"updated":"2020-02-29T09:08:30.879Z","content":"导入依赖Spring必备依赖\nJavax Annotation API（有些注解需要该包的支持）\n开启包扫描指定要扫描的包，Spring会对当前包以及子包下的类进行扫描，寻找注解。\n123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;context:component-scan base-package=\"controller\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"service\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"dao\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"pojo\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;\n\nBean管理Bean注册@Component\n注册Bean\n可指定id\n若不指定id默认为类名（第一个字母小写）\n123456789101112@Component(\"accountControlller\")public class AccountController &#123;    private AccountService accountService;    public void setAccountService(AccountService accountService) &#123;        this.accountService = accountService;    &#125;    public void transfer() &#123;        accountService.transfer(3, 4, 100);    &#125;&#125;\n\n@Repository\n同@Component，用于注册DAO类\n@Service\n同@Component，用于注册Service类\n@Controller\n同@Component，用于注册Controller类\nBean作用范围@Scope\n指定作用范围\n12345678910111213@Controller(\"accountControlller\")@Scope(\"prototype\")public class AccountController &#123;    private AccountService accountService;    public void setAccountService(AccountService accountService) &#123;        this.accountService = accountService;    &#125;    public void transfer() &#123;        accountService.transfer(3, 4, 100);    &#125;&#125;\n\nBean生命周期方法1234567891011121314151617181920212223@Controller(\"accountControlller\")@Scope(\"prototype\")public class AccountController &#123;    private AccountService accountService;    public void setAccountService(AccountService accountService) &#123;        this.accountService = accountService;    &#125;    public void transfer() &#123;        accountService.transfer(3, 4, 100);    &#125;    @PostConstruct    public void init() &#123;        System.out.println(\"Account Controller Init...\");    &#125;    @PreDestroy    public void destroy() &#123;        System.out.println(\"Account Controller Destroy...\");    &#125;&#125;\n\n@PostConstruct\n创建Bean时调用的方法\n@PreDestroy\n销毁Bean时调用的方法\nBean依赖注入@Value\n用于注入基本类型和String, 可使用SpEL表达式\n123456789101112131415161718192021222324252627@Controller(\"accountControlller\")@Scope(\"prototype\")public class AccountController &#123;    @Value(\"1\")    private int intForTest;        private AccountService accountService;    public void setAccountService(AccountService accountService) &#123;        this.accountService = accountService;    &#125;    public void transfer() &#123;        accountService.transfer(3, 4, 100);    &#125;    @PostConstruct    public void init() &#123;        System.out.println(\"Account Controller Init...\");    &#125;    @PreDestroy    public void destroy() &#123;        System.out.println(\"Account Controller Destroy...\");    &#125;&#125;\n\n@Autowired\n按照类型注入\nIoC容器中能找到唯一对应：直接注入\nIoC容器中能找到多个对应：使用变量名与id匹配注入\n123456789101112131415161718192021222324252627@Controller(\"accountControlller\")@Scope(\"prototype\")public class AccountController &#123;    @Value(\"1\")    private int intForTest;    @Autowired    private AccountService accountService;    public void setAccountService(AccountService accountService) &#123;        this.accountService = accountService;    &#125;    public void transfer() &#123;        accountService.transfer(3, 4, 100);    &#125;    @PostConstruct    public void init() &#123;        System.out.println(\"Account Controller Init...\");    &#125;    @PreDestroy    public void destroy() &#123;        System.out.println(\"Account Controller Destroy...\");    &#125;&#125;\n\n@Qualifier\n必须和@Autowired同时使用，在按照@Autowired按类型注入的基础上，再按照id注入\n1234567891011121314151617181920212223242526272829@Controller(\"accountControlller\")@Scope(\"prototype\")public class AccountController &#123;    @Value(\"1\")    private int intForTest;        @Autowired    @Qualifier(\"accountService\")    private AccountService accountService;    public void setAccountService(AccountService accountService) &#123;        this.accountService = accountService;    &#125;    public void transfer() &#123;        accountService.transfer(3, 4, 100);    &#125;    @PostConstruct    public void init() &#123;        System.out.println(\"Account Controller Init...\");    &#125;    @PreDestroy    public void destroy() &#123;        System.out.println(\"Account Controller Destroy...\");    &#125;&#125;\n\n@Resource\n按照id注入，要写name属性\n12345678910111213141516@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123;    @Resource(name = \"accountDao\")    private AccountDao accountDao;    public void setAccountDao(AccountDao accountDao) &#123;        this.accountDao = accountDao;    &#125;    @Override    public void transfer(int src, int dest, int num) &#123;        accountDao.in(dest, num);        int i = 1 / 0;        accountDao.out(src, num);    &#125;&#125;\n\n\nAOP开启AOP注解支持12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;context:component-scan base-package=\"controller\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"service\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"dao\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"pojo\"&gt;&lt;/context:component-scan&gt;        &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;\n\n配置切面类@Aspect\n12345@Aspect@Componentpublic class Logger &#123;&#125;\n\n配置切入点@Pointcut\n方法名为切入点名称\n12345678@Aspect@Componentpublic class Logger &#123;    @Pointcut(\"execution(public void service.impl.AccountServiceImpl.transfer(int, int, int))\")    void accountServicePointcut()&#123;&#125;;&#125;\n\n配置通知引用切入点需要加入()\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Aspect@Componentpublic class Logger &#123;    @Pointcut(\"execution(public void service.impl.AccountServiceImpl.transfer(int, int, int))\")    void accountServicePointcut()&#123;&#125;;    @Before(\"accountServicePointcut()\")    void before() &#123;        System.out.println(\"[Before]: 记录日志\");    &#125;    @After(\"accountServicePointcut()\")    void after() &#123;        System.out.println(\"[After]: 记录日志\");    &#125;    @AfterReturning(\"accountServicePointcut()\")    void afterReturning() &#123;        System.out.println(\"[AfterReturning]: 记录日志\");    &#125;    @AfterThrowing(\"accountServicePointcut()\")    void afterThrowing() &#123;        System.out.println(\"[After-Throwing]: 记录日志\");    &#125;    @Around(\"accountServicePointcut()\")    Object around(ProceedingJoinPoint proceedingJoinPoint)&#123;        try&#123;            // 前置            before();            Object[] args = proceedingJoinPoint.getArgs();            // 方法调用            Object returnVal = proceedingJoinPoint.proceed(args);            // 后置            afterReturning();            return returnVal;        &#125; catch (Throwable throwable) &#123;            // 异常            afterThrowing();            throwable.printStackTrace();        &#125; finally &#123;            // 最终            after();        &#125;        return null;    &#125;&#125;\n\n@Before\n前置通知\n@After\n最终通知\n@AfterReturning\n后置通知\n@AfterThrowing\n异常通知\n@Around\n环绕通知\n事务管理开启事务控制注解支持需要传入transactionManager事务管理器\n12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;context:component-scan base-package=\"controller\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"service\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"dao\"&gt;&lt;/context:component-scan&gt;    &lt;context:component-scan base-package=\"pojo\"&gt;&lt;/context:component-scan&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC&amp;amp;useSSL=false\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"LQ18851195070\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;tx:annotation-driven transaction-manager=\"transactionManager\"&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt;\n\n注解配置事务@Transactional\n可配置在类上应用到所有方法，也可以配置在方法上单独配置\n1234567891011121314151617@Service(\"accountService\")@Transactional(isolation = Isolation.REPEATABLE_READ, propagation = Propagation.REQUIRED, readOnly = false, timeout = -1)public class AccountServiceImpl implements AccountService &#123;    @Resource(name = \"accountDao\")    private AccountDao accountDao;    public void setAccountDao(AccountDao accountDao) &#123;        this.accountDao = accountDao;    &#125;    @Override    public void transfer(int src, int dest, int num) &#123;        accountDao.in(dest, num);        int i = 1 / 0;        accountDao.out(src, num);    &#125;&#125;\n\n测试Spring提供对Junit的支持，可注入依赖的属性。\n需要引入Spring Test包\n12345678910111213141516@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = Config.class)public class Test01 &#123;    @Autowired    private AccountController controller;    public void setController(AccountController controller) &#123;        this.controller = controller;    &#125;    @Test    public void test()&#123;        controller.transfer();    &#125;&#125;\n\n@RunWith\n指定Runner\n@ContextConfiguration\n指定配置位置\n可指定配置文件\n可指定配置类\n","thumbnail":"post/Java/Spring/7-Spring之XML配置加注解开发/cover.png","plink":"https://beginc.github.io/post/Java/Spring/7-Spring之XML配置加注解开发/"},{"title":"6-Spring之事务管理","date":"2020-01-26T15:43:05.000Z","date_formatted":{"ll":"Jan 26, 2020","L":"01/26/2020","MM-DD":"01-26"},"updated":"2020-02-29T08:59:28.152Z","content":"事务逻辑上的一组操作，组成这组操作的各个单元要么全部成功，要么全部失败。\n事务的特性Atomicity原子性。事务里的一组操作要么全部成功，要么全部失败。\n转账事务：\n    1. A账户减少100块钱\n    2. B账户增加100块钱1和2要么全部成功，要么全部失败，不能是A账户减少了100块钱，而B账户却没有增加100块钱。\nConsistency一致性。事务执行后，数据保持完整性，符合逻辑。\nIsolation隔离性。两个事务的执行应该不会互相影响。\nDurability持久性。事务完成后，结果被持久化到数据库。\nACID的实现Atomicity事务成功commit\n事务失败rollback\nConsistency通过原子性 + 隔离性实现。\nIsolation使用事务的隔离级别来保证。\n事务之间的影响脏读\n一个事务读到了另一个事务未提交的数据。\n转账事务：\n    1. A账户减少100块钱\n    2. B账户增加100块钱\n\n读账户事务：\n    1. 读取A账户的余额若转账事务执行到1，此时数据被读账户事务读取，但转账事务失败，发生了回滚，此时读账户事务读到的数据不再与数据库一致。\n不可重复读\n一个事务读到了另一个事务更新的数据，导致一个事务中前后多次查询结果不一致。\n读账户事务：\n    1. 读取A账户的余额（此时为1000）\n\n转账事务：\n    1. A账户减少100块钱（变为900）\n    2. B账户增加100块钱\n\n读账户事务：\n    2. 读取A账户的余额（此时为900）幻读\n一个事务读到了另一个事务插入的数据，导致一个事务中前后多次查询结果不一致。\n读账户事务：\n    1. 读取当前账户数量（10）\n\n添加账户事务：\n    1. 添加一个账户（11）\n\n读账户事务：\n    2. 读取当前账户数量（11）事务的隔离级别为了消除事务间的影响，提出了事务的隔离级别。\nRead Uncommitted\n可读未提交的数据，不能解决任何问题。\nRead Committed\n只能读已提交的数据。可解决脏读。\nRepetable Read\n一个事务开始了读操作后，不允许其他事务再进行修改操作。可解决不可重复读。\nSerialiable\n所有事务必须串行执行，可解决所有问题，但效率很低。\nD(Durability)通过事务日志来实现。\nSpring声明式事务配置事务管理器PlatformTransactionManager有两个实现类\nDataSourceTransactionManager使用JDBC管理事务\nHibernateTransactionManager使用Hibernate管理事务\n1234&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;    &lt;!--注入数据源--&gt;    &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;\n\n配置事务通知需要引入tx约束\n需要注入事务管理器\ntx:method中name指定方法名\ntx:method中isolation指定隔离级别\ntx:method中propagation指定传播行为\ntx:method中read-only指定是否为只读事务\ntx:method中timeout指定事务超时时间，若超过该时间事务还未完成则事务自动回滚，单位为秒\ntx:method中rollback-for与no-rollback-for控制事务回滚\n123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC&amp;amp;useSSL=false\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"LQ18851195070\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;tx:advice id=\"transactionAdvice\" transaction-manager=\"transactionManager\"&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" timeout=\"-1\"/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;&lt;/beans&gt;\n\n配置事务AOP切面将通知应用到业务层方法上。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC&amp;amp;useSSL=false\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"LQ18851195070\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;tx:advice id=\"transactionAdvice\" transaction-manager=\"transactionManager\"&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" timeout=\"-1\"/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id=\"serviceImplPointcut\" expression=\"execution(public void service.impl.AccountServiceImpl.transfer(int, int, int))\"/&gt;        &lt;aop:advisor advice-ref=\"transactionAdvice\" pointcut-ref=\"serviceImplPointcut\"&gt;&lt;/aop:advisor&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\n事务的传播行为我们的事务目前加在Service中的方法上，但当业务逻辑特别复杂时，可能出现业务层方法互相调用的情况，这时候需要需要使用传播行为来管理两个方法间的事务关系。\n1234567891011public MockService&#123;  public void A()&#123;    doSomethingA();  &#125;  public void B()&#123;    A()    doSomethingB();  &#125;&#125;\n\n保证在同一事务中PROPOGATION_REQUIRED\n若A中有事务，则使用A中的事务将B方法全部包括起来\n若A中无事务，则创建一个新的事务，将B方法全部包括起来\nPROPOGATION_SUPPORTS\n若A中有事务，则使用A中的事务将B方法全部包括起来\n若A中无事务，则B方法不使用事务\nPROPOGATION_MANDATORY\n若A中有事务，则使用A中的事务将B方法全部包括起来\n若A中无事务，抛出异常\n保证不在同一事务中PROPOGATION_REQUIRE_NEW\n若A中有事务，将A的事务暂停，创建一个新事务，只包括B本身的操作doSomethingB()\n若A中无事务，创建一个新事务，只包括B本身的操作doSomethingB()\nPROPOGATION_NOT_SUPPORTS\n若A中有事务，将A的事务暂停，不使用事务管理。\nPROPOGATION_NEVER\n如果A中有事务，抛出异常。\n嵌套事务PROPOGATION_NESTED\n若A中有事务，按照A的事务执行，执行完后，设置一个保存点\n执行B中的操作doSomethingB()无异常，执行成功\n有异常，可以回滚到初始状态，也可以回滚到保存点\n\n事务回滚控制Spring中默认只有当事务执行时发生了RuntimeException或Error时会发生事务回滚，因此在发生了非运行期异常时，不会发生回滚。\n回滚控制使用rollback-for指定遇到什么类型的异常时发生回滚。\n123456&lt;tx:advice id=\"transactionAdvice\" transaction-manager=\"transactionManager\"&gt;    &lt;tx:attributes&gt;        &lt;!--发生所有异常时都回滚--&gt;        &lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" timeout=\"-1\" no-rollback-for=\"Exception\"/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;\n\n不回滚控制使用no-rollback-for指定遇到什么类型的异常时不发生回滚。\n12345&lt;tx:advice id=\"transactionAdvice\" transaction-manager=\"transactionManager\"&gt;    &lt;tx:attributes&gt;        &lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\" timeout=\"-1\" no-rollback-for=\"ArithmeticException\"/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;","thumbnail":"post/Java/Spring/6-Spring之事务管理/cover.png","plink":"https://beginc.github.io/post/Java/Spring/6-Spring之事务管理/"},{"title":"5-Spring之JdbcTemplate","date":"2020-01-26T14:03:32.000Z","date_formatted":{"ll":"Jan 26, 2020","L":"01/26/2020","MM-DD":"01-26"},"updated":"2020-02-29T08:59:25.483Z","content":"引入依赖Spring Context\nSpring JDBC\nSpring TX\nAspectJ Weaver\nMySQL 驱动\nJunit\n12345678910111213141516171819202122232425262728&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.9.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n创建表1234CREATE TABLE account(  id INT PRIMARY KEY AUTO_INCREMENT,  money INT NOT NULL DEFAULT 0)\n\nJdbcTemplate配置配置数据源12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"LQ18851195070\"&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n配置JdbcTemplate注入DataSource\n1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"LQ18851195070\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n注入JdbcTemplate到DAO层1234567891011121314151617public class AccountDaoImpl implements AccountDao &#123;    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    @Override    public void in(int id, int num) &#123;        System.out.println(\"[Account\" + id + \"]: \" + \"收了\" + num + \"元钱\");    &#125;    @Override    public void out(int id, int num) &#123;        System.out.println(\"[Account\" + id + \"]: \" + \"花了\" + num + \"元钱\");    &#125;&#125;\n\n123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;        &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"LQ18851195070\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nJdbcTemplate使用建立Account类\n123456789101112131415161718192021222324252627282930313233343536public class Account &#123;    private Integer id;    private Integer money;    public Account(Integer id, Integer money) &#123;        this.id = id;        this.money = money;    &#125;    public Account() &#123;    &#125;    @Override    public String toString() &#123;        return \"Account&#123;\" +                \"id=\" + id +                \", money=\" + money +                '&#125;';    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public Integer getMoney() &#123;        return money;    &#125;    public void setMoney(Integer money) &#123;        this.money = money;    &#125;&#125;\n\n增增加一个账户\n使用`update`方法，带可变参数123456789101112public class AccountDaoImpl implements AccountDao &#123;    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    @Override    public void insert(Account account) &#123;        jdbcTemplate.update(\"insert into account (money) values (?)\", account.getMoney());    &#125;&#125;\n\n删删除一个账户\n使用`update`方法，带可变参数123456789101112public class AccountDaoImpl implements AccountDao &#123;    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    @Override    public void delete(int id) &#123;        jdbcTemplate.update(\"delete from account where id = ?\", id);    &#125;&#125;\n\n改账户收钱\n\n账户花钱\n  使用update方法，带可变参数\n\n123456789101112public class AccountDaoImpl implements AccountDao &#123;    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    @Override    public void out(int id, int num) &#123;        jdbcTemplate.update(\"update account set money = money - ? where id = ?\", id, num);    &#125;&#125;\n\n查查询一个账户\n查询所有账户\n查询用户数量\n对象封装方式一\n使用自带的BeanPropertyRowMapper对象，自动封装。\n对象封装方式二\n使用实现RowMapper接口的对象，手动封装。\n12345678910111213141516171819202122232425262728293031323334public class AccountDaoImpl implements AccountDao &#123;    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;        this.jdbcTemplate = jdbcTemplate;    &#125;    @Override    public Account find(int id) &#123;        List&lt;Account&gt; account = jdbcTemplate.query(\"select * from account where id = ?\", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id);        return account.size() != 0 ? account.get(0) : null;    &#125;    @Override    public List&lt;Account&gt; findAll() &#123;        List&lt;Account&gt; account = jdbcTemplate.query(\"select * from account\", new RowMapper&lt;Account&gt;() &#123;            @Override            public Account mapRow(ResultSet resultSet, int i) throws SQLException &#123;                Account account = new Account();                account.setId(resultSet.getInt(1));                account.setMoney(resultSet.getInt(2));                return account;            &#125;        &#125;);        return account;    &#125;    @Override    public int findAccountNum() &#123;        int accountNum = jdbcTemplate.queryForObject(\"select count(1) from account\", Integer.class);        return accountNum;    &#125;&#125;\n\nJdbcDaoSupport若继承JdbcDaoSupport类，则只需注入dataSource对象，注入时会自动创建jdbcTemplate对象。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123;    @Override    public void insert(Account account) &#123;        getJdbcTemplate().update(\"insert into account (money) values (?)\", account.getMoney());    &#125;    @Override    public void delete(int id) &#123;        getJdbcTemplate().update(\"delete from account where id = ?\", id);    &#125;    @Override    public void in(int id, int num) &#123;        getJdbcTemplate().update(\"update account set money = money + ? where id = ?\", id, num);    &#125;    @Override    public void out(int id, int num) &#123;        getJdbcTemplate().update(\"update account set money = money - ? where id = ?\", id, num);    &#125;    @Override    public Account find(int id) &#123;        List&lt;Account&gt; account = getJdbcTemplate().query(\"select * from account where id = ?\", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id);        return account.size() != 0 ? account.get(0) : null;    &#125;    @Override    public List&lt;Account&gt; findAll() &#123;        List&lt;Account&gt; account = getJdbcTemplate().query(\"select * from account\", new RowMapper&lt;Account&gt;() &#123;            @Override            public Account mapRow(ResultSet resultSet, int i) throws SQLException &#123;                Account account = new Account();                account.setId(resultSet.getInt(1));                account.setMoney(resultSet.getInt(2));                return account;            &#125;        &#125;);        return account;    &#125;    @Override    public int findAccountNum() &#123;        int accountNum = getJdbcTemplate().queryForObject(\"select count(1) from account\", Integer.class);        return accountNum;    &#125;&#125;\n\n1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC&amp;amp;useSSL=false\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"LQ18851195070\"&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;","thumbnail":"post/Java/Spring/5-Spring之JdbcTemplate/cover.png","plink":"https://beginc.github.io/post/Java/Spring/5-Spring之JdbcTemplate/"},{"title":"4-Spring之AOP","date":"2020-01-26T12:35:27.000Z","date_formatted":{"ll":"Jan 26, 2020","L":"01/26/2020","MM-DD":"01-26"},"updated":"2020-02-29T08:59:22.503Z","content":"创建Maven项目编译设置12345678910111213141516171819202122232425&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;spring-02&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                    &lt;source&gt;11&lt;/source&gt;                    &lt;target&gt;11&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n引入依赖Spring Context\nAspectJ Weaver\nJunit\n123456789101112131415161718&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.9.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n创建applicationContext.xml要引入aop约束\n12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;/beans&gt;\n\n模拟Web MVC三层DAO1234567891011public class AccountDaoImpl implements AccountDao &#123;    @Override    public void in(int id, int num) &#123;        System.out.println(\"[Account\" + id + \"]: \" + \"收了\" + num + \"元钱\");    &#125;    @Override    public void out(int id, int num) &#123;        System.out.println(\"[Account\" + id + \"]: \" + \"花了\" + num + \"元钱\");    &#125;&#125;\n\nService12345678910111213public class AccountServiceImpl implements AccountService &#123;    private AccountDao accountDao;    public void setAccountDao(AccountDao accountDao) &#123;        this.accountDao = accountDao;    &#125;    @Override    public void transfer(int src, int dest, int num) &#123;        accountDao.in(dest, num);        accountDao.out(src, num);    &#125;&#125;\n\nController1234567891011public class AccountController &#123;    private AccountService accountService;    public void setAccountService(AccountService accountService) &#123;        this.accountService = accountService;    &#125;    public void transfer() &#123;        accountService.transfer(1, 2, 100);    &#125;&#125;\n\nAOP基本概念Joinpoint接入点可以被拦截的点，在Spring中指被增强类的方法。\nPointcut切入点Joinpoint中被增强的点，在Spring中指被增强的方法。\nAdvice通知即对切入点进行的增强。\n前置通知\n后置通知\n异常通知\n最终通知\n环绕通知\nIntroduction引介是一种特殊的通知，可以在不修改类的代码的前提下，动态地为其添加一些方法或属性。\nTarget目标对象代理的目标对象。\nWeaving织入把增强引用到目标对象，创建代理对象的过程。\nProxy代理目标对象织入增强后产生的代理对象。\nAspect切面多个切入点和多个通知的结合。\nAOP需求在transfer转账之前记录日志（前置通知）\n在transfer转账之后记录日志（后置通知）\n在transfer转账发生异常时记录日志（异常通知）\n在transfer转账不管正不正常执行都记录日志（最终通知）\n编写增强类12345678910111213141516171819public class Logger &#123;    void before() &#123;        System.out.println(\"[Before]: 记录日志\");    &#125;    void after() &#123;        System.out.println(\"[After]: 记录日志\");    &#125;    void afterReturning() &#123;        System.out.println(\"[AfterReturning]: 记录日志\");    &#125;    void afterThrowing() &#123;        System.out.println(\"[After-Throwing]: 记录日志\");    &#125;&#125;\n\n配置AOP增强类和被增强类交给Spring管理\n配置切入点\n配置切面\n12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--将增强类交给Spring管理--&gt;    &lt;bean id=\"logger\" class=\"aop.Logger\"&gt;    &lt;/bean&gt;    &lt;!--aop配置--&gt;    &lt;aop:config&gt;        &lt;!--切入点配置--&gt;        &lt;aop:pointcut id=\"accountServicePointcut\" expression=\"execution(public void service.impl.AccountServiceImpl.transfer(int, int, int))\"/&gt;        &lt;!--增强配置--&gt;        &lt;aop:aspect id=\"loggerAdvice\" ref=\"logger\"&gt;            &lt;aop:before method=\"before\" pointcut-ref=\"accountServicePointcut\"&gt;&lt;/aop:before&gt;            &lt;aop:after method=\"after\" pointcut-ref=\"accountServicePointcut\"&gt;&lt;/aop:after&gt;            &lt;aop:after-returning method=\"afterReturning\" pointcut-ref=\"accountServicePointcut\"&gt;&lt;/aop:after-returning&gt;            &lt;aop:after-throwing method=\"afterThrowing\" pointcut-ref=\"accountServicePointcut\"&gt;&lt;/aop:after-throwing&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\n切入点表达式格式\nexecution(访问修饰符 返回值类型 包名.包名.类名.方法名(参数类型，参数类型))访问修饰符\n可以省略\n返回值\n可使用通配符*\n包名\ncn.edu.njust.service.impl直接全写出来\ncn.edu.njust.*.*通配符\ncn.edu.njust..当前包及其子包\n类名\n可使用通配符*\n方法名\n可使用通配符*\n参数名\n(int, int)直接写出来\n(*, *)通配符匹配任意类型，但必须有参数\n(..)匹配任意参数，可以没有参数\n通知aop:before前置通知\naop:after最终通知\naop:after-returning后置通知\naop:after-throwing异常通知\naop:around环绕通知\n环绕通知使用环绕通知可编程式增强方法。现在使用环绕通知实现上述需求。\n环绕通知方法\n12345678910111213141516171819202122232425262728293031323334353637383940public class Logger &#123;    void before() &#123;        System.out.println(\"[Before]: 记录日志\");    &#125;    void after() &#123;        System.out.println(\"[After]: 记录日志\");    &#125;    void afterReturning() &#123;        System.out.println(\"[AfterReturning]: 记录日志\");    &#125;    void afterThrowing() &#123;        System.out.println(\"[After-Throwing]: 记录日志\");    &#125;    Object around(ProceedingJoinPoint proceedingJoinPoint)&#123;        try&#123;            // 前置            before();            Object[] args = proceedingJoinPoint.getArgs();            // 方法调用            Object returnVal = proceedingJoinPoint.proceed(args);            // 后置            afterReturning();            return returnVal;        &#125; catch (Throwable throwable) &#123;            // 异常            afterThrowing();            throwable.printStackTrace();        &#125; finally &#123;            // 最终            after();        &#125;        return null;    &#125;&#125;\n\n环绕通知配置\n12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;    &lt;bean id=\"accountDao\" class=\"dao.impl.AccountDaoImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\"&gt;        &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"accountController\" class=\"controller.AccountController\"&gt;        &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--将增强类交给Spring管理--&gt;    &lt;bean id=\"logger\" class=\"aop.Logger\"&gt;    &lt;/bean&gt;    &lt;!--aop配置--&gt;    &lt;aop:config&gt;        &lt;!--切入点配置--&gt;        &lt;aop:pointcut id=\"accountServicePointcut\" expression=\"execution(public void service.impl.AccountServiceImpl.transfer(int, int, int))\"/&gt;        &lt;!--增强配置--&gt;        &lt;aop:aspect id=\"loggerAdvice\" ref=\"logger\"&gt;            &lt;aop:around method=\"around\" pointcut-ref=\"accountServicePointcut\"&gt;&lt;/aop:around&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;","thumbnail":"post/Java/Spring/4-Spring之AOP/cover.png","plink":"https://beginc.github.io/post/Java/Spring/4-Spring之AOP/"},{"title":"3-Spring之Bean依赖注入","date":"2020-01-25T14:21:56.000Z","date_formatted":{"ll":"Jan 25, 2020","L":"01/25/2020","MM-DD":"01-25"},"updated":"2020-02-29T08:59:19.936Z","content":"建立测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class DITest &#123;    private int basic;    private String string;    private Date ref;    private int[] array;    private List&lt;Integer&gt; list;    private Set&lt;Integer&gt; set;    private Map&lt;String, Integer&gt; map;    private Properties prop;    public DITest(int basic, String string, Date ref, int[] array, List&lt;Integer&gt; list, Set&lt;Integer&gt; set, Map&lt;String, Integer&gt; map, Properties prop) &#123;        this.basic = basic;        this.string = string;        this.ref = ref;        this.array = array;        this.list = list;        this.set = set;        this.map = map;        this.prop = prop;    &#125;    public DITest() &#123;    &#125;    @Override    public String toString() &#123;        return \"DITest&#123;\" +                \"basic=\" + basic +                \", string='\" + string + '\\'' +                \", ref=\" + ref +                \", array=\" + Arrays.toString(array) +                \", list=\" + list +                \", set=\" + set +                \", map=\" + map +                \", prop=\" + prop +                '&#125;';    &#125;    public void setBasic(int basic) &#123;        this.basic = basic;    &#125;    public void setString(String string) &#123;        this.string = string;    &#125;    public void setRef(Date ref) &#123;        this.ref = ref;    &#125;    public void setArray(int[] array) &#123;        this.array = array;    &#125;    public void setList(List&lt;Integer&gt; list) &#123;        this.list = list;    &#125;    public void setSet(Set&lt;Integer&gt; set) &#123;        this.set = set;    &#125;    public void setMap(Map&lt;String, Integer&gt; map) &#123;        this.map = map;    &#125;    public void setProp(Properties prop) &#123;        this.prop = prop;    &#125;&#125;\n\n注入方式构造函数注入Spring调用带参构造函数，传入参数来进行依赖注入。\n123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"t1\" class=\"pojo.DITest\"&gt;        &lt;constructor-arg index=\"0\" value=\"1\"/&gt;        &lt;constructor-arg type=\"java.lang.String\" value=\"String\"/&gt;        &lt;constructor-arg name=\"string\" value=\"0\"/&gt;        &lt;!--以下属性省略--&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nIndex注入按构造函数参数列表参数顺序注入（从0开始）。\nType注入按构造函数参数列表中参数的类型注入。\nName注入按构造函数参数列表中参数的名称注入。\nSetter注入Spring调用默认构造函数实例化对象，再通过属性的Setter方法来注入依赖。\n12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"t1\" class=\"pojo.DITest\"&gt;        &lt;property name=\"basic\" value=\"1\"/&gt;        &lt;!--以下属性省略--&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n注入类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"date\" class=\"java.util.Date\"&gt;&lt;/bean&gt;    &lt;bean id=\"testBean\" class=\"pojo.DITest\"&gt;        &lt;property name=\"basic\" value=\"1\"&gt;&lt;/property&gt;        &lt;property name=\"string\" value=\"str\"&gt;&lt;/property&gt;        &lt;property name=\"ref\" ref=\"date\"&gt;&lt;/property&gt;        &lt;property name=\"array\"&gt;            &lt;array&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;        &lt;property name=\"list\"&gt;            &lt;list&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;property name=\"set\"&gt;            &lt;set&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/set&gt;        &lt;/property&gt;        &lt;property name=\"map\"&gt;            &lt;map&gt;                &lt;entry key=\"1\" value=\"1\"/&gt;                &lt;entry key=\"2\"&gt;                    &lt;value&gt;2&lt;/value&gt;                &lt;/entry&gt;                &lt;entry key=\"3\" value=\"3\"/&gt;            &lt;/map&gt;        &lt;/property&gt;        &lt;property name=\"prop\"&gt;            &lt;props&gt;                &lt;prop key=\"1\"&gt;1&lt;/prop&gt;                &lt;prop key=\"2\"&gt;2&lt;/prop&gt;                &lt;prop key=\"3\"&gt;3&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n基本类型和String用value指定。\n对象类型用ref引用。\n集合类型Array1234567&lt;property name=\"array\"&gt;    &lt;array&gt;        &lt;value&gt;1&lt;/value&gt;        &lt;value&gt;2&lt;/value&gt;        &lt;value&gt;3&lt;/value&gt;    &lt;/array&gt;&lt;/property&gt;\nList1234567&lt;property name=\"list\"&gt;    &lt;list&gt;        &lt;value&gt;1&lt;/value&gt;        &lt;value&gt;2&lt;/value&gt;        &lt;value&gt;3&lt;/value&gt;    &lt;/list&gt;&lt;/property&gt;\nSet1234567&lt;property name=\"set\"&gt;    &lt;set&gt;        &lt;value&gt;1&lt;/value&gt;        &lt;value&gt;2&lt;/value&gt;        &lt;value&gt;3&lt;/value&gt;    &lt;/set&gt;&lt;/property&gt;\nMap123456789&lt;property name=\"map\"&gt;    &lt;map&gt;        &lt;entry key=\"1\" value=\"1\"/&gt;        &lt;entry key=\"2\"&gt;            &lt;value&gt;2&lt;/value&gt;        &lt;/entry&gt;        &lt;entry key=\"3\" value=\"3\"/&gt;    &lt;/map&gt;&lt;/property&gt;\n\nProperties1234567&lt;property name=\"prop\"&gt;    &lt;props&gt;        &lt;prop key=\"1\"&gt;1&lt;/prop&gt;        &lt;prop key=\"2\"&gt;2&lt;/prop&gt;        &lt;prop key=\"3\"&gt;3&lt;/prop&gt;    &lt;/props&gt;&lt;/property&gt;\n\n空123&lt;property name=\"prop\"&gt;    &lt;null/&gt;&gt;&lt;/property&gt;\n\nBean的继承Bean的继承可以复用配置，简化XML。\nabstract指定的Bean只能被继承，不能被实例化\nparent指定父Bean\nmerge集合属性配置中都可以设置merge为true来合并与父Bean的配置，而不是代替\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"date\" class=\"java.util.Date\"&gt;&lt;/bean&gt;    &lt;bean id=\"parent\" class=\"pojo.DITest\" abstract=\"true\"&gt;        &lt;property name=\"basic\" value=\"1\"&gt;&lt;/property&gt;        &lt;property name=\"string\" value=\"str\"&gt;&lt;/property&gt;        &lt;property name=\"ref\" ref=\"date\"&gt;&lt;/property&gt;        &lt;property name=\"array\"&gt;            &lt;array&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;        &lt;property name=\"list\"&gt;            &lt;list&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;property name=\"set\"&gt;            &lt;set&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/set&gt;        &lt;/property&gt;        &lt;property name=\"map\"&gt;            &lt;map&gt;                &lt;entry key=\"1\" value=\"1\"/&gt;                &lt;entry key=\"2\"&gt;                    &lt;value&gt;2&lt;/value&gt;                &lt;/entry&gt;                &lt;entry key=\"3\" value=\"3\"/&gt;            &lt;/map&gt;        &lt;/property&gt;        &lt;property name=\"prop\"&gt;            &lt;props&gt;                &lt;prop key=\"1\"&gt;1&lt;/prop&gt;                &lt;prop key=\"2\"&gt;2&lt;/prop&gt;                &lt;prop key=\"3\"&gt;3&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=\"child\" class=\"pojo.DITest\" parent=\"parent\"&gt;        &lt;property name=\"basic\" value=\"2\"&gt;&lt;/property&gt;        &lt;property name=\"array\"&gt;            &lt;array merge=\"true\"&gt;                &lt;value&gt;4&lt;/value&gt;                &lt;value&gt;5&lt;/value&gt;                &lt;value&gt;6&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;","thumbnail":"post/Java/Spring/3-Spring之Bean依赖注入/cover.png","plink":"https://beginc.github.io/post/Java/Spring/3-Spring之Bean依赖注入/"},{"title":"2-Spring之Bean管理","date":"2020-01-25T13:40:15.000Z","date_formatted":{"ll":"Jan 25, 2020","L":"01/25/2020","MM-DD":"01-25"},"updated":"2020-02-29T08:59:17.790Z","content":"Bean的创建直接创建下列三个Bean都是直接调用默认构造函数创建。\n1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"service.impl.UserServiceImpl\"&gt;        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\"&gt;        &lt;property name=\"userService\" ref=\"userService\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n实例工厂创建实例化一个工厂，然后通过该工厂来创建对象。\n建立工厂类123456public class UserDaoInstanceFactory &#123;    public UserDao getInstance()&#123;        return new UserDaoImpl();    &#125;&#125;\n\n配置applicationContext.xml配置示例工厂Bean\nfactory-bean指明实例工厂Bean\nfactory-method指明实例工厂Bean创建对象的方法\n1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"instanceFactory\" class=\"factory.UserDaoInstanceFactory\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\" factory-bean=\"instanceFactory\" factory-method=\"getInstance\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"service.impl.UserServiceImpl\"&gt;        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\"&gt;        &lt;property name=\"userService\" ref=\"userService\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n静态工厂创建工厂采用静态方法创建对象，无需实例化。\n建立工厂类123456public class UserServiceStaticFactory &#123;    public static UserService getInstance() &#123;        return new UserServiceImpl();    &#125;&#125;\n\n配置applicationContext.xmlclass填工厂类\nfactory-method指明静态工厂Bean创建对象的方法\n12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"instanceFactory\" class=\"factory.UserDaoInstanceFactory\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\" factory-bean=\"instanceFactory\" factory-method=\"getInstance\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"factory.UserServiceStaticFactory\" factory-method=\"getInstance\"&gt;        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\"&gt;        &lt;property name=\"userService\" ref=\"userService\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nBean的作用范围通过scope指定。\n1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"instanceFactory\" class=\"factory.UserDaoInstanceFactory\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\" factory-bean=\"instanceFactory\" factory-method=\"getInstance\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"factory.UserServiceStaticFactory\" factory-method=\"getInstance\"&gt;        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\" scope=\"prototype\"&gt;        &lt;property name=\"userService\" ref=\"userService\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nSingleton单例，一个Bean只会被创建一次，多次获取，为同一个对象。\nPrototype多例，每次获取都会重新创建一个对象。\nRequestTODO\nSessionTODO\nGlobalTODO\nBean的生命周期创建单例IoC容器创建时对象就被创建。\n多例获取Bean时才创建。\n生命周期方法init-method\n123456789101112131415public class UserController &#123;    private UserService userService;    public void save()&#123;        userService.save();    &#125;    public void setUserService(UserService userService) &#123;        this.userService = userService;    &#125;    public void init()&#123;        System.out.println(\"Init User Controller...\");    &#125;&#125;\n\n1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"instanceFactory\" class=\"factory.UserDaoInstanceFactory\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\" factory-bean=\"instanceFactory\" factory-method=\"getInstance\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"factory.UserServiceStaticFactory\" factory-method=\"getInstance\"&gt;        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\" scope=\"singleton\" init-method=\"init\"&gt;        &lt;property name=\"userService\" ref=\"userService\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n销毁单例IoC容器关闭时销毁。\n多例GC回收时销毁。\n生命周期方法destroy-method\n12345678910111213141516171819public class UserController &#123;    private UserService userService;    public void save()&#123;        userService.save();    &#125;    public void setUserService(UserService userService) &#123;        this.userService = userService;    &#125;    public void init()&#123;        System.out.println(\"Init User Controller...\");    &#125;    public void destroy()&#123;        System.out.println(\"Destroy User Controller...\");    &#125;&#125;\n\n1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"instanceFactory\" class=\"factory.UserDaoInstanceFactory\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\" factory-bean=\"instanceFactory\" factory-method=\"getInstance\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"factory.UserServiceStaticFactory\" factory-method=\"getInstance\"&gt;        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\" scope=\"singleton\" init-method=\"init\" destroy-method=\"destroy\"&gt;        &lt;property name=\"userService\" ref=\"userService\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;","thumbnail":"post/Java/Spring/2-Spring之Bean管理/cover.png","plink":"https://beginc.github.io/post/Java/Spring/2-Spring之Bean管理/"},{"title":"1-Spring入门","date":"2020-01-25T13:16:35.000Z","date_formatted":{"ll":"Jan 25, 2020","L":"01/25/2020","MM-DD":"01-25"},"updated":"2020-01-25T15:14:33.927Z","content":"创建Maven项目编译设置123456789101112131415161718192021&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;spring-01&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;11&lt;/source&gt;                    &lt;target&gt;11&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n引入依赖Spring Context\nJunit\n12345678910111213&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n创建applicationContext.xml123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;/beans&gt;\n\n模拟Web MVC三层DAO123456public class UserDaoImpl implements UserDao &#123;    @Override    public void save() &#123;        System.out.println(\"Save user...\");    &#125;&#125;\n\nService123456789101112public class UserServiceImpl implements UserService &#123;    private UserDao userDao;    @Override    public void save() &#123;        userDao.save();    &#125;    public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;    &#125;&#125;\n\nController1234567891011public class UserController &#123;    private UserService userService;    public void save()&#123;        userService.save();    &#125;    public void setUserService(UserService userService) &#123;        this.userService = userService;    &#125;&#125;\n\nIoC入门使用将UserDao，UserService，UserController交给IoC容器来管理，让Spring帮我们创建对象。\n123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"service.impl.UserServiceImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\"&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\nDI入门使用将UserDao注入UserService，将UserService注入UserController。\n1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\"&gt;    &lt;/bean&gt;    &lt;bean id=\"userService\" class=\"service.impl.UserServiceImpl\"&gt;        &lt;property name=\"userDao\" ref=\"userDao\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"userController\" class=\"controller.UserController\"&gt;        &lt;property name=\"userService\" ref=\"userService\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n编写测试123456789public class Test01 &#123;    @Test    public void test01() &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");        UserController userController = context.getBean(\"userController\", UserController.class);        userController.save();    &#125;&#125;","thumbnail":"post/Java/Spring/1-Spring入门/cover.png","plink":"https://beginc.github.io/post/Java/Spring/1-Spring入门/"},{"title":"Leetcode-80-删除排序数组中的重复项II","date":"2020-01-24T03:25:02.000Z","date_formatted":{"ll":"Jan 24, 2020","L":"01/24/2020","MM-DD":"01-24"},"updated":"2020-02-08T02:32:43.712Z","content":"题目给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n示例示例 1:\n    给定 nums = [1,1,1,2,2,3],\n函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。示例 2:\n    给定 nums = [0,0,1,1,1,1,2,3,3],\n函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。解法1：单指针 + slots + lastEl + num思路同Leetcode-26-删除排序数组中的重复项解法1，只不过我们增加一个num来记录元素重复出现的次数。\n当前元素nums[i]\nnums[i] == lastEl 出现重复元素num &gt;= 2 重复出现了2次及以上，slots++删除掉该元素\nnum &lt; 2 重复出现了不足2次，num++记录数量，并将该元素向前移动slots个位置\n\nnums[i] != lastEl 出现下一个非重复元素，将元素向前移动slots个位置，并将lastEl设为当前元素, num = 1重置计数器\n123456789101112131415161718192021222324252627public int removeDuplicates(int[] nums) &#123;    if(nums.length == 0 || nums.length == 1)        return nums.length;    int slots = 0;    int lastEl = nums[0];    // 记录上个元素出现的次数    int num = 1;    for (int i = 1; i &lt; nums.length; i++) &#123;        if(nums[i] == lastEl)&#123;            if(num &gt;= 2)                slots++;            else&#123;                num++;                nums[i - slots] = nums[i];            &#125;        &#125;        else&#123;            nums[i - slots] = nums[i];            lastEl = nums[i];            num = 1;        &#125;    &#125;    return nums.length - slots;&#125;\n复杂度分析时间线性扫描O(n)\n空间O(1)\n进一步分析当待删除元素出现在前半部分时，要移动的元素数量较多\n当待删除元素出现在后半部分时，要移动的元素数量较少\n当无待删除元素时，无需移动元素\n解法2：","thumbnail":"post/数据结构与算法/Leetcode-80-删除排序数组中的重复项II/cover.jpg","plink":"https://beginc.github.io/post/数据结构与算法/Leetcode-80-删除排序数组中的重复项II/"},{"title":"Leetcode-26-删除排序数组中的重复项","date":"2020-01-24T03:08:16.000Z","date_formatted":{"ll":"Jan 24, 2020","L":"01/24/2020","MM-DD":"01-24"},"updated":"2020-02-08T02:32:34.963Z","content":"题目给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n示例示例 1:\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n你不需要考虑数组中超出新长度后面的元素。示例 2:\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。解法1：单指针 + lastEl + slots思路同Leetcode-27-移除元素解法1，只不过我们增加一个lastEl来记录上次的元素是什么。\n当前元素nums[i]\nnums[i] == lastEl 出现重复元素，slots++，直接继续向前扫描\nnums[i] != lastEl 出现下一个非重复元素，将元素向前移动slots个位置，并将lastEl设为当前元素\n123456789101112131415161718public int removeDuplicates(int[] nums) &#123;    if(nums.length == 0 || nums.length == 1)        return nums.length;    int slots = 0;    int lastEl = nums[0];    for (int i = 1; i &lt; nums.length; i++) &#123;        if(nums[i] == lastEl)            slots++;        else&#123;            nums[i - slots] = nums[i];            lastEl = nums[i];        &#125;    &#125;    return nums.length - slots;&#125;\n\n复杂度分析时间线性扫描O(n)\n空间O(1)\n进一步分析当待删除元素出现在前半部分时，要移动的元素数量较多\n当待删除元素出现在后半部分时，要移动的元素数量较少\n当无待删除元素时，无需移动元素\n解法2：双前向指针思路同Leetcode-27-移除元素解法2\n当前元素nums[j]\nnums[j] == num[i] 出现重复元素，直接继续向前扫描\nnums[j] != num[i] 出现下一个非重复元素，将当前元素拷贝到nums[i + 1], 并将i++\n1234567891011public int removeDuplicates(int[] nums) &#123;    if (nums.length == 0) return 0;    int i = 0;    for (int j = 1; j &lt; nums.length; j++) &#123;        if (nums[j] != nums[i]) &#123;            i++;            nums[i] = nums[j];        &#125;    &#125;    return i + 1;&#125;\n\n复杂度分析时间线性扫描O(n)\n空间O(1)\n进一步分析只需移动非重复元素，效率高\n","thumbnail":"post/数据结构与算法/Leetcode-26-删除排序数组中的重复项/cover.jpg","plink":"https://beginc.github.io/post/数据结构与算法/Leetcode-26-删除排序数组中的重复项/"},{"title":"Leetcode-27-移除元素","date":"2020-01-24T02:14:26.000Z","date_formatted":{"ll":"Jan 24, 2020","L":"01/24/2020","MM-DD":"01-24"},"updated":"2020-02-08T02:32:39.476Z","content":"题目给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例示例 1:\n给定 nums = [3,2,2,3], val = 3,\n\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n\n你不需要考虑数组中超出新长度后面的元素。示例 2:\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n\n注意这五个元素可为任意顺序。\n\n你不需要考虑数组中超出新长度后面的元素。解法1：单指针 + slots单指针扫描数组\nslots用来记录当前已经删除掉的元素数量\n当nums[i] != val时，元素向前移动slots个位置，当nums[i] == val时，slots++，继续向前扫描。\n1234567891011public int removeElement(int[] nums, int val) &#123;    int slots = 0;    for (int i = 0; i &lt; nums.length; i++) &#123;        if (nums[i] == val)            slots++;        else            nums[i - slots] = nums[i];    &#125;    return nums.length - slots;&#125;\n复杂度分析时间线性扫描O(n)\n空间O(1)\n进一步分析当待删除元素出现在前半部分时，要移动的元素数量较多\n当待删除元素出现在后半部分时，要移动的元素数量较少\n当无待删除元素时，无需移动元素\n解法2：双前向指针指针i记录当前非目标元素的个数\n指针j负责持续前向扫描\n当前元素nums[j]:\nnums[j] == val，直接跳过，继续向前扫描\nnums[j] != val，将该元素拷贝到nums[i]\n12345678910public int removeElement(int[] nums, int val) &#123;    int i = 0;    for (int j = 0; j &lt; nums.length; j++) &#123;        if (nums[j] != val) &#123;            nums[i] = nums[j];            i++;        &#125;    &#125;    return i;&#125;\n\n复杂度分析时间线性扫描O(n)\n空间O(1)\n进一步分析所有非目标元素都需要移动，无效移动次数太多\n解法3：双指针(一正一反)指针i负责持续前向扫描\n指针n记录当前数组的有效长度\n当前元素nums[i]:\nnums[i] == val，互换nums[i] 与nums[n - 1]\nnums[i] != val，继续向前扫描\n1234567891011121314public int removeElement(int[] nums, int val) &#123;    int i = 0;    int n = nums.length;    while (i &lt; n) &#123;        if (nums[i] == val) &#123;            nums[i] = nums[n - 1];            // reduce array size by one            n--;        &#125; else &#123;            i++;        &#125;    &#125;    return n;&#125;\n\n复杂度分析时间线性扫描O(n)\n空间O(1)\n进一步分析移动的次数为目标元素的个数，避免了无效移动\n元素会乱序，但是题目不要求保持原有顺序\n","thumbnail":"post/数据结构与算法/Leetcode-27-移除元素/cover.jpg","plink":"https://beginc.github.io/post/数据结构与算法/Leetcode-27-移除元素/"},{"title":"Leetcode目录","date":"2020-01-24T02:10:48.000Z","date_formatted":{"ll":"Jan 24, 2020","L":"01/24/2020","MM-DD":"01-24"},"updated":"2020-02-08T02:32:46.680Z","content":"数组Leetcode-27-移除元素---双指针\nLeetcode-26-删除排序数组中的重复项---双指针\n","thumbnail":"post/数据结构与算法/Leetcode目录/cover.jpg","plink":"https://beginc.github.io/post/数据结构与算法/Leetcode目录/"},{"title":"6-MyBatis注解开发","date":"2020-01-23T14:37:40.000Z","date_formatted":{"ll":"Jan 23, 2020","L":"01/23/2020","MM-DD":"01-23"},"updated":"2020-01-23T16:05:58.975Z","content":"基本操作Select12@Select(\"select * from user\")List&lt;User&gt; findAll();\n\nInsert + SelectKey123@Insert(\"insert into user (username, address, sex, birthday) values (#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;)\")@SelectKey(statement = \"select LAST_INSERT_ID()\", keyColumn = \"id\", keyProperty = \"id\", before = false, resultType = Integer.class)void save(User user);\n\nUpdate12@Update(\"update user set username = #&#123;username&#125;, address = #&#123;address&#125;, sex = #&#123;sex&#125;, birthday = #&#123;birthday&#125; where id = #&#123;id&#125;\")void update(User user);\n\nDelete12@Delete(\"delete from user where id = #&#123;id&#125;\")void delete(Integer id);\n\nResultMap配置Resultsid标记该ResultMap\nvalue数组填充@Result\n1234567891011@Select(\"select * from user\")@Results(        id = \"userMap\",        value = &#123;                @Result(id = true, column = \"id\", property = \"id\"),                @Result(column = \"username\", property = \"username\"),                @Result(column = \"address\", property = \"address\"),                @Result(column = \"birthday\", property = \"birthday\"),        &#125;)List&lt;User&gt; findAll();\n\n使用ResultMap12345678910111213141516171819202122232425262728public interface UserMapper &#123;    @Select(\"select * from user\")    @Results(            id = \"userMap\",            value = &#123;                    @Result(id = true, column = \"id\", property = \"id\"),                    @Result(column = \"username\", property = \"username\"),                    @Result(column = \"address\", property = \"address\"),                    @Result(column = \"birthday\", property = \"birthday\"),            &#125;    )    List&lt;User&gt; findAll();    @Select(\"select * from user where id = #&#123;id&#125;\")    @ResultMap(\"userMap\")    User find(Integer id);    @Insert(\"insert into user (username, address, sex, birthday) values (#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;)\")    @SelectKey(statement = \"select LAST_INSERT_ID()\", keyColumn = \"id\", keyProperty = \"id\", before = false, resultType = Integer.class)    void save(User user);    @Update(\"update user set username = #&#123;username&#125;, address = #&#123;address&#125;, sex = #&#123;sex&#125;, birthday = #&#123;birthday&#125; where id = #&#123;id&#125;\")    void update(User user);    @Delete(\"delete from user where id = #&#123;id&#125;\")    void delete(Integer id);&#125;\n\n关联查询一对多Result里面用many进行指定\n12345678910111213141516@Select(\"select * from user\")@Results(        id = \"userMap\",        value = &#123;                @Result(id = true, column = \"id\", property = \"id\"),                @Result(column = \"username\", property = \"username\"),                @Result(column = \"address\", property = \"address\"),                @Result(column = \"birthday\", property = \"birthday\"),                @Result(                        column = \"id\",                        property = \"accounts\",                        many = @Many(select = \"mapper.AccountMapper.findByUID\", fetchType = FetchType.LAZY)                )        &#125;)List&lt;User&gt; findAll();\n\n一对一Result里面用one指定\n1234567891011121314@Select(\"select * from account\")@Results(        id = \"accountMap\",        value = &#123;                @Result(id = true, column = \"id\", property = \"id\"),                @Result(column = \"money\", property = \"money\"),                @Result(                        column = \"uid\",                        property = \"user\",                        one = @One(select = \"mapper.UserMapper.find\", fetchType = FetchType.EAGER)                )        &#125;)List&lt;Account&gt; findAll();\n\n动态SQL可使用SelectProvider, UpdateProvider, InsertProvider, DeleteProvider，通过定义一个Provider类，通过类中的方法动态进行SQL语句生成，从而实现动态SQL的效果。\n注解SelectProvider注解标识Provider\ntype指定Provider类\nmethod指定Provider中用于生成该SQL的方法\nParam注解用于指定参数名称（Provider用map接收参数，取参数时，若指定了参数名就用参数名取，若没有指定，则使用参数顺序的下标取）\n1234567@SelectProvider(type = UserProvider.class, method = \"findByUsernameOrSex\")@ResultMap(\"userMap\")List&lt;User&gt; findByUsernameOrSex(@Param(\"user\") User user);@SelectProvider(type = UserProvider.class, method = \"findInIDs\")@ResultMap(\"userMap\")List&lt;User&gt; findInIDs(@Param(\"ids\") List&lt;Integer&gt; ids);\n\n编写ProviderMap接收参数\nSQL类可用于辅助构造SQL语句\n12345678910111213141516171819202122232425262728293031public class UserProvider &#123;    public String findByUsernameOrSex(Map&lt;String, Object&gt; params) &#123;        User user = (User) params.get(\"user\");        SQL sql = new SQL().SELECT(\"username\", \"address\", \"sex\", \"birthday\").FROM(\"user\");        if(user.getUsername() != null)            sql.WHERE(\"username = #&#123;user.username&#125;\");        if(user.getSex() != null)            sql.WHERE(\"sex = #&#123;user.sex&#125;\");        return sql.toString();    &#125;    public String findInIDs(Map&lt;String, Object&gt; params)&#123;        List&lt;Integer&gt; ids = (List&lt;Integer&gt;) params.get(\"ids\");        StringBuilder sql = new StringBuilder();        sql.append(\"select * from user \");        if(ids != null &amp;&amp; ids.size() &gt; 0)&#123;            sql.append(\"where id in (\");            int i = 0;            for (i = 0; i &lt; ids.size() - 1; i++) &#123;                sql.append(ids.get(i)).append(\",\");            &#125;            sql.append(ids.get(i)).append(\")\");        &#125;        return sql.toString();    &#125;&#125;\n\n配置冲突一个Mapper要么使用注解配置，要么使用XML配置，不可混合使用。\n","thumbnail":"post/Java/MyBatis/6-MyBatis注解开发/cover.jpg","plink":"https://beginc.github.io/post/Java/MyBatis/6-MyBatis注解开发/"},{"title":"Java集合之List接口继承体系下的迭代器","date":"2020-01-12T11:57:03.000Z","date_formatted":{"ll":"Jan 12, 2020","L":"01/12/2020","MM-DD":"01-12"},"updated":"2020-03-16T15:30:48.412Z","content":"AbstractList提供的迭代器AbstractList提供了两种迭代器的实现。\nItr实现了Iterator接口\nListItr实现了ListIterator接口\nItr迭代器该迭代器为标准的Iterator的实现类，实现了所有的方法。\nConcurrentModification使用迭代器对集合进行遍历的时候不允许进行对集合有结构型改变的操作（使集合的长度发生变化），否则会使迭代器遍历行为异常。AbstractList中使用modCount来避免这种行为，modCount负责记录当前对集合的结构性修改的次数，在执行add、remove等方法时需要将modCount++。\n\n\n初始化迭代器时记录当前modCount\n\n\n若当前modCount不等于预期的expectedModCount，即发生了ConcurrentModification，则抛出异常\nhasNext\n\nnext\n\nremove想要移除当前元素可以使用迭代器提供的remove方法进行合法操作。\n\n\n\n\nListItr迭代器ListItr迭代器是专门为List实现了增强版的Itr迭代器，不仅支持前向遍历，还支持反向遍历，还支持替换元素和增加元素。操作逻辑和Itr相同：\n通过modCount避免ConcurrentModification\n使用cursor和lastRet来进行遍历\n\n\n\n\nArrayList提供的迭代器ArrayList提供了Itr和ListItr的优化实现。\nnext手动检查下标越界，不依赖try catch，其他方法也类似\n\n\n\n\n\n\nLinkedList提供的迭代器由于AbstractList中提供的Itr迭代器和ListItr在遍历时，维持下标cursor和lastRet，在获取元素时通过get(cursor)来获取元素，这对于ArrayList来说没有问题，因为它可随机访问，但是对于LinkedList来说，每一次get(cursor)都意味着必须将指针从首节点开始移动到目标节点，这意味着对于LinkedList若使用AbstractList提供的迭代器实现，遍历一次的时间复杂度为O(n^2)，多出了很多无意义的指针移动，因此必须进行重新实现。\nItrLinkedList的父类AbstractSequentialList重写了iterator方法，直接调用了listIterator方法。\n\n\n\n\nListItr使用指针来维护当前节点和上一个返回节点的位置。\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之List接口继承体系下的迭代器/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之List接口继承体系下的迭代器/"},{"title":"Java集合之List","date":"2020-01-12T11:56:57.000Z","date_formatted":{"ll":"Jan 12, 2020","L":"01/12/2020","MM-DD":"01-12"},"updated":"2020-03-16T15:30:48.408Z","content":"继承体系\n\n特性有序集合，支持整数索引\n允许重复元素\n特性方法\n\n增加的方法主要都是支持整数索引的方法。\n增\n12void add(int index, E element);boolean addAll(int index, Collection&lt;? extends E&gt; c);\n\n删\n1E remove(int index);\n\n改\n1E set(int index, E element);\n\n查\n12int indexOf(Object o);int lastIndexOf(Object o);","thumbnail":"post/Java/Java语言/Java集合/Java集合之List/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之List/"},{"title":"Java集合之LinkedList","date":"2020-01-12T11:56:49.000Z","date_formatted":{"ll":"Jan 12, 2020","L":"01/12/2020","MM-DD":"01-12"},"updated":"2020-03-16T15:30:48.408Z","content":"继承体系\n\n不光实现了List接口，还实现了Queue接口。\n底层实现底层实现为双向链表，存储了指向首节点和尾节点的指针，操作均为链表的常规操作。\n\n\n多线程环境非同步实现，线程不安全。\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之LinkedList/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之LinkedList/"},{"title":"Java集合之Collection","date":"2020-01-12T11:56:43.000Z","date_formatted":{"ll":"Jan 12, 2020","L":"01/12/2020","MM-DD":"01-12"},"updated":"2020-03-16T15:30:48.408Z","content":"继承体系\n\nCollection是一个接口，继承自Iterable接口。\nIterable接口Java中对于集合使用迭代器Iterator进行遍历，实现了Iterable接口说明了该集合支持通过调用iterator方法返回一个Iterator接口的实现类，从而对集合进行遍历。\n\n\n\n\nCollection接口所有集合都实现了该接口，该接口定义了所有集合共有的一些方法。\n\n\n增\n12boolean add(E e);boolean addAll(Collection&lt;? extends E&gt; c);\n\n删\n123boolean remove(Object o);boolean removeAll(Collection&lt;?&gt; c);void clear();\n\n改\n未定义\n查\n12boolean contains(Object o);boolean containsAll(Collection&lt;?&gt; c);\n\n属性\n12int size();boolean isEmpty();","thumbnail":"post/Java/Java语言/Java集合/Java集合之Collection/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之Collection/"},{"title":"Java集合之ArrayList","date":"2020-01-12T11:56:35.000Z","date_formatted":{"ll":"Jan 12, 2020","L":"01/12/2020","MM-DD":"01-12"},"updated":"2020-03-16T15:30:48.408Z","content":"继承体系\n\n\n\n底层实现底层实现为数组，可进行动态扩容，elementData.length就是当前最大容量，size保存了当前元素的个数。\n\n\n\n\n\n\n\n增检查索引范围\n检查容量\n存数据\n\n\n扩容策略\n默认扩容1.5倍\n限制无限制内存分配\n\n\n\n\n\n\n\n\n容量缩减\n缩减到实际大小\n\n\n\n\n多线程环境非同步实现，线程不安全。\n","thumbnail":"post/Java/Java语言/Java集合/Java集合之ArrayList/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之ArrayList/"},{"title":"Babel基本使用","date":"2020-01-08T11:56:00.000Z","date_formatted":{"ll":"Jan 8, 2020","L":"01/08/2020","MM-DD":"01-08"},"updated":"2020-02-11T13:42:35.932Z","content":"什么是BabelBabel是一个用来将高版本JS代码(ES6或以上)编译转化为向后兼容的低版本JS代码的编译器。\n基本介绍Babel所提供的基本功能代码转换（如将箭头函数转化成普通函数）\n添加缺失的特性（Async, Await, Promise, Iterator, Generator, Set, Map, Proxy, Reflect, Symbol等）\nBabel的基本流程解析\n转换\n生成\nBabel的插件化Babel构建在插件之上，可通过组合多个插件或使用preset构建一个Pipeline。\n语法插件：相当于编译器前端\n转译插件：相当于编译器后端(使用转译插件自动依赖语法插件)\nBabel工具链@babel/core提供了Babel的核心功能。\n@babel/cli提供了命令行方式来使用Babel。\n1.&#x2F;node_modules&#x2F;.bin&#x2F;babel src --out-dir lib\n\n@babel/polyfillBabel默认只转换JS语法，而不转换新的API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法(比如Object.assign)都不会转码。@babel/polyfill通过向全局对象和内置对象的prototype上添加方法来支持新API\n缺点\n打包体积非常大\n污染全局变量\n@babel/plugin-transform-runtime  @babel/runtime","thumbnail":"post/Web/前端工程化/Babel基本使用/cover.png","plink":"https://beginc.github.io/post/Web/前端工程化/Babel基本使用/"},{"title":"webpack基本使用","date":"2020-01-08T10:46:42.000Z","date_formatted":{"ll":"Jan 8, 2020","L":"01/08/2020","MM-DD":"01-08"},"updated":"2020-02-11T13:42:35.932Z","content":"为何要使用webpack前端模块化开发\n资源打包，减少请求次数\n基本概念入口(entry)webpack通过对各模块的依赖关系进行分析，构建出一个依赖关系图，然后将所有模块打包成一个(多个)bundle文件，入口指定了webpack从哪个文件开始构建依赖关系图。\n出口(outout)出口指定了webpack打包后如何输出。\nloaderloader可以将所有类型的文件转换成webpack能够处理的有效模块，从而让webpack能够处理非JavaScript文件。总之可将其理解为预处理器。\n图片\n字体\n样式（css、less、sass等）\nVue组件\nES6 JS文件（通过babel先进行转换）\n插件(plugin)待进一步理解\n基本配置123456789101112131415161718192021222324252627282930313233343536const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123;    mode: 'development',    entry: './src/index.js',    output: &#123;        path: path.resolve(__dirname, 'dist'),        filename: 'bundle.js'    &#125;,    module: &#123;        rules: [            &#123;                test: /\\.js$/,                exclude: /node_modules/,                use: 'babel-loader'            &#125;,            &#123;                test: /\\.less$/,                use: ['style-loader', 'css-loader', 'less-loader']            &#125;        ]    &#125;,    plugins: [        new HtmlWebpackPlugin(&#123;            filename: 'index.html',            template: 'template.html'        &#125;)    ],    devServer: &#123;        contentBase: path.resolve(__dirname, 'dist'),        port: 8000,        hot: true,        open: true    &#125;&#125;\n\n入口entry指定入口文件\noutputpath指定目录，filename指定文件名\nloader在module的rules中指定\n1234&#123;    test: 正则表达式,    use: [loader1, loader2...]&#125;\n\nJS语法转换\nbabel-loader\n1npm install -D babel-loader\n\nCSS\n[style-loader, css-loader, less-loader]\n1npm install -D css-loader style-loader less-loader\n\n图片与字体\nurl-loader\n1npm install -D url-loader\n\nVue组件\nvue-loader\n1npm install -D vue-loader vue-template-compiler\n\n配置(vue-loader V15 还需配置plugin和css!!)\n1234567891011121314151617181920212223242526272829303132const VueLoaderPlugin = require('vue-loader/lib/plugin')module.exports = &#123;  mode: 'development',  module: &#123;    rules: [      &#123;        test: /\\.vue$/,        loader: 'vue-loader'      &#125;,      // 它会应用到普通的 `.js` 文件      // 以及 `.vue` 文件中的 `&lt;script&gt;` 块      &#123;        test: /\\.js$/,        loader: 'babel-loader'      &#125;,      // 它会应用到普通的 `.css` 文件      // 以及 `.vue` 文件中的 `&lt;style&gt;` 块      &#123;        test: /\\.css$/,        use: [          'vue-style-loader',          'css-loader'        ]      &#125;    ]  &#125;,  plugins: [    // 请确保引入这个插件来施展魔法    new VueLoaderPlugin()  ]&#125;\n\n插件在module的plugins里面new出来。\nhtml-webpack-plugin\n用于自动将打包好的bundle文件注入到html中\nfilename 指定注入html的文件名（无需存在）\ntemplate 指定html模板文件（自己创建，可选）\ndevServer可用于热加载, 在module的devServer下配置。\ncontentBase 托管的目录（写dist目录）\nport 端口\nhot 热加载（默认为true)\nopen 是否自动打开页面\n","thumbnail":"post/Web/前端工程化/webpack基本使用/cover.png","plink":"https://beginc.github.io/post/Web/前端工程化/webpack基本使用/"},{"title":"npm基本使用","date":"2020-01-08T09:54:38.000Z","date_formatted":{"ll":"Jan 8, 2020","L":"01/08/2020","MM-DD":"01-08"},"updated":"2020-02-11T13:42:35.932Z","content":"npm介绍NPM是NodeJS下的包管理工具，可以解决包依赖问题。\n基本命令初始化1npm init\n\n执行之后当前目录下会生成一个package.json的配置文件。\npackage.json配置文件详解\nname 包名\nversion 版本号\ndescription 包描述信息\nmain 入口文件，require(&#39;moduleName&#39;)时会加载这个文件，默认为根目录下的index.js\nscripts 定义可执行脚本，可使用npm run执行\nauthor 作者\nlicense 许可\ndevDependencies 开发时所依赖的包，运行时不需要\ndependencies 运行时所依赖的包\n安装全局安装\n1npm install package-name -g\n\n本地安装\n安装包，不修改package.json\n1npm install package-name\n\n安装包，修改package.json的dependencies\n12npm install package-name --savenpm install package-name -S\n\n安装包，修改package.json的devDependencies\n12npm install package-name --save-devnpm install package-name -D\n\n卸载全局卸载\n1npm install package-name -g\n\n本地卸载\n卸载包，不修改package.json\n1npm uninstall package-name\n\n卸载包，修改package.json的dependencies\n12npm uninstall package-name --savenpm uninstall package-name -S\n\n卸载包，修改package.json的devDependencies\n12npm uninstall package-name --save-devnpm uninstall package-name -D\n\n淘宝镜像npm默认从国外服务器拉取资源，速度十分缓慢，因此可将其替换成淘宝镜像cnpm.\n1npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org\n\n使用\n1cnpm install package-name","thumbnail":"post/Web/前端工程化/npm基本使用/cover.jpg","plink":"https://beginc.github.io/post/Web/前端工程化/npm基本使用/"},{"title":"七大原则","date":"2019-12-23T11:02:51.000Z","date_formatted":{"ll":"Dec 23, 2019","L":"12/23/2019","MM-DD":"12-23"},"updated":"2020-01-08T08:34:37.678Z","content":"单一职责原则每一个类只负责一项职责\n","thumbnail":"post/设计模式/七大原则/cover.jpg","plink":"https://beginc.github.io/post/设计模式/七大原则/"},{"title":"Leetcode-53 Maximun Array","date":"2019-09-11T13:19:59.000Z","date_formatted":{"ll":"Sep 11, 2019","L":"09/11/2019","MM-DD":"09-11"},"updated":"2020-01-08T08:34:39.599Z","content":"题目Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\nExample:\n123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.\n\n动态规划状态转移方程\n定义dp[i]为子序列seq[:i]的最大连续子列和\n1dp[i] &#x3D; max(dp[i - 1] + seq[i], seq[i])\n\n实现\n12345678910111213141516public class Solution &#123;    public int maxSubArray(int[] nums) &#123;        // 记录最大和        int max = nums[0];        int[] dp = new int[nums.length];        dp[0] = nums[0];        for (int i = 1; i &lt; nums.length; i++) &#123;            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);            max = Math.max(dp[i], max);        &#125;        return max;    &#125;&#125;","thumbnail":"post/数据结构与算法/Leetcode-53/cover.jpg","plink":"https://beginc.github.io/post/数据结构与算法/Leetcode-53/"},{"title":"MIPS-Like单周期16位CPU设计","date":"2019-09-09T15:48:42.000Z","date_formatted":{"ll":"Sep 9, 2019","L":"09/09/2019","MM-DD":"09-09"},"updated":"2020-01-08T09:46:30.603Z","content":"由于课程设计的需要，利用Verilog实现了一个类MIPS的单周期CPU。\n指令集R型寄存器操作型指令，三个操作数都为寄存器。\n指令格式\nOpType(2位) FuncType(5位) R1(3位) R2(3位) R3(3位)\n实现指令\n123456789ADDR  r1, r2, r3(r1 + r2   ---&gt; r3) 加法SUBR  r1, r2, r3(r1 - r2   ---&gt; r3) 减法LSLR  r1, r2, r3(r1 &lt;&lt; r2  ---&gt; r3) 逻辑左移LSRR  r1, r2, r3(r1 &gt;&gt; r2  ---&gt; r3) 逻辑右移ASLR  r1, r2, r3(r1 &lt;&lt;&lt; r2 ---&gt; r3) 算术左移ASRR  r1, r2, r3(r1 &gt;&gt;&gt; r2 ---&gt; r3) 算术右移ANDR  r1, r2, r3(r1 and r2 ---&gt; r3) 按位与ORR   r1, r2, r3(r1 or r2  ---&gt; r3) 按位或MOVR  r1, .., r3(r1 ---&gt; r3)        转存\n\nI型寄存器与立即数混合运算。\n指令格式\nOpType(2位) FuncType(5位) R1(3位) IConst(3位) R3(3位)\n实现指令\n1234567891011ADDI  r1, const, r3(r1 + r2   ---&gt; r3)    加法SUBI  r1, const, r3(r1 - r2   ---&gt; r3)    减法LSLI  r1, const, r3(r1 &lt;&lt; r2  ---&gt; r3)    逻辑左移LSRI  r1, const, r3(r1 &gt;&gt; r2  ---&gt; r3)    逻辑右移ASLI  r1, const, r3(r1 &lt;&lt;&lt; r2 ---&gt; r3)    算术左移ASRI  r1, const, r3(r1 &gt;&gt;&gt; r2 ---&gt; r3)    算术右移ANDI  r1, const, r3(r1 and r2 ---&gt; r3)    按位与ORI   r1, const, r3(r1 or r2  ---&gt; r3)    按位或MOVI  .., const, r3(const ---&gt; r3)        转存LOAD  r1, const, r3(M[r1 + const] ---&gt; r3)读数据内存STORE r1, const, r3(r3 ---&gt; M[r1 + const])写数据内存\n\nJ型执行跳转指令。\n指令格式\nOpType(2位) FuncType(5位) JConst(9位)\n实现指令\n1234JMP constJE  constJL  constJG  const\n\n寄存器设置R1-R8八个16位寄存器\nPSW程序状态字(Z.S)\n配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// 字长`define WORD_WIDTH 15:0// PSW宽度`define PSW_WIDTH 1:0// PSW位选择`define PSW_Z_SEL 0`define PSW_S_SEL 1// S标志正负`define PSW_S_NEG 1`define PSW_S_POS 0// 复位`define ChipResetEnable  1`define ChipResetDisable 0// 寄存器数量`define REG_MAX_NUM    8`define REG_ADDR_WIDTH 7:0// 寄存器宽度`define REG_WIDTH      15:0// 读写信号`define READ  0`define WRITE 1// 数据存储器数量`define DATA_MAX_NUM    8`define DATA_ADDR_WIDTH 7:0// 数据存储器宽度`define DATA_WIDTH      15:0// 指令存储器数量`define INST_MAX_NUM    16`define INST_ADDR_WIDTH 15:0// 指令存储器宽度`define INST_WIDTH      15:0// 指令格式`define OP_TYPE_WIDTH   1:0`define FUNC_TYPE_WIDTH 4:0`define I_CONST_WIDTH   2:0`define J_CONST_WIDTH   8:0`define OP_TYPE_SEL   15:14`define FUNC_TYPE_SEL 13:9`define R1_SEL         8:6`define R2_SEL         5:3`define R3_SEL         2:0`define I_CONST_SEL    5:3`define J_CONST_SEL    8:0// 操作码`define OP_R 2'b00`define OP_I 2'b01`define OP_J 2'b10// 功能码`define FUNC_ADDR 5'b00000`define FUNC_SUBR 5'b00001`define FUNC_LSLR 5'b00010`define FUNC_LSRR 5'b00011`define FUNC_ASLR 5'b00100`define FUNC_ASRR 5'b00101`define FUNC_ANDR 5'b00110`define FUNC_ORR  5'b00111`define FUNC_MOVR 5'b01000`define FUNC_ADDI  5'b00000`define FUNC_SUBI  5'b00001`define FUNC_LSLI  5'b00010`define FUNC_LSRI  5'b00011`define FUNC_ASLI  5'b00100`define FUNC_ASRI  5'b00101`define FUNC_ANDI  5'b00110`define FUNC_ORI   5'b00111`define FUNC_MOVI  5'b01000`define FUNC_LOAD  5'b01001`define FUNC_STORE 5'b01010`define FUNC_JMP 5'b00000`define FUNC_JE  5'b00001`define FUNC_JL  5'b00010`define FUNC_JG  5'b00011// 位扩展模式`define ZERO_EXTEND   0`define SIGN_EXTEND   1// 控制器控制信号// ALU OP2 Selection`define ALU_OP2_ICONST 1`define ALU_OP2_R2 0// Register Write Data Selection`define REG_WRITE_ALU_OUT 0`define REG_WRITE_R1 1`define REG_WRITE_ICONST 2`define REG_WRITE_MEM 3// Register Read Port2 Address Selection`define REG_PORT2_ADDR_R2 0`define REG_PORT2_ADDR_R3 1// Write Enable`define WRITE_ENABLE 1`define WRITE_DISABLE 0// PC Delta Selection`define PC_DELTA_1 0`define PC_DELTA_J 1\n\n基础部件实现存储器实现由于采用数据存储器、指令存储器分离，因此需分别实现两种存储器。\n指令寄存器指令存储器为只读存储器。\n端口定义\nreset复位信号\ninstAddr即PC取指令地址\ninst为取出的指令\n12345678910111213141516171819202122232425262728`include \"config.v\"module InstMemory(    input reset,    input[`INST_ADDR_WIDTH] instAddr,    output reg[`INST_WIDTH] inst);reg[`INST_WIDTH] data[`INST_ADDR_WIDTH];integer index;// Resetalways@(*) begin    if(reset == `ChipResetEnable) begin        for(index=0;index&lt;`INST_MAX_NUM;index=index+1)            data[index] &lt;= 0;            endendalways@(*) begin    if(reset == `ChipResetEnable)        inst = 0;    else        inst = data[instAddr];endendmodule\n\n数据存储器端口定义\nclk为时钟信号\nreset复位信号\ndataMemWR控制写入还是读出\ndataMemWriteEnable写使能\ndataMemAddr相当于MAR\ndataMemIn要写入的数据\ndataMemOut读出的数据\n123456789101112131415161718192021222324252627282930313233343536373839`include \"config.v\"module DataMemory(    input clk,    input reset,    input dataMemWR,    input dataMemWriteEnable,    input[`DATA_ADDR_WIDTH] dataMemAddr,    input[`DATA_WIDTH] dataMemIn,    output reg[`DATA_WIDTH] dataMemOut);reg[`DATA_WIDTH] data[`DATA_ADDR_WIDTH];integer index;// Resetalways@(*) begin    if(reset == `ChipResetEnable) begin        for(index=0;index&lt;`DATA_MAX_NUM;index=index+1)            data[index] &lt;= 0;    endend// Readalways@(*) begin    if(reset == `ChipResetEnable)        dataMemOut &lt;= 0;    else begin        if(dataMemWR == `READ)            dataMemOut &lt;= data[dataMemAddr];    endend// Writealways@(posedge clk) begin    if(reset == `ChipResetDisable) begin        if((dataMemWR == `WRITE) &amp;&amp; (dataMemWriteEnable == `WRITE_ENABLE))            data[dataMemAddr] = dataMemIn;    endendendmodule\n\n寄存器组实现clk时钟信号\nreset复位信号\nregisterWR寄存器读写模式\nregisterWriteEnable寄存器写使能\nr1Addr读端口1地址\nr2Addr读端口2地址\nr1Data读端口1输出数据\nr2Data读端口2输出数据\nwRegAddr写端口地址\nwRegData待写数据\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546`include \"config.v\"module Register(    input clk,    input reset,    input registerWR,    input registerWriteEnable,    input[`REG_ADDR_WIDTH] r1Addr,    input[`REG_ADDR_WIDTH] r2Addr,    output reg [`REG_WIDTH] r1Data,    output reg [`REG_WIDTH] r2Data,    input[`REG_ADDR_WIDTH] wRegAddr,    input[`REG_WIDTH] wRegData);reg[`REG_WIDTH] regs[`REG_ADDR_WIDTH];integer index;// 初始复位清空数据always@(*) begin    if(reset == `ChipResetEnable) begin        for(index=0;index&lt;`REG_MAX_NUM;index=index+1)            regs[index]=0;    endend// 读端口1always@(*) begin    if((reset == `ChipResetEnable))        r1Data &lt;= 0;    else begin        r1Data &lt;= regs[r1Addr];    endend// 读端口2always@(*) begin    if((reset == `ChipResetEnable))        r2Data &lt;= 0;    else begin        r2Data &lt;= regs[r2Addr];    endend// 写端口always@(posedge clk) begin    if((reset == `ChipResetDisable) &amp;&amp; (registerWR == `WRITE) &amp;&amp; (registerWriteEnable == `WRITE_ENABLE))        regs[wRegAddr] &lt;= wRegData;endendmodule\n\n二路选择器实现在输入的两路信号中选择一路输出。\nsel选择信号\nmuxIn1输入1\nmuxIn2输入2\nmuxOut输出\n1234567891011121314151617`include \"config.v\"module Mux2(    input sel,    input[`WORD_WIDTH] muxIn1,    input[`WORD_WIDTH] muxIn2,    output reg[`WORD_WIDTH] muxOut);always@(*) begin    if(sel == 0) begin        muxOut &lt;= muxIn1;    end    else        muxOut &lt;= muxIn2;endendmodule\n\n四路选择器实现在输入的四路信号中选择一路输出\nsel选择信号\nmuxIn1输入1\nmuxIn2输入2\nmuxIn3输入3\nmuxIn4输入4\nmuxOut输出\n1234567891011121314151617181920`include \"config.v\"module Mux4(    input[1:0] sel,    input[`WORD_WIDTH] muxIn1,    input[`WORD_WIDTH] muxIn2,    input[`WORD_WIDTH] muxIn3,    input[`WORD_WIDTH] muxIn4,    output reg[`WORD_WIDTH] muxOut);always@(*) begin    case(sel)        0: muxOut &lt;= muxIn1;        1: muxOut &lt;= muxIn2;        2: muxOut &lt;= muxIn3;        3: muxOut &lt;= muxIn4;    endcaseendendmodule\n\n数据通路实现实现完一些基础部件后，开始对数据通路进行实现。\n最全数据通路\n先列出最全的数据通路，而对于不同的指令，其数据通路将为下面数据通路的子集，需要使用控制器进行相应的信号控制。\n依据PC取指令\n对指令译码，得出指令的各个组成部分OPType\nFuncType\nR1Addr\nR2Addr\nR3Addr\nIConst(I型指令的立即数，需要进行位扩展到寄存器宽度)\nJConst(J型指令的立即数，需要进行位扩展到寄存器宽度)\n\n读寄存器(R型和I型指令需要读寄存器)\nALU运算(R型和I型指令需要ALU运算)\n数据存储器访问写内存(STORE指令)\n读内存(LOAD指令)\n\n写寄存器(R型指令和I型指令需要写寄存器)\n改变PC+1(对于R型指令和I型指令，PC加1，继续顺序执行)\nJConst + PC + 1(J型指令跳转，修改PC)\n\n数据通路分析R型指令除MOVR指令外\n依据PC取指令\n对指令译码，得出指令的各个组成部分OPType\nFuncType\nR1Addr\nR2Addr\nR3Addr\n\n读寄存器registerWR读模式\nregisterWriteEnable禁止\n用R1Addr地址读出数据到R1Data\n用R2Addr地址读出数据到R2Data\n\nALU运算ALUOp1为R1Data\nALUOp2为R2Data\n\n写寄存器registerWR写模式\nregisterWriteEnable允许\n用R3Addr作为写地址，将ALUOut写入寄存器\n\nPC + 1\nMOVR指令\nMOVR指令不同于其他R型指令，它无需进行ALU运算。\n依据PC取指令\n对指令译码，得出指令的各个组成部分OPType\nFuncType\nR1Addr\n......(无作用)\nR3Addr\n\n读寄存器registerWR读模式\nregisterWriteEnable禁止\n用R1Addr地址读出数据到R1Data\n\n写寄存器registerWR写模式\nregisterWriteEnable允许\n用R3Addr作为写地址，将R1Data写入寄存器\n\nPC + 1\n冲突分析\nMOVR指令无需进行ALU运算，因此在设计ALU时，当见到MOVR指令时，无需进行计算\nMOVR指令使用R1Data写入寄存器地址R3Data处，而其他指令使用ALUOut写入寄存器地址R3Data处，因此需添加一个多路选择器，用控制信号wRegDataSel来选择写入寄存器的数据来源\nI型指令除MOVI, LOAD, STORE外\n依据PC取指令\n对指令译码，得出指令的各个组成部分OPType\nFuncType\nR1Addr\nIConst(I型指令的立即数，需要进行位扩展到寄存器宽度)\nR3Addr\n\n位扩展(将IConst进行位扩展)移位指令需要零扩展\n其他运算指令需要符号扩展\n\n读寄存器registerWR读模式\nregisterWriteEnable禁止\n用R1Addr地址读出数据到R1Data\n\nALU运算ALUOp1为R1Data\nALUOp2为位扩展后的IConst\n\n写寄存器registerWR写模式\nregisterWriteEnable允许\n用R3Addr作为写地址，将ALUOut写入寄存器\n\nPC + 1\nMOVI指令\n依据PC取指令\n对指令译码，得出指令的各个组成部分OPType\nFuncType\nIConst(I型指令的立即数，需要进行位扩展到寄存器宽度)\nR3Addr\n\n位扩展(将IConst进行位扩展)符号扩展\n\n写寄存器registerWR写模式\nregisterWriteEnable允许\n用R3Addr作为写地址，将位扩展后的IConst写入寄存器\n\nPC + 1\nLOAD指令\n依据PC取指令\n对指令译码，得出指令的各个组成部分OPType\nFuncType\nR1Addr\nIConst(I型指令的立即数，需要进行位扩展到寄存器宽度)\nR3Addr\n\n位扩展(将IConst进行位扩展)符号扩展\n\nALU运算ALUOp1为R1Data\nALUOp2为位扩展后的IConst\n\n数据存储器访问\n\nSTORE指令\n","thumbnail":"post/Hardware/MIPS-Like单周期CPU设计/cover.jpg","plink":"https://beginc.github.io/post/Hardware/MIPS-Like单周期CPU设计/"},{"title":"VirtualBox下CentOS克隆","date":"2019-09-09T14:44:38.000Z","date_formatted":{"ll":"Sep 9, 2019","L":"09/09/2019","MM-DD":"09-09"},"updated":"2020-01-08T08:31:06.569Z","content":"CentOS-Minimal安装配置先用Minimal镜像安装好一台虚拟机，进行配置。\n安装wget1sudo yum install wget\n\n源配置详见\n安装ifconfig1sudo yum install net-tools\n\n桥接网络设置详见\n设置开机菜单选择时间缩短选择时间，快速开机。\nCentOS7\n1sudo vi /etc/grub2.cfg\n\n\n\nCentOS克隆准备由于克隆后两台虚拟机会有相同的MAC地址，发生冲突，需要提前先进行一些配置。\n删除MAC和UUID\n1sudo vi /etc/sysconfig/network-scripts/ifcfg-enp0s3\n将HWADDR和UUID注释掉，解除其与网卡名称的绑定。\n删除文件\n该文件将网卡名和MAC地址进行了绑定，克隆后的虚拟机会使用新的MAC地址，将会出错。\n1sudo rm /etc/udev/rules.d/70-persistent-ipoib.rules\n\n重启网络服务\n1service network restart\n\n生成快照安装完后，在VirtualBox中生成快照，之后可用于克隆。\n\n\n\n\n克隆虚拟机\n\n更新克隆机的MAC地址\n\n修改静态IP克隆后的虚拟机和其父本有一样的IP，需要修改。\n12# 打开后对IPADDR进行更改sudo vi /etc/sysconfig/network-scripts/ifcfg-enp0s3\n主机名修改这一步不是必要的。\nCentOS7\n1sudo vi /etc/hostname\n设置hostname,重启生效。\n1node01\n\nCentOS6\n1sudo vi /etc/sysconfig/network\n设置hostname,重启生效。\n1HOSTNAME=node01\n\n设置hostname映射\n将hostname映射到IP\n1sudo vi /etc/hosts\n设置映射\n1234# 本机可以不设置192.168.1.101 node01# 设置别的机器的映射192.168.1.102 node02","thumbnail":"post/Linux/VirtualBox下CentOS克隆/cover.jpg","plink":"https://beginc.github.io/post/Linux/VirtualBox下CentOS克隆/"},{"title":"各种源配置","date":"2019-09-09T13:51:07.000Z","date_formatted":{"ll":"Sep 9, 2019","L":"09/09/2019","MM-DD":"09-09"},"updated":"2020-01-08T08:31:06.570Z","content":"CentOS源备份repo文件\n123cd /etc/yum.repos.d/sudo mkdir bakmv ./*.repo ./bak/\n\n下载repo文件\n阿里源\n1wget http://mirrors.aliyun.com/repo/Centos-7.repo\n\n网易源\n1wget http://mirrors.163.com/.help/CentOS7-Base-163.repo\n\n重建yum缓存\n12sudo yum clean allsudo yum makecache\n\nPip源1pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n","thumbnail":"post/其他/各种源配置/cover.jpg","plink":"https://beginc.github.io/post/其他/各种源配置/"},{"title":"CentOS网络配置","date":"2019-09-09T13:34:39.000Z","date_formatted":{"ll":"Sep 9, 2019","L":"09/09/2019","MM-DD":"09-09"},"updated":"2020-01-08T08:31:06.569Z","content":"虚拟机三种网络模式NAT虚拟机借助NAT的功能，通过宿主机所在的网络来访问公网。在这种模式下宿主机成为双网卡主机，同时参与现有的宿主局域网和新建的虚拟局域网，但由于加设了一个虚拟的NAT服务器，使得虚拟局域网内的虚拟机在对外访问时，使用的则是宿主机的IP地址，这样从外部网络来看，只能看到宿主机，完全看不到新建的虚拟局域网。\n桥接虚拟机就像是局域网中的一台独立的主机，需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。\nHost-Only在这种模式下宿主机上的所有虚拟机是可以相互通信的，但虚拟机和真实的网络是被隔离开的。\n在这种模式下新建了一个由所有虚拟机与宿主机所构成的局域网，但该局域网与宿主机本身所处的现有局域网是相互独立的，如果不做额外路由设置，这两个局域网之间不会连通，因此新建的局域网可以认为是一个单独从属于当前宿主机的私有网络，其成员为当前宿主机和相关的所有虚拟机。\nCentOS7网络配置桥接配置手工为虚拟系统配置IP地址、子网掩码。\n查看当前网卡\n\n\n可知当前使用的为enp0s3\n修改配置文件\n12cd /etc/sysconfig/network-scripts/sudo vi ./ifcfg-enp0s3\n\n主要参数\nBOOTPROTO获取的ip地址类型，static和none为静态地址，dhcp为动态获取ip地址\nONBOOT设置网卡是否在Linux系统启动时激活\nIPADDRIP地址\nNETMASK子网掩码\nGATEWAY网关地址\nDNS1首选DNS服务器\nDNS2辅助选DNS服务器\n123456789101112# 静态IPBOOTPROTO=static# 设置IPIPADDR=192.168.1.101# 网络掩码NETMASK=255.255.255.0# 和本机网关保持一致GATEWAY=192.168.1.1# DNS1DNS1=114.114.114.114# DNS2DNS2=8.8.8.8\n\n重启网络服务\n1service network restart\n","thumbnail":"post/Linux/CentOS网络配置/cover.jpg","plink":"https://beginc.github.io/post/Linux/CentOS网络配置/"},{"title":"Pipeline框架设计---Registry","date":"2019-09-06T03:36:45.000Z","date_formatted":{"ll":"Sep 6, 2019","L":"09/06/2019","MM-DD":"09-06"},"updated":"2020-01-08T08:31:06.569Z","content":"设计目的要使得框架能够实现全配置文件化，必须提供某种机制，使得我们能够实例化任何在配置文件中所指定的类，并传递配置文件中的相关参数。\nmmdet的实现Registry类实现一个注册工厂类，用来存储和检索注册的类\n12345678910111213141516171819202122232425262728293031323334353637383940class Registry(object):    def __init__(self, name):        self._name = name        self._module_dict = dict()    def __repr__(self):        format_str = self.__class__.__name__ + '(name=&#123;&#125;, items=&#123;&#125;)'.format(            self._name, list(self._module_dict.keys()))        return format_str    @property    def name(self):        return self._name    @property    def module_dict(self):        return self._module_dict    def get(self, key):        return self._module_dict.get(key, None)    def _register_module(self, module_class):        \"\"\"Register a module.        Args:            module (:obj:`nn.Module`): Module to be registered.        \"\"\"        if not inspect.isclass(module_class):            raise TypeError('module must be a class, but got &#123;&#125;'.format(                type(module_class)))        module_name = module_class.__name__        if module_name in self._module_dict:            raise KeyError('&#123;&#125; is already registered in &#123;&#125;'.format(                module_name, self.name))        self._module_dict[module_name] = module_class    def register_module(self, cls):        self._register_module(cls)        return cls\n\n实例化工厂为每个类别的模块实例化一个注册工厂\n123456789from mmdet.utils import RegistryBACKBONES = Registry('backbone')NECKS = Registry('neck')ROI_EXTRACTORS = Registry('roi_extractor')SHARED_HEADS = Registry('shared_head')HEADS = Registry('head')LOSSES = Registry('loss')DETECTORS = Registry('detector')\n\n注册使用注解的形式进行注册\n123@DETECTORS.register_moduleclass SingleStageDetector(BaseDetector):    ...\n\nPipeline框架Registry设计Registry使用全称限定名进行注册\n在检索的时候才进行模块的导入(lazy-import)\n12345678910111213141516171819202122232425262728293031from importlib import import_moduleclass Registry():    def __init__(self):        self._catelog = dict()    def register(self, name, fullname):        assert name not in self._catelog        self._catelog[name] = fullname    def register_package(self, package, *modules):        for module in modules:            self.register(module, package + '.' + module)    def get(self, name):        assert name in self._catelog, \"&#123;&#125; hasn't been registered yet!\".format(            name)        fullname = self._catelog[name]        path = fullname.split(\".\")        module_name = \".\".join(path[:-1])        cls_name = path[-1]        module = import_module(module_name)        cls = getattr(module, cls_name)        return cls    @property    def catelog(self):        return self._catelog\n\n注册1234567891011REGISTRY = Registry()# TransformREGISTRY.register_package('mxnet.gluon.data.vision.transforms',                          'ToTensor', 'Normalize', 'RandomResizedCrop',                          'CenterCrop', 'Resize', 'RandomFlipLeftRight',                          'RandomColorJitter', 'RandomLighting')# DatasetREGISTRY.register_package('mxnet.gluon.data.vision', 'CIFAR10', 'MNIST')# ModelREGISTRY.register_package('pipeline.model.resnet', 'ResNetV1', 'ResNetV2')\n\n实现用配置文件实例化类cfg中需包含type字段指明类名（需要注册过）\ncfg中可嵌套包含其他类（builder进行递归实例化）\n12345model_config = dict(    type='ResNetV1',    num_layers=18,    classes=10)\n\nbuilder\n12345678910111213from .registry import REGISTRYdef build(cfg):    if isinstance(cfg, dict) and \"type\" in cfg:        name = cfg.get(\"type\")        cls = REGISTRY.get(name)        params = &#123;&#125;        for key, val in cfg.items():            if key != 'type':                params[key] = build(val)        return cls(**params)    return cfg","thumbnail":"post/Python/Pipeline框架设计-Registry/cover.jpg","plink":"https://beginc.github.io/post/Python/Pipeline框架设计-Registry/"},{"title":"SSM整合","date":"2019-09-06T02:57:06.000Z","date_formatted":{"ll":"Sep 6, 2019","L":"09/06/2019","MM-DD":"09-06"},"updated":"2020-01-28T14:55:26.141Z","content":"创建Maven项目packaging为war\n编译设置123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;org.example&lt;/groupId&gt;  &lt;artifactId&gt;ssm&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;ssm Maven Webapp&lt;/name&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;  &lt;/properties&gt;&lt;/project&gt;\n配置maven-tomcat7-plugin插件可通过tomcat7:run运行项目\n1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;groupId&gt;cn.edu.njust&lt;/groupId&gt;    &lt;artifactId&gt;Reading&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;    &lt;/properties&gt;        &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;contextReloadable&gt;true&lt;/contextReloadable&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n引入依赖Servlet + JSP + JSTL + Annotationscope设置为provided（因为在tomcat容器中有依赖，不设置为provided会发生冲突）\n1234567891011121314151617181920212223&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;    &lt;version&gt;2.2.1&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.annotation&lt;/groupId&gt;    &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;    &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;\n\nMyBatismybatis\nmybatis-spring整合包\n12345678910&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;2.0.3&lt;/version&gt;&lt;/dependency&gt;\n\n数据库mysql驱动\ndruid数据库连接池\n12345678910&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;\n\nSpringMVCspring-webmvc已经包含了：spring-context\nspring-bean\nspring-core\nspring-expression\nspring-aop\nspring-web\n\n12345&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\nSpringMVC JSON绑定（Jackson）jackson-databind已经依赖了jackson-core和jackson-annotation\n12345&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt;\n\nAspectj Weaver12345&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;    &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;\n\nSpring事务管理12345678910&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;    &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n\nSpring测试spring-test + junit\n123456789101112&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;\n\n日志logback-classic为日志框架\nspring-core在这个包里面把commons-logging依赖剔除掉\njcl-over-slf4j将commons-logging日志API转发到slf4j，做一个桥接\nlogback-ext-spring支持web环境下的日志\n1234567891011121314151617181920212223242526&lt;dependency&gt;    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;    &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;    &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;exclusions&gt;    &lt;exclusion&gt;        &lt;groupId&gt;commons-logging&lt;/groupId&gt;        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;    &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;    &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.logback-extensions&lt;/groupId&gt;    &lt;artifactId&gt;logback-ext-spring&lt;/artifactId&gt;    &lt;version&gt;0.1.4&lt;/version&gt;&lt;/dependency&gt;\n\n配置文件spring-context.xml开启注解扫描\n配置数据源\n整合MyBatis\n配置事务控制\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;    &lt;!--引入JDBC配置文件--&gt;    &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;    &lt;!--开启注解扫描--&gt;    &lt;context:component-scan base-package=\"cn.edu.njust\"&gt;        &lt;!--不扫描Contoller，让SpringMVC扫描--&gt;        &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;    &lt;/context:component-scan&gt;    &lt;!--整合MyBatis--&gt;    &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt;        &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt;        &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;        &lt;property name=\"configLocation\" value=\"classpath:mybatis.xml\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;        &lt;property name=\"basePackage\" value=\"cn.edu.njust.dao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--事务控制--&gt;    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;tx:advice id=\"generalTransactionAdvice\" transaction-manager=\"transactionManager\"&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=\"find*\" read-only=\"true\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"insert*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"update*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"delete*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"save*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;aop:config&gt;        &lt;!--业务层所有方法加上事务--&gt;        &lt;aop:pointcut id=\"generalPointcut\" expression=\"execution(* cn.edu.njust.service.impl.*(..))\"/&gt;        &lt;aop:advisor advice-ref=\"generalTransactionAdvice\" pointcut-ref=\"generalPointcut\"&gt;&lt;/aop:advisor&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\nmybatis.xml指定日志框架\n开启延迟加载\n1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"        \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;!--指定日志框架为slf4j--&gt;        &lt;setting name=\"logImpl\" value=\"slf4j\"/&gt;        &lt;!--开启延迟加载--&gt;        &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt;        &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;    &lt;/settings&gt;        &lt;typeAliases&gt;        &lt;package name=\"cn.edu.njust.pojo\"/&gt;    &lt;/typeAliases&gt;&lt;/configuration&gt;\n\nspring-mvc.xml开启注解扫描\n开启注解驱动(自动配置HandlerMapping和HandlerAdapter)\n静态资源交给default-servlet-handler\n123456789101112131415161718&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;!--开启注解--&gt;    &lt;context:component-scan base-package=\"cn.edu.njust.controller\"/&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!--配置视图解析器--&gt;    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"/&gt;    &lt;!--处理静态资源--&gt;    &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt;\n\nlogback.xml12345678910&lt;configuration&gt;    &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;        &lt;encoder&gt;            &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%thread][%-5level][%logger&#123;36&#125;]: %msg%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;root level=\"INFO\"&gt;        &lt;appender-ref ref=\"STDOUT\"/&gt;    &lt;/root&gt;&lt;/configuration&gt;\n\nweb.xmlSpring配置文件路径启动参数\nLogback配置文件路径启动参数\nCharacterEncodingFilter编码过滤器\nContextLoaderListener为Spring配置文件加载监听器\nLogbackConfigListener为Logback加载监听器\nDispatcherServlet前端控制器\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!--Spring配置文件位置--&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring-context.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--Logback配置文件位置--&gt;  &lt;context-param&gt;    &lt;param-name&gt;logbackConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:logback.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--SpringWeb编码过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;!--Spring配置文件加载监听器--&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!--Logback加载监听器--&gt;  &lt;listener&gt;    &lt;listener-class&gt;ch.qos.logback.ext.spring.web.LogbackConfigListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!--SpringMVC前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n测试Pojo1234567891011121314151617181920212223242526272829303132public class TestAccount &#123;    private Integer id;    private Integer money;    public TestAccount() &#123;    &#125;    @Override    public String toString() &#123;        return \"TestAccount&#123;\" +                \"id=\" + id +                \", money=\" + money +                '&#125;';    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public Integer getMoney() &#123;        return money;    &#125;    public void setMoney(Integer money) &#123;        this.money = money;    &#125;&#125;\n\nDao1234567@Repository(\"testDao\")@Mapperpublic interface TestDao &#123;    @Select(\"select * from account\")    List&lt;TestAccount&gt; findAll();&#125;\n\nService1234567891011121314@Service(\"testService\")public class TestServiceImpl implements TestService &#123;    @Resource(name = \"testDao\")    private TestDao testDao;    public void setTestDao(TestDao testDao) &#123;        this.testDao = testDao;    &#125;    @Override    public List&lt;TestAccount&gt; findAll() &#123;        return testDao.findAll();    &#125;&#125;\n\nController12345678910111213141516171819202122@Controller@RequestMapping(\"/test\")public class TestController &#123;    @Resource(name = \"testService\")    private TestService testService;    public void setTestService(TestServiceImpl testService) &#123;        this.testService = testService;    &#125;    @RequestMapping(\"/findall\")    public String testFindAll()&#123;        System.out.println(123);        List&lt;TestAccount&gt; accounts = testService.findAll();        for (TestAccount account : accounts) &#123;            System.out.println(account);        &#125;        return \"/index.jsp\";    &#125;&#125;\n\n\n启动1mvn tomcat7:run","thumbnail":"post/Java/SSM/SSM整合/cover.jpg","plink":"https://beginc.github.io/post/Java/SSM/SSM整合/"},{"title":"Java泛型","date":"2019-09-04T11:32:04.000Z","date_formatted":{"ll":"Sep 4, 2019","L":"09/04/2019","MM-DD":"09-04"},"updated":"2020-01-08T08:31:06.570Z","content":"使用泛型泛型类123class Container&lt;T&gt;&#123;    private T data;&#125;\n\n泛型方法123456789101112131415class Container&lt;T&gt;&#123;    private T data;    public Container(T data) &#123;        this.data = data;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;&#125;\n\n静态方法泛型类型&lt;T&gt;不能用于静态方法\n1234567891011121314151617181920class Container&lt;T&gt;&#123;    private T data;    public Container(T data) &#123;        this.data = data;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;    // 报错    public static void staticMethod(T data)&#123;    &#125;&#125;\n\n在static修饰符后面加一个，编译就能通过, 这个&lt;T&gt;和Container&lt;T&gt;类型的&lt;T&gt;已经没有任何关系了，可换一个泛型类型\n123456789101112131415161718192021222324252627282930313233343536373839404142class Container&lt;T&gt;&#123;    private T data;        public Container(T data) &#123;        this.data = data;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;    // 报错    public static void staticMethod(T data)&#123;    &#125;&#125;class Container&lt;T&gt;&#123;    private T data;        public Container(T data) &#123;        this.data = data;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;    // 不报错    public static &lt;K&gt; void staticMethod(K data)&#123;    &#125;&#125;\n\n多个泛型类型1234class Container&lt;T, K&gt;&#123;    private T dataT;    private T dataK;&#125;\n\n擦拭法Java语言的泛型实现方式是擦拭法（Type Erasure）。\n所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的，编译器把类型&lt;T&gt;一律改成Object，并且根据&lt;T&gt;实现安全的强制类型转换。\n123456789101112131415161718192021222324252627282930313233// 编写的代码class Container&lt;T&gt;&#123;    private T data;        public Container(T data) &#123;        this.data = data;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;&#125;// JVM执行的代码class Container&#123;    private Object data;        public Container(Object data) &#123;        this.data = data;    &#125;    public Object getData() &#123;        return data;    &#125;    public void setData(Object data) &#123;        this.data = data;    &#125;&#125;\n\n缺点\n无法使用基本类型作为泛型，因为基本类型无法转换为Object\n\n无法取得带泛型的Class\n1234Container&lt;String&gt; c1 = new Container&lt;String&gt;(\"123\");Container&lt;Integer&gt; c2 = new Container&lt;String&gt;(123);// trueSystem.out.println(c1.getClass() == c2.getClass());\n\n无法判断带泛型的Class\n123Container&lt;String&gt; c1 = new Container&lt;String&gt;(\"123\");// trueSystem.out.println(c1 isinstance of Container&lt;Integer&gt;.class);\n\n不能实例化T类型\n12// 错误T data = new T();\n\n导致不恰当的覆写方法\n1234// 与equals(Object t)冲突public boolean equals(T t)&#123;    return this == t;&#125;\n\n\n泛型继承TODO\n通配符extends通配符","thumbnail":"post/Java/Java语言/Java泛型/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java泛型/"},{"title":"Java注解","date":"2019-08-29T14:02:41.000Z","date_formatted":{"ll":"Aug 29, 2019","L":"08/29/2019","MM-DD":"08-29"},"updated":"2020-01-08T08:31:06.570Z","content":"注解简介注解只是一种特殊的注释，不对代码逻辑产生任何影响，具体的作用取决于程序如何使用这个注释信息。\n注解的作用编译器使用的注解\n编译后即被丢弃，不会进入.class文件\n@Override编译器检查方法是否正确实现了重载\n@SupressWarnings告诉编译器忽略此处的警告\n工具处理\n有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。\n运行期可读取\n此类注解在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。\n注解的参数注解可配置一些基本参数。大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。\n所有基本类型\nString\n枚举类型\n定义注解基本定义@interface定义注解\n类型 名字() default 值定义参数\n12345public @interface Report &#123;    int type() default 0;    String level() default \"info\";    String value() default \"\";&#125;\n\n元注解元注解负责修饰注解，对注解进行一些配置\n@Target\n指定注解可以放的位置(必配置)\nElementType.TYPE类或接口\nElementType.FIELD字段\nElementType.METHOD方法\nElementType.CONSTRUCTOR构造方法\nElementType.PARAMETER方法参数\n12345678910111213141516// 只能加在方法上@Target(ElementType.METHOD)public @interface Report &#123;    int type() default 0;    String level() default \"info\";    String value() default \"\";&#125;// 加在多个位置上@Target(&#123;    ElementType.METHOD,    ElementType.FIELD&#125;)public @interface Report &#123;    ...&#125;\n\n@Retention\n定义注解的生命周期(必配置)\nRetentionPolicy.SOURCE注解在编译期就被丢掉了\nRetentionPolicy.CLASS注解仅保存在class文件中，它们不会被加载进JVM(默认)\nRetentionPolicy.RUNTIME注解会被加载进JVM，并且在运行期可以被程序读取\n@Repeatable\n定义注解是否可重复进行注解\n123456789101112@Repeatable@Target(ElementType.TYPE)public @interface Report &#123;    int type() default 0;    String level() default \"info\";    String value() default \"\";&#125;@Report(type=1, level=\"debug\")@Report(type=2, level=\"warning\")public class Hello &#123;&#125;\n\n@Inherited\n定义子类是否可以继承父类的注解，仅针对@Target(ElementType.TYPE)有效\n使用注解RetentionPolicy.SOURCE(暂不讨论)RetentionPolicy.CLASS(暂不讨论)RetentionPolicy.RUNTIME获取注解\n详见\n使用注解\n如何使用注解完全取决于程序的目的\n12345678910111213141516171819202122232425262728293031@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface OptimizerConfig&#123;    String type() default \"SGD\";    double lr() default 0.02;    int epoch() default 12;&#125;@OptimizerConfig(type=\"SGD\", lr=0.01, epoch=20)class Model&#123;    private String type = \"SGD\";    private double lr = 0.02;    private int epoch = 12;    public Model()&#123;        Class cls = getClass();        if(cls.isAnnotationPresent(OptimizerConfig.class))&#123;            OptimizerConfig config = (OptimizerConfig) cls.getAnnotation(OptimizerConfig.class);            this.type =  config.type();            this.lr = config.lr();            this.epoch = config.epoch();        &#125;    &#125;    public void run()&#123;        System.out.println(\"Running with config:\");        System.out.println(\"Type:\" + type);        System.out.println(\"Lr:\" + lr);        System.out.println(\"Epoch:\" + epoch);    &#125;&#125;\n\n\n","thumbnail":"post/Java/Java语言/Java注解/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java注解/"},{"title":"SpringIoC容器","date":"2019-08-29T06:50:15.000Z","date_formatted":{"ll":"Aug 29, 2019","L":"08/29/2019","MM-DD":"08-29"},"updated":"2020-01-25T15:14:50.198Z","content":"Spring IoC容器Spring IoC容器简介IoC容器提供了控制反转(IoC)和依赖注入(DI)功能，程序将bean的创建过程交由IoC容器完成，并为其完成依赖属性的注入。\n两种IoC容器的实现ClassPathXmlApplicationContext读取classpath下的配置文件建立IoC容器\nFileSystemXmlApplicationContext读取文件系统下的配置文件建立IoC容器\n基本配置12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"student\" class=\"bean.Student\"&gt;       &lt;/bean&gt;&lt;/beans&gt;\n\n导入其他容器配置文件路径都是相对于当前配置文件\n12345&lt;beans&gt;    &lt;import resource=\"spring-services.xml\"/&gt;    &lt;bean id=\"studentService\" class=\"service.StudentService\"/&gt;&lt;/beans&gt;\n\n使用IoC容器getBean()\n可一次读取多个配置文件\n12ApplicationContext context = new ClassPathXmlApplicationContext(\"spring-context.xml\", \"spring-tx.xml\");Student student = context.getBean(\"student\", Student.class);\n\nBean命名id唯一，不可有特殊符号\nname唯一，可有特殊符号\n12&lt;bean id=\"student\" class=\"bean.Student\"/&gt;&lt;bean name=\"student1\" class=\"bean.Student\"/&gt;\n别名1&lt;alias name=\"student\" alias=\"johnStudent\"/&gt;\n\n初始化Bean无参构造器调用无参构造器\n使用setter注入依赖\n123&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;property name=\"name\" value=\"John\"/&gt;&lt;/bean&gt;\n\n静态工厂class此时指定工厂类\nfactory-method指定生产该对象的工厂方法\n123456public class StudentFactory &#123;    public static Student buildStudentStatic() &#123;        return new Student();    &#125;&#125;\n\n123&lt;bean id=\"bean\" class=\"factory.StudentFactory\" factory-method=\"buildStudentStatic\"&gt;    &lt;property name=\"name\" value=\"John\"/&gt;&lt;/bean&gt;\n\n实例工厂先实例化工厂，再生产Bean\nfactory-bean指定工厂实例\nfactory-method指定工厂方法\n1234567public class StudentFactory &#123;    public Student buildStudent() &#123;        return new Student();    &#125;&#125;\n\n12345&lt;bean id=\"studentFactory\" class=\"factory.StudentFactory\"&gt;&lt;/bean&gt;&lt;bean id=\"student\" factory-bean=\"studentFactory\" factory-method=\"buildStudent\"&gt;&lt;/bean&gt;\n\n依赖注入方式使用构造函数注入constructor-arg\n按名字注入\n必须在编译时开启debug flag, 或者在构造器上写上@ConstructorProperties({&quot;id&quot;, &quot;name&quot;, &quot;age&quot;})\n123456// @ConstructorProperties(&#123;\"id\", \"name\", \"age\"&#125;)public Student(Integer id, String name, Integer age) &#123;    this.id = id;    this.name = name;    this.age = age;&#125;\n\n12345&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;constructor-arg name=\"id\" value=\"1\"/&gt;    &lt;constructor-arg name=\"name\" value=\"John\"/&gt;    &lt;constructor-arg name=\"age\" value=\"18\"/&gt;&lt;/bean&gt;\n\n按类型注入\n1234public Student(Integer id, String name) &#123;    this.id = id;    this.name = name;&#125;\n\n1234&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;constructor-arg type=\"java.lang.Integer\" value=\"1\"/&gt;    &lt;constructor-arg type=\"java.lang.String\" value=\"John\"/&gt;&lt;/bean&gt;\n\n按索引注入\n12345public Student(Integer id, String name, Integer age) &#123;    this.id = id;    this.name = name;    this.age = age;&#125;\n\n12345&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;constructor-arg index=\"0\" value=\"1\"/&gt;    &lt;constructor-arg index=\"1\" value=\"John\"/&gt;    &lt;constructor-arg index=\"2\" value=\"18\"/&gt;&lt;/bean&gt;\n\n构造器注入循环依赖\n若beanA依赖beanB，beanB依赖beanA，则使用构造器注入会引起不可解决的循环依赖，解决方法为换为使用setter注入（先建立对象，再进行注入）\n使用setter注入必须要有无参构造器\n1234567891011public void setId(Integer id) &#123;    this.id = id;&#125;public void setName(String name) &#123;    this.name = name;&#125;public void setAge(Integer age) &#123;    this.age = age;&#125;\n\n12345&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;property name=\"id\" value=\"1\"/&gt;    &lt;property name=\"name\" value=\"John\"/&gt;    &lt;property name=\"age\" value=\"18\"/&gt;&lt;/bean&gt;\n\n依赖注入具体配置普通类型value\n&lt;idref&gt;\nvalue\n12345&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;property name=\"id\" value=\"1\"/&gt;    &lt;property name=\"name\" value=\"John\"/&gt;    &lt;property name=\"age\" value=\"18\"/&gt;&lt;/bean&gt;\n\n&lt;idref&gt;\n用来引用另外一个bean的id(String)，并进行检查，确保其存在\n1234567&lt;bean id=\"John\" class=\"bean.Student\"&gt;&lt;/bean&gt;&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;property name=\"name\"&gt;        &lt;idref bean=\"John\"/&gt;    &lt;property/&gt;&lt;/bean&gt;\n\n等价于name值为John + 检查引用的John这个bean是否存在\n12345&lt;bean id=\"John\" class=\"bean.Student\"&gt;&lt;/bean&gt;&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;property name=\"name\" value=\"referencedBean\"/&gt;&lt;/bean&gt;\n\n引用ref\n12345&lt;bean id=\"bean1\" class=\"bean.Bean1\"&gt;&lt;/bean&gt;&lt;bean id=\"bean2\" class=\"bean.Bean2\"&gt;    &lt;property name=\"Bean1\" ref=\"bean1\"/&gt; &lt;/bean&gt;\n\nparent\n在基于spring框架开发的项目中，如果有多个bean都是一个类的实例，如配置多个数据源时，大部分配置的属性都一样，只有少部分不一样，经常是copy上一个的定义，然后修改不一样的地方。其实spring bean定义也可以和对象一样进行继承。\n123456789&lt;bean id=\"student1\" class=\"bean.Student\"&gt;    &lt;property name=\"id\" value=\"1\"/&gt;    &lt;property name=\"name\" value=\"John\"/&gt;    &lt;property name=\"age\" value=\"18\"/&gt;&lt;/bean&gt;&lt;!-- name和age与student1一致--&gt;&lt;bean id=\"student2\" class=\"bean.Student\" parent=\"student1\"&gt;    &lt;property name=\"id\" value=\"2\"/&gt;&lt;/bean&gt;\n\n内部Bean类似于匿名对象，内部Bean不需要id\n内部类的scope属性被忽略，因为总是和外部Bean一起创建\n1234567&lt;bean id=\"bean2\" class=\"bean.Bean2\"&gt;    &lt;property name=\"Bean1\"&gt;        &lt;bean class=\"bean.Bean1\"&gt;            &lt;property name=\"name\" value=\"John\"/&gt;        &lt;/bean&gt;    &lt;/property&gt; &lt;/bean&gt;\n\n集合list对应List\nmap对应Map\nset对应Set\nprops对应Properties\nProperty\nkey-type指定键类型\nvalue-type指定值类型\n也可以不指定类型，由Spring来自动转换\n12345678&lt;bean id=\"bean\" class=\"bean.Bean\"&gt;    &lt;property name=\"prop\"&gt;        &lt;props key-type=\"java.lang.String\" value-type=\"java.lang.String\"&gt;            &lt;prop key=\"name\"&gt;John&lt;/prop&gt;            &lt;prop key=\"age\"&gt;18&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;\n\nList\nvalue-type指定值类型\n也可以不指定类型，由Spring来自动转换\n12345678&lt;bean id=\"bean\" class=\"bean.Bean\"&gt;    &lt;property name=\"prop\"&gt;        &lt;list value-type=\"java.lang.String\"&gt;            &lt;value&gt;John&lt;/value&gt;            &lt;ref bean=\"anotherBean\"/&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;\n\nMap\nkey-type指定键类型\nvalue-type指定值类型\n也可以不指定类型，由Spring来自动转换\n12345678&lt;bean id=\"bean\" class=\"bean.Bean\"&gt;    &lt;property name=\"prop\"&gt;        &lt;map key-type=\"java.lang.String\" value-type=\"java.lang.String\"&gt;            &lt;entry key=\"name\" value=\"John\"/&gt;            &lt;entry key=\"anotherBean\" value-ref=\"anotherBean\"/&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;\n\nSet\nvalue-type指定值类型\n也可以不指定类型，由Spring来自动转换\n12345678&lt;bean id=\"bean\" class=\"bean.Bean\"&gt;    &lt;property name=\"prop\"&gt;        &lt;set value-type=\"java.lang.String\"&gt;            &lt;value&gt;John&lt;/value&gt;            &lt;ref bean=\"anotherBean\"/&gt;        &lt;/set&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n使用parent和merge进行集合的合并\n在使用parent进行继承时，可指定集合属性的merge为true，即可将集合与parent的集合进行合并（相同的属性会被child替换）\n不能合并类型不同的集合\n123456789101112131415&lt;bean id=\"bean1\" class=\"bean.Bean\"&gt;    &lt;property name=\"prop\"&gt;        &lt;map&gt;            &lt;entry key=\"name\" value=\"John\"/&gt;            &lt;entry key=\"anotherBean\" value-ref=\"anotherBean\"/&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"bean2\" class=\"bean.Bean\"&gt;    &lt;property name=\"prop\"&gt;        &lt;map merge=\"true\"&gt;            &lt;entry key=\"name\" value=\"Bob\"/&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n空值&lt;null/&gt;用以区分空值和空字符串\n空串\n123&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;property name=\"name\" value=\"\"/&gt;&lt;/bean&gt;\n\n空值\n12345&lt;bean id=\"student\" class=\"bean.Student\"&gt;    &lt;property name=\"name\"&gt;        &lt;null/&gt;&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n复合属性路径上的最后一个属性可为null，前面的不能为null\n注入fred属性中bob属性中的sammy属性值123\n123&lt;bean id=\"something\" class=\"things.ThingOne\"&gt;    &lt;property name=\"fred.bob.sammy\" value=\"123\" /&gt;&lt;/bean&gt;","thumbnail":"post/Java/Spring/Spring IoC容器/cover.png","plink":"https://beginc.github.io/post/Java/Spring/Spring IoC容器/"},{"title":"配置文件整合","date":"2019-08-28T14:27:01.000Z","date_formatted":{"ll":"Aug 28, 2019","L":"08/28/2019","MM-DD":"08-28"},"updated":"2020-01-28T14:55:52.302Z","content":"SpringapplicationContext.xml\n12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"        xmlns:context=\"http://www.springframework.org/schema/context\"        xmlns:aop=\"http://www.springframework.org/schema/aop\"        xmlns:tx=\"http://www.springframework.org/schema/tx\"        xmlns:mvc=\"http://www.springframework.org/schema/mvc\"        xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;&lt;/beans&gt;\n\nSpringMVCspring-mvc.xml\n123456789101112&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txmlns:context=\"http://www.springframework.org/schema/context\"\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\txsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;\t &lt;/beans&gt;\n\nMyBatisSqlMapConfig.xml\n1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;/configuration&gt;\n\nmapper.xml\n1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"\"&gt;&lt;/mapper&gt;\n\nJDBCjdbc.properties\n1234jdbc.driver&#x3D;com.mysql.cj.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;easypay?serverTimezone&#x3D;UTCjdbc.username&#x3D;rootjdbc.password&#x3D;Hgld521125\n\nLogbacklogback.xml\n12345678910&lt;configuration&gt;    &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;        &lt;encoder&gt;            &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%thread][%-5level][%logger&#123;36&#125;]: %msg%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;root level=\"WARN\"&gt;        &lt;appender-ref ref=\"STDOUT\"/&gt;    &lt;/root&gt;&lt;/configuration&gt;\n\nSSM整合pom.xml\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;org.example&lt;/groupId&gt;  &lt;artifactId&gt;ssm&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;ssm Maven Webapp&lt;/name&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;!--JaveEE API--&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;      &lt;version&gt;3.1.0&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;      &lt;version&gt;2.2.1&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;jstl&lt;/artifactId&gt;      &lt;version&gt;1.2&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!--注解API--&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.annotation&lt;/groupId&gt;      &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;      &lt;version&gt;1.3.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Mybatis--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;      &lt;version&gt;3.4.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;      &lt;version&gt;2.0.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Database--&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;8.0.15&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;      &lt;artifactId&gt;druid&lt;/artifactId&gt;      &lt;version&gt;1.1.10&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Spring--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.aspectj&lt;/groupId&gt;      &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;      &lt;version&gt;1.9.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;      &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;      &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Spring MVC JSON Biding--&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;      &lt;version&gt;2.9.8&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Testing--&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.12&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;      &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!--Logging--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;      &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;      &lt;exclusions&gt;        &lt;exclusion&gt;          &lt;groupId&gt;commons-logging&lt;/groupId&gt;          &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;      &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;      &lt;version&gt;1.2.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;      &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;      &lt;version&gt;1.7.25&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.logback-extensions&lt;/groupId&gt;      &lt;artifactId&gt;logback-ext-spring&lt;/artifactId&gt;      &lt;version&gt;0.1.4&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;plugins&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;2.2&lt;/version&gt;        &lt;configuration&gt;          &lt;contextReloadable&gt;true&lt;/contextReloadable&gt;          &lt;port&gt;8080&lt;/port&gt;          &lt;path&gt;/ssm&lt;/path&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;    &lt;/plugins&gt;  &lt;/build&gt;&lt;/project&gt;\n\nspring-context.xml\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xmlns:tx=\"http://www.springframework.org/schema/tx\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;    &lt;!--引入JDBC配置文件--&gt;    &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;    &lt;!--开启注解扫描--&gt;    &lt;context:component-scan base-package=\"cn.edu.njust\"&gt;        &lt;!--不扫描Contoller，让SpringMVC扫描--&gt;        &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;    &lt;/context:component-scan&gt;    &lt;!--整合MyBatis--&gt;    &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt;        &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt;        &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt;        &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt;        &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;        &lt;property name=\"configLocation\" value=\"classpath:mybatis.xml\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;        &lt;property name=\"basePackage\" value=\"cn.edu.njust.dao\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--事务控制--&gt;    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;tx:advice id=\"generalTransactionAdvice\" transaction-manager=\"transactionManager\"&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=\"find*\" read-only=\"true\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"insert*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"update*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"delete*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;            &lt;tx:method name=\"save*\" isolation=\"DEFAULT\"&gt;&lt;/tx:method&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;aop:config&gt;        &lt;!--业务层所有方法加上事务--&gt;        &lt;aop:pointcut id=\"generalPointcut\" expression=\"execution(* cn.edu.njust.service.impl.*.*(..))\"/&gt;        &lt;aop:advisor advice-ref=\"generalTransactionAdvice\" pointcut-ref=\"generalPointcut\"&gt;&lt;/aop:advisor&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\nspring-mvc.xml\n123456789101112131415161718&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;!--开启注解--&gt;    &lt;context:component-scan base-package=\"cn.edu.njust.controller\"/&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!--配置视图解析器--&gt;    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"/&gt;    &lt;!--处理静态资源--&gt;    &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt;\n\nweb.xml\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!--Spring配置文件位置--&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring-context.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--Logback配置文件位置--&gt;  &lt;context-param&gt;    &lt;param-name&gt;logbackConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:logback.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--SpringWeb编码过滤器--&gt;  &lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;!--Spring配置文件加载监听器--&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!--Logback加载监听器--&gt;  &lt;listener&gt;    &lt;listener-class&gt;ch.qos.logback.ext.spring.web.LogbackConfigListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!--SpringMVC前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;","thumbnail":"post/其他/配置文件整合/cover.jpg","plink":"https://beginc.github.io/post/其他/配置文件整合/"},{"title":"Java日志框架概况","date":"2019-08-28T14:26:52.000Z","date_formatted":{"ll":"Aug 28, 2019","L":"08/28/2019","MM-DD":"08-28"},"updated":"2020-02-08T02:39:09.488Z","content":"Java日志框架分类日志门面框架主要用于适配各种不同的底层日志实现框架，提供统一访问的API，充当门面\nslf4j\ncommons-logging\n日志实现框架实现具体的记录日志的操作的框架\nlog4j\nlog4j2\nlogback\njava.util.logging\n共性组件Logger提供日志输出的API，但往往不做任何事，实际的操作都通过其他组件实现。\nLoggerManager组织管理所有Logger。\nLevel日志级别。可通过设置日志级别，让高于高级别的日志进行输出，低于该级别的日志无法输出。\nAppender日志输出目的地。通常可输出到Console, File, Socket等地方。\nFilter日志过滤器。用于在日志输出前对其进行过滤。\nFormatter日志格式化。\n层次Logger往往被组织成一个树状层次结构，每个Logger(除了RootLogger)都有一个Parent Logger。\nLogger一般是通过名字来进行层次划分(使用.)。\ncn.edu.njust.dao.UserDao的Parent Logger为cn.edu.njust.dao(若不存在，则继续上溯，直到RootLogger)\n\n\n继承性未经配置的Child Logger往往继承或加性继承（合并）了Parent Logger的一些配置，如Level，Appender，Hierachy等。\n","thumbnail":"post/Java/日志/Java日志框架概况/cover.jpg","plink":"https://beginc.github.io/post/Java/日志/Java日志框架概况/"},{"title":"5-MyBatis缓存","date":"2019-08-28T13:04:25.000Z","date_formatted":{"ll":"Aug 28, 2019","L":"08/28/2019","MM-DD":"08-28"},"updated":"2020-01-23T14:17:58.458Z","content":"一级缓存一级缓存介绍在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。在每个SqlSession中持有Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户。\n一级缓存配置在SqlMapConfig.xml的settings中进行配置，默认值为SESSION\nSESSION缓存作用一次SqlSession\nSTATEMENT只对当前执行的这一个Statement有效\n1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt;    &lt;/settings&gt;&lt;/configuration&gt;\n\n1234student = mapper.findById(1); //不走缓存student = mapper.findById(1); //缓存student = mapper.findById(1); //缓存student = mapper.findById(1); //缓存\n\n调试分析\n进入invoke方法????\n\n调用cachedMapperMethod，methodCache为ConcurrentHashMap，在其中获取存储的方法对象\n\n没有找到该method对象，说明没有进行过调用，为其新建一个MapperMethod对象，存储到methodCache中\n\n执行方法\n\n\n一级缓存特点SESSION Scope缓存只在一个session内有效\n一个session内多次使用同一个查询，除第一次查询外，其他走缓存\n使用修改（增，删，改）操作后一级缓存会被清空失效\n无法适应分布式下多个session的缓解，一级缓存会导致读脏数据\n一级缓存导致脏读123456789101112131415161718192021SqlSession session1 = factory.openSession(true);SqlSession session2 = factory.openSession(true);StudentMapper mapper1 = session1.getMapper(StudentMapper.class);StudentMapper mapper2 = session2.getMapper(StudentMapper.class);// Student(name=\"Bob\")student = mapper1.findById(1); //不走缓存，建立缓存// Student(name=\"Bob\")student = mapper1.findById(1); //session1缓存// Student(name=\"Bob\")student = mapper2.findById(1); //不走缓存，建立缓存// Student(name=\"Bob\")student = mapper2.findById(1); //session2缓存student.setName(\"John\"); mapper1.updateName(student); //更新名字，session1清空缓存session1.commit()// Student(name=\"John\")student = mapper1.findById(1); //不走缓存，建立缓存// Student(name=\"Bob\")student = mapper2.findById(1); //继续走缓存，脏读!!\n\n解决方法\n将localSessionScope设置为STATEMENT\n","thumbnail":"post/Java/MyBatis/5-MyBatis缓存/cover.jpg","plink":"https://beginc.github.io/post/Java/MyBatis/5-MyBatis缓存/"},{"title":"Java反射","date":"2019-08-28T12:32:12.000Z","date_formatted":{"ll":"Aug 28, 2019","L":"08/28/2019","MM-DD":"08-28"},"updated":"2020-01-08T08:31:06.570Z","content":"Class与反射 Java除了基本类型外都是class，class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。该Class包含了该类型的所有信息。通过Class实例获取类信息的方式叫做反射\n类动态加载JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。利用这个特性我们可以在运行时动态加载类。\n获取Class实例类型.class\n1Class cls = String.class;\n\n类的实例.getClass()\n12String s = \"123\";Class cls = s.getClass();\n\nClass.forName(&quot;java.lang.String&quot;)\n\n类的信息cls.getName()获取全称\ncls.getSimpleName()获取类名\ncls.getPackage().getName()获取包名\ncls.isInterface()\ncls.isEnum()\ncls.isArray()\ncls.isPrimitive()\n字段信息获取Field对象Field getField(name)根据字段名获取某个public的field（包括父类）\nField getDeclaredField(name)根据字段名获取当前类的某个field（不包括父类)\nField[] getFields()获取所有public的field（包括父类）\nField[] getDeclaredFields()获取当前类的所有field（不包括父类）\n获取Field对象的信息getName()返回字段名称，例如，&quot;name&quot;；\ngetType()返回字段类型，也是一个Class实例，例如，String.class；\ngetModifiers()返回字段的修饰符，它是一个int，不同的bit表示不同的含义。\n可用Modifier类的一些静态方法来判断\n123456789Field f = String.class.getDeclaredField(\"value\");f.getName(); // \"value\"f.getType(); // class [B 表示byte[]类型int m = f.getModifiers();Modifier.isFinal(m); // trueModifier.isPublic(m); // falseModifier.isProtected(m); // falseModifier.isPrivate(m); // trueModifier.isStatic(m); // false\n\n\n获取Field的值字段.get(类的实例对象)访问实例对象的该字段值\n字段.setAccessible(true)设置实例对象该字段值的可访问性\n123456789101112131415161718public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Object p = new Person(\"Xiao Ming\");        Class c = p.getClass();        Field f = c.getDeclaredField(\"name\");        Object value = f.get(p);        System.out.println(value); // \"Xiao Ming\"    &#125;&#125;class Person &#123;    private String name;    public Person(String name) &#123;        this.name = name;    &#125;&#125;\n\n设置字段的值字段.set(类的实例对象, 值)访问实例对象的该字段值\n字段.setAccessible(true)设置实例对象该字段值的可访问性\n123456789101112131415161718192021222324public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Person p = new Person(\"Xiao Ming\");        System.out.println(p.getName()); // \"Xiao Ming\"        Class c = p.getClass();        Field f = c.getDeclaredField(\"name\");        f.setAccessible(true);        f.set(p, \"Xiao Hong\");        System.out.println(p.getName()); // \"Xiao Hong\"    &#125;&#125;class Person &#123;    private String name;    public Person(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return this.name;    &#125;&#125;\n\n方法信息获取Method对象Method getMethod(name, Class...)获取某个public的Method（包括父类）(第二个参数parameterTypes是按声明顺序标识该方法形参类型，可用于重载的情况)\nMethod getDeclaredMethod(name, Class...)获取当前类的某个Method（不包括父类）(第二个参数parameterTypes是按声明顺序标识该方法形参类型，可用于重载的情况)\nMethod[] getMethods()获取所有public的Method（包括父类）\nMethod[] getDeclaredMethods()获取当前类的所有Method（不包括父类）\n获取Method信息getName()返回方法名称，例如：&quot;getScore&quot;；\ngetReturnType()返回方法返回值类型，也是一个Class实例，例如：String.class；\ngetParameterTypes()返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}；\ngetModifiers()返回方法的修饰符，它是一个int，不同的bit表示不同的含义。\n调用MethodMethod.invoke(对象实例，...)传入对象实例和参数(静态方法第一个参数为null)\nMethod.setAccessible(true)调用非public方法时需要设置允许调用\n构造方法信息直接使用无参构造方法创建实例newInstance()\n1Persons p = Persons.class.newInstance();\n\n获取Constructor对象getConstructor(Class...)获取某个public的Constructor。\ngetDeclaredConstructor(Class...)获取某个Constructor。\ngetConstructors()获取所有public的Constructor。\ngetDeclaredConstructors()获取所有Constructor。\n调用ConstructornewInstance()\nsetAccessable(true)获取访问权限\n12Constructor cons1 = Integer.class.getConstructor(int.class);Integer n1 = (Integer) cons1.newInstance(123);\n\n注解信息判断注解是否存在Class.isAnnotationPresent(Class)\nField.isAnnotationPresent(Class)\nMethod.isAnnotationPresent(Class)\nConstructor.isAnnotationPresent(Class)\n获取Annotation对象获取指定的注解(需要手动转型)\nClass.getAnnotation(Class)\nField.getAnnotation(Class)\nMethod.getAnnotation(Class)\nConstructor.getAnnotation(Class)\n获取所有的注解\nClass.getAnnotations()\nField.getAnnotations()\nMethod.getAnnotations()\nConstructor.getAnnotations()\n12345678910111213141516171819202122232425262728293031@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface OptimizerConfig&#123;    String type() default \"SGD\";    double lr() default 0.02;    int epoch() default 12;&#125;@OptimizerConfig(type=\"SGD\", lr=0.01, epoch=20)class Model&#123;    private String type = \"SGD\";    private double lr = 0.02;    private int epoch = 12;    public Model()&#123;        Class cls = getClass();        if(cls.isAnnotationPresent(OptimizerConfig.class))&#123;            OptimizerConfig config = (OptimizerConfig) cls.getAnnotation(OptimizerConfig.class);            this.type =  config.type();            this.lr = config.lr();            this.epoch = config.epoch();        &#125;    &#125;    public void run()&#123;        System.out.println(\"Running with config:\");        System.out.println(\"Type:\" + type);        System.out.println(\"Lr:\" + lr);        System.out.println(\"Epoch:\" + epoch);    &#125;&#125;\n\n获取方法参数的注解\n方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。\n12345678910111213141516public void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) &#123;&#125;// 获取Method实例:Method m = ...// 获取所有参数的Annotation:Annotation[][] annos = m.getParameterAnnotations();// 第一个参数（索引为0）的所有Annotation:Annotation[] annosOfName = annos[0];for (Annotation anno : annosOfName) &#123;    if (anno instanceof Range) &#123; // @Range注解        Range r = (Range) anno;    &#125;    if (anno instanceof NotNull) &#123; // @NotNull注解        NotNull n = (NotNull) anno;    &#125;&#125;\n\n获取继承关系获取父类的ClassgetSuperClass()\n12Class cls = Integer.class;Class superCls = cls.getSuperClass();\n\n获取Interface用来查询类实现的接口(只返回直接实现的接口，不返回父类实现的)\ngetInterfaces()\n123Class cls = Integer.class;// Interface也是ClassClass[] interfaces = cls.getInterfaces();\n\n判断继承关系isinstanceof, A isinstancesof B当A为B类或者B类的子类时，返回true(向下判断)\nisAssignableFrom, A.isAssignableFrom(B)当B能向上转型为A时返回true(向上判断)\n动态代理动态代理技术即可实现在运行时动态创建实现某个Interface的实例。动态代理实际上是JDK在运行期动态创建class字节码并加载的过程。\nInvocationHandler负责进行具体方法的实现或者增强\nProxy.newProxyInstance()创建代理对象\n1234567891011121314151617181920212223242526272829interface Flyable&#123;    public void fly();&#125;public class Main &#123;    public static void main(String[] args) &#123;        InvocationHandler handler = new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                if(method.getName().equals(\"fly\"))&#123;                    System.out.println(\"判断该方法为目标方法，下面开始实现\");                    System.out.println(\"Flying.....\");                    System.out.println(\"方法实现结束\");                &#125;                System.out.println(\"下面返回参数\");                return null;            &#125;        &#125;;        Flyable flyable = (Flyable) Proxy.newProxyInstance(                Flyable.class.getClassLoader(), // 传入ClassLoader                new Class[]&#123;Flyable.class&#125;, // 传入要实现的接口                handler // 传入InvocationHandler        );        flyable.fly();    &#125;&#125;\n\n\n\n","thumbnail":"post/Java/Java语言/Java反射/cover.jpg","plink":"https://beginc.github.io/post/Java/Java语言/Java反射/"},{"title":"1-SpringMVC入门","date":"2019-08-24T13:42:43.000Z","date_formatted":{"ll":"Aug 24, 2019","L":"08/24/2019","MM-DD":"08-24"},"updated":"2020-02-08T02:43:10.258Z","content":"创建Maven项目创建时使用maven-archetype-webapp\n编译设置123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;org.example&lt;/groupId&gt;  &lt;artifactId&gt;springmvc-01&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;springmvc-01 Maven Webapp&lt;/name&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;  &lt;/properties&gt;&lt;/project&gt;\n\n引入依赖Spring WebMVC\nJavaWeb包(由于tomcat中有这些包, 所以scope需要设置为provided)Servlet\nJSP\n\n12345678910111213141516171819&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;        &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;        &lt;version&gt;2.2.1&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;        &lt;version&gt;3.1.0&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n配置核心组件配置核心配置文件springmvc.xml开启包扫描\n开启Spring MVC注解支持\n1234567891011121314&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txmlns:context=\"http://www.springframework.org/schema/context\"\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\txsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;\t&lt;context:component-scan base-package=\"controller\"/&gt;\t&lt;mvc:annotation-driven/&gt;&lt;/beans&gt;\n\n前端控制器DispatcherServlet前端控制器DispatcherServlet拦截路径\n*.action\n/  拦截所有(包括静态资源不包括JSP)\n/* 拦截所有(包括静态资源和JSP, 会导致跳转到JSP页面被拦截导致出错)\n1234567891011121314151617181920&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;    &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n配置CharacterEncodingFilter解决POST乱码12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;    &lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;    &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;    &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n处理器映射器和处理器适配器方式一: 分别配置123456789101112131415161718&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;context:component-scan base-package=\"controller\"/&gt;    &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"&gt;    &lt;/bean&gt;    &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n方式二: 开启annotation-driven默认都进行了配置1234567891011121314&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;context:component-scan base-package=\"controller\"/&gt;    &lt;mvc:annotation-driven/&gt;&lt;/beans&gt;\n\n\n视图解析器prefix指定视图名称的前缀\nsuffix指定视图名称的后缀\n路径示意图\n\n\n12345678910111213141516171819&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context.xsd \"&gt;    &lt;context:component-scan base-package=\"controller\"/&gt;    &lt;mvc:annotation-driven/&gt;    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;        &lt;property name=\"prefix\" value=\"/\"&gt;&lt;/property&gt;        &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\nController编写123456789@Controller@RequestMapping(\"/account\")public class AccountController &#123;    @RequestMapping(path = \"\")    public String index()&#123;        return \"index\";    &#125;&#125;","thumbnail":"post/Java/SpringMVC/1-SpringMVC入门/cover.png","plink":"https://beginc.github.io/post/Java/SpringMVC/1-SpringMVC入门/"},{"title":"MyBatis整合Spring","date":"2019-08-24T04:38:49.000Z","date_formatted":{"ll":"Aug 24, 2019","L":"08/24/2019","MM-DD":"08-24"},"updated":"2020-01-08T08:31:06.570Z","content":"创建Maven项目编译设置12345678910111213141516&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\t&lt;groupId&gt;cn.edu.njust&lt;/groupId&gt;\t&lt;artifactId&gt;mybatis01&lt;/artifactId&gt;\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\t&lt;name&gt;mybatis01&lt;/name&gt;\t&lt;description&gt;mybatis01&lt;/description&gt;\t&lt;properties&gt;\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\t\t&lt;maven.compiler.source&gt;12&lt;/maven.compiler.source&gt;\t\t&lt;maven.compiler.target&gt;12&lt;/maven.compiler.target&gt;\t&lt;/properties&gt;&lt;/project&gt;\n\n引入依赖MySQL驱动\nJUnit\nMyBatis\nSpring\nmybatis-spring整合包\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.17&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.10&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.2.7&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;        &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.annotation&lt;/groupId&gt;        &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;        &lt;version&gt;1.3.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;version&gt;1.2.2&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n建立pojo对象Student\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package pojo;public class Student &#123;\tprivate int id;\tprivate String name;\tprivate CClass cclass;\tpublic Student() &#123;\t&#125;\tpublic Student(int id, String name, CClass cclass) &#123;\t\tsuper();\t\tthis.id = id;\t\tthis.name = name;\t\tthis.cclass = cclass;\t&#125;\t/**\t * @return the name\t */\tpublic String getName() &#123;\t\treturn name;\t&#125;\t/**\t * @param name the name to set\t */\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t/**\t * @return the cclass\t */\tpublic CClass getCclass() &#123;\t\treturn cclass;\t&#125;\t/**\t * @param cclass the cclass to set\t */\tpublic void setCclass(CClass cclass) &#123;\t\tthis.cclass = cclass;\t&#125;\t/**\t * \t * @return\t */\t@Override\tpublic String toString() &#123;\t\treturn \"Student [id=\" + id + \", name=\" + name + \", cclass=\" + cclass + \"]\";\t&#125;&#125;\n\nCClass\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package pojo;import java.util.List;public class CClass &#123;\tprivate int id;\tprivate String name;\tprivate List&lt;Student&gt; students;\tpublic CClass() &#123;\t&#125;\tpublic CClass(int id, String name, List&lt;Student&gt; students) &#123;\t\tsuper();\t\tthis.id = id;\t\tthis.name = name;\t\tthis.students = students;\t&#125;\t/**\t * @return the id\t */\tpublic int getId() &#123;\t\treturn id;\t&#125;\t/**\t * @param id the id to set\t */\tpublic void setId(int id) &#123;\t\tthis.id = id;\t&#125;\t/**\t * @return the name\t */\tpublic String getName() &#123;\t\treturn name;\t&#125;\t/**\t * @param name the name to set\t */\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\t/**\t * @return the students\t */\tpublic List&lt;Student&gt; getStudents() &#123;\t\treturn students;\t&#125;\t/**\t * @param students the students to set\t */\tpublic void setStudents(List&lt;Student&gt; students) &#123;\t\tthis.students = students;\t&#125;\t/**\t * \t * @return\t */\t@Override\tpublic String toString() &#123;\t\treturn \"CClass [id=\" + id + \", name=\" + name + \", students=\" + students + \"]\";\t&#125;&#125;\n\n为pojo对象建立SqlMap配置文件Student.xml\n123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"mapper.StudentMapper\"&gt;\t&lt;resultMap type=\"Student\" id=\"studentResultMap\"&gt;\t\t&lt;id column=\"sid\" property=\"id\"/&gt;\t\t&lt;result column=\"sname\" property=\"name\"/&gt;\t\t\t\t&lt;association property=\"cclass\" javaType=\"CClass\"&gt;\t\t\t&lt;id column=\"cid\" property=\"id\"/&gt;\t\t\t&lt;result column=\"cname\" property=\"name\"/&gt;\t\t&lt;/association&gt;\t&lt;/resultMap&gt;\t&lt;select id=\"findStudentById\" parameterType=\"Integer\" resultMap=\"studentResultMap\"&gt;\t\tselect student.id as sid, student.name as sname, age, class.id as cid, class.name as cname\t\tfrom student join class\t\ton student.classId = class.id\t\twhere student.id = #&#123;value&#125;\t&lt;/select&gt;&lt;/mapper&gt;\n\nCClass\n123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"mapper.CClassMapper\"&gt;\t&lt;resultMap type=\"CClass\" id=\"cclassResultMap\"&gt;\t\t&lt;id column=\"cid\" property=\"id\"/&gt;\t\t&lt;result column=\"cname\" property=\"name\"/&gt;\t\t\t\t&lt;collection property=\"students\" ofType=\"Student\"&gt;\t\t\t&lt;id column=\"sid\" property=\"id\"/&gt;\t\t\t&lt;result column=\"sname\" property=\"name\"/&gt;\t\t&lt;/collection&gt;\t&lt;/resultMap&gt;\t&lt;select id=\"findCClassById\" parameterType=\"Integer\" resultMap=\"cclassResultMap\"&gt;\t\tselect class.id as cid, class.name as cname, student.id as sid, student.name as sname, age\t\tfrom student join class\t\ton student.classId = class.id\t\twhere class.id = #&#123;value&#125;\t&lt;/select&gt;&lt;/mapper&gt;\n\n配置SqlMapConfig.xml只需配置mappers\n1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;\t&lt;typeAliases&gt;\t\t&lt;package name=\"pojo\"/&gt;\t&lt;/typeAliases&gt;\t\t&lt;mappers&gt;\t\t&lt;mapper resource=\"sqlmap/Student.xml\"/&gt;\t\t&lt;mapper resource=\"sqlmap/CClass.xml\"/&gt;\t&lt;/mappers&gt;&lt;/configuration&gt;\n\nDAO开发配置applicationContext.xmldataSource\nSqlSessionFactory注入dataSource\n注入SqlMapConfig.xml的位置\n\n123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txmlns:context=\"http://www.springframework.org/schema/context\"\txmlns:aop=\"http://www.springframework.org/schema/aop\"\txmlns:tx=\"http://www.springframework.org/schema/tx\"\txsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;\t\t&lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;\t\t&lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimezone=UTC\"/&gt;\t\t&lt;property name=\"username\" value=\"root\"/&gt;\t\t&lt;property name=\"password\" value=\"Hgld521125\"/&gt;\t&lt;/bean&gt;\t\t&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;\t\t&lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\t\t&lt;property name=\"configLocation\" value=\"classpath:SqlMapConfig.xml\"/&gt;\t&lt;/bean&gt;&lt;/beans&gt;\n\nDAO + DAOImplStudentDAO\n1234567package dao;import pojo.Student;public interface StudentDAO &#123;\tpublic Student findStudentById(Integer id);&#125;\n\nStudentDAOImpl\n继承SqlSessionDaoSupport\n通过this.getSqlSession来获取SqlSession\nSpring管理SqlSessionFactory的时候不允许手动关闭session\n1234567891011121314151617package dao.impl;import org.apache.ibatis.session.SqlSession;import org.mybatis.spring.support.SqlSessionDaoSupport;import dao.StudentDAO;import pojo.Student;public class StudentDAOImpl extends SqlSessionDaoSupport implements StudentDAO &#123;\tpublic Student findStudentById(Integer id) &#123;\t\tSqlSession session = this.getSqlSession();\t\tStudent student = session.selectOne(\"findStudentById\", 1);\t\t// session.close();\t\treturn student;\t&#125;&#125;\n\n为StudentDAOImpl注入SqlSessionFacotry\n123&lt;bean id=\"studentDAO\" class=\"dao.impl.StudentDAOImpl\"&gt;    &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt;&lt;/bean&gt;\n\n编写测试123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Test01 &#123;\t@Resource(name = \"studentDAO\")\tprivate StudentDAO studentDAO;\t@Test\tpublic void test01() &#123;\t\tStudent student = this.studentDAO.findStudentById(1);\t\tSystem.out.println(student);\t&#125;&#125;\n\nMapper动态代理开发建立mapper1234567package mapper;import pojo.CClass;public interface CClassMapper &#123;\tpublic CClass findCClassById(Integer id);&#125;\n\n配置applicationContext.xml同\n方式一: MapperFactoryBean该工厂负责生产动态代理产生的mapper\n注入sqlSessionFactory\n注入mapperInterface\n1234&lt;bean id=\"cclassMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt;    &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt;    &lt;property name=\"mapperInterface\" value=\"mapper.CClassMapper\"/&gt;&lt;/bean&gt;\n\n编写测试\n1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Test01 &#123;\t@Resource(name = \"cclassMapper\")\tprivate CClassMapper mapper;\t@Test\tpublic void test02() &#123;\t\tSystem.out.println(mapper.findCClassById(1));\t&#125;&#125;\n\n方式二: MapperScannerConfigurer自动注入sqlSessionFactory\n自动扫描包(及其子包)管理mapper(无需手动为每个mapper配置MapperFactoryBean)\n无需设置id, 直接用mapper名.class在context中获取mapper\n123&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;\t&lt;property name=\"basePackage\" value=\"mapper\" /&gt;&lt;/bean&gt;\n\n\n编写测试\n开启自动扫描, 无法通过name注入mapper, 必须通过context.getBean(CClassMapper.class)获取mapper或者使用@Autowired按类型注入mapper\n1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Test01 &#123;\t@Autowired\tprivate CClassMapper mapper;\t@Test\tpublic void test02() &#123;\t\tSystem.out.println(mapper.findCClassById(1));\t&#125;&#125;\n\n","thumbnail":"post/Java/MyBatis/MyBatis整合Spring/cover.jpg","plink":"https://beginc.github.io/post/Java/MyBatis/MyBatis整合Spring/"},{"title":"4-MyBatis关联查询","date":"2019-08-24T01:58:29.000Z","date_formatted":{"ll":"Aug 24, 2019","L":"08/24/2019","MM-DD":"08-24"},"updated":"2020-01-23T15:52:34.471Z","content":"一对一查询需求查询出账户的同时，将其对应的用户信息也查询出来。\nAccount关联User一个账户对应一个用户，用一个User对象表示。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Account &#123;    private Integer id;    private User user;    private Double money;    public Account(Integer id, User user, Double money) &#123;        this.id = id;        this.user = user;        this.money = money;    &#125;    public Account() &#123;    &#125;    @Override    public String toString() &#123;        return \"Account&#123;\" +                \"id=\" + id +                \", user=\" + user.getId() +                \", money=\" + money +                '&#125;';    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public User getUser() &#123;        return user;    &#125;    public void setUser(User user) &#123;        this.user = user;    &#125;    public Double getMoney() &#123;        return money;    &#125;    public void setMoney(Double money) &#123;        this.money = money;    &#125;&#125;\n\n关联查询编写ResultMapassociation表示一对一关联\ncolumn为用于查询对应用户信息的参数\nproperty为Account对象中User对象的属性名称\njavaType为关联对象的类型\nselect为用column查询用户信息的方法\nfetchTypeeager查询出账户时会马上查询出对应的用户\nlazy延迟加载，使用用户信息时才会查询\n\n123456789&lt;mapper namespace=\"mapper.AccountMapper\"&gt;    &lt;resultMap id=\"accountMap\" type=\"pojo.Account\"&gt;        &lt;id column=\"id\" property=\"id\"/&gt;        &lt;result column=\"money\" property=\"money\"/&gt;        &lt;association column=\"uid\" property=\"user\" javaType=\"pojo.User\" select=\"mapper.UserMapper.find\" fetchType=\"eager\"&gt;        &lt;/association&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;\n\nResultType换成ResultMap1234567&lt;select id=\"findAll\" resultMap=\"accountMap\"&gt;\t&lt;include refid=\"selectAllAttr\"/&gt;&lt;/select&gt;&lt;select id=\"find\" resultMap=\"accountMap\"&gt;\tselect * from account where id = #&#123;id&#125;&lt;/select&gt;\n\n一对多查询需求查询出用户的同时，将其对应的账户信息也查询出来。\nUser关联Account一个用户可有多个账户，用一个List&lt;Account&gt;表示。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class User &#123;    private Integer id;    private String username;    private Date birthday;    private String sex;    private String address;    private List&lt;Account&gt; accounts;    public User(Integer id, String username, Date birthday, String sex, String address, List&lt;Account&gt; accounts) &#123;        this.id = id;        this.username = username;        this.birthday = birthday;        this.sex = sex;        this.address = address;        this.accounts = accounts;    &#125;    public User() &#123;    &#125;    @Override    public String toString() &#123;        return \"User&#123;\" +                \"id=\" + id +                \", username='\" + username + '\\'' +                \", birthday=\" + birthday +                \", sex='\" + sex + '\\'' +                \", address='\" + address + '\\'' +                \", accounts=\" + accounts +                '&#125;';    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public Date getBirthday() &#123;        return birthday;    &#125;    public void setBirthday(Date birthday) &#123;        this.birthday = birthday;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;&#125;\n\n关联查询编写ResultMapcollection表示一对多关联\ncolumn为用于查询对应账户信息的参数\nproperty为User对象中List&lt;Account&gt;的属性名称\nofType为关联对象的类型\nselect为用column查询账户信息的方法\nfetchType\n123456789101112&lt;mapper namespace=\"mapper.UserMapper\"&gt;    &lt;resultMap id=\"userMap\" type=\"pojo.User\"&gt;        &lt;id column=\"id\" property=\"id\"/&gt;        &lt;id column=\"username\" property=\"username\"/&gt;        &lt;id column=\"address\" property=\"address\"/&gt;        &lt;id column=\"sex\" property=\"sex\"/&gt;        &lt;id column=\"birthday\" property=\"birthday\"/&gt;        &lt;collection property=\"accounts\" column=\"uid\" ofType=\"pojo.Account\" select=\"mapper.AccountMapper.findByUID\" fetchType=\"lazy\"&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;\n\nResultType换成ResultMap123456789101112131415161718192021222324252627&lt;select id=\"findAll\" resultMap=\"userMap\"&gt;    &lt;include refid=\"selectAllAttr\"/&gt;&lt;/select&gt;&lt;select id=\"find\" resultMap=\"userMap\"&gt;    select * from user where id = #&#123;id&#125;&lt;/select&gt;&lt;select id=\"findByUsernameOrSex\" parameterType=\"pojo.User\" resultMap=\"userMap\"&gt;    select * from user    &lt;where&gt;        &lt;if test=\"username != null\"&gt;            username = #&#123;username&#125;        &lt;/if&gt;        &lt;if test=\"sex != null\"&gt;            and sex = #&#123;sex&#125;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;&lt;select id=\"findInIDs\" parameterType=\"list\" resultMap=\"userMap\"&gt;    select * from user    &lt;where&gt;        &lt;foreach collection=\"list\" open=\"id in (\" close=\")\" separator=\",\" item=\"id\"&gt;            #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n双向关联中的死递归问题问题我们先看User类和Account类自动生成的toString方法。若我们调用User的toString方法，则会调用Account的toString方法，而Account的toString方法又会调用User的toString方法，如此往复，形成死递归。\nUser\n1234567891011@Overridepublic String toString() &#123;    return \"User&#123;\" +            \"id=\" + id +            \", username='\" + username + '\\'' +            \", birthday=\" + birthday +            \", sex='\" + sex + '\\'' +            \", address='\" + address + '\\'' +            \", accounts=\" + accounts +            '&#125;';&#125;\n\nAccount\n12345678@Overridepublic String toString() &#123;    return \"Account&#123;\" +            \"id=\" + id +            \", user=\" + user +            \", money=\" + money +            '&#125;';&#125;\n\n解决办法\n将Account类中调用User对象toString方法的地方改成user.getId()\n12345678@Overridepublic String toString() &#123;    return \"Account&#123;\" +            \"id=\" + id +            \", user=\" + (user != null ? String.valueOf(user.getId()) : \"null\") +            \", money=\" + money +            '&#125;';&#125;\n\n关联查询中的延迟加载在查询用户时，假若一个用户有10个账户，我们并不想查询用户时同时将用户的10个账户马上查询出来，而是希望在用到某个账户时，对该账户再进行查询，即延迟加载。\n全局开关lazyLoadingEnabled全局开关\naggressiveLazyLoading积极加载\n12345678910111213141516171819202122&lt;configuration&gt;    &lt;settings&gt;        &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt;        &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;    &lt;/settings&gt;    &lt;environments default=\"mysql\"&gt;        &lt;environment id=\"mysql\"&gt;            &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt;            &lt;dataSource type=\"POOLED\"&gt;                &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimezone=UTC\"/&gt;                &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;                &lt;property name=\"username\" value=\"root\"/&gt;                &lt;property name=\"password\" value=\"LQ18851195070\"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=\"SqlMap/User.xml\"/&gt;        &lt;mapper resource=\"SqlMap/Account.xml\"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n局部开关在配置关联时用fetchType指定\n123456789&lt;mapper namespace=\"mapper.AccountMapper\"&gt;    &lt;resultMap id=\"accountMap\" type=\"pojo.Account\"&gt;        &lt;id column=\"id\" property=\"id\"/&gt;        &lt;result column=\"money\" property=\"money\"/&gt;        &lt;association column=\"uid\" property=\"user\" javaType=\"pojo.User\" select=\"mapper.UserMapper.find\" fetchType=\"eager\"&gt;        &lt;/association&gt;    &lt;/resultMap&gt;&lt;/maper&gt;\n\n延迟加载的触发aggressiveLazyLoading为false只有调用getUser()获取用户对象时会触发延迟加载。\n12Account account = accountMapper.find(1);account.getUser();\n\naggressiveLazyLoading为true调用Account对象任何方法都会触发延迟加载。\n12Account account = accountMapper.find(1);account.getId();\n","thumbnail":"post/Java/MyBatis/4-MyBatis关联查询/cover.jpg","plink":"https://beginc.github.io/post/Java/MyBatis/4-MyBatis关联查询/"},{"title":"3-MyBatis动态SQL","date":"2019-08-24T01:12:43.000Z","date_formatted":{"ll":"Aug 24, 2019","L":"08/24/2019","MM-DD":"08-24"},"updated":"2020-01-23T13:37:22.700Z","content":"If-Where标签需求根据名字或性别查询用户(有名字就用名字，有性别就用性别，两者都有就都用)\n编写SqlMap文件用If来判断name和age是否存在, 仅当存在时才作为查询条件\nWhere可用于处理条件语句, 还可以去掉前导and(当只有sex做条件时, 需要去掉前面的and)\n1234567891011&lt;select id=\"findByUsernameOrSex\" parameterType=\"pojo.User\" resultType=\"pojo.User\"&gt;    select * from user    &lt;where&gt;        &lt;if test=\"username != null\"&gt;            username = #&#123;username&#125;        &lt;/if&gt;        &lt;if test=\"sex != null\"&gt;            and sex = #&#123;sex&#125;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;\n\n编写测试123456789101112131415161718192021222324252627282930@Testpublic void testUserFindByUsernameOrSex()&#123;    User user = new User();    List&lt;User&gt; users;    // 根据username查询    user.setUsername(\"罗浩文\");    users = userMapper.findByUsernameOrSex(user);    for (User user1 : users) &#123;        System.out.println(user1);    &#125;    System.out.println(\"-------------------------------------------------------------\");    // 根据sex查询    user.setUsername(null);    user.setSex(\"男\");    users = userMapper.findByUsernameOrSex(user);    for (User user1 : users) &#123;        System.out.println(user1);    &#125;    System.out.println(\"-------------------------------------------------------------\");    // 根据username和sex查询    user.setUsername(\"罗浩文\");    user.setSex(\"男\");    users = userMapper.findByUsernameOrSex(user);    for (User user1 : users) &#123;        System.out.println(user1);    &#125;&#125;\n\nForEach标签需求给定一串id, 查找id在其中的用户(不定数量的id)\n编写SqlMap文件collection指定要遍历的数组或集合\nitem指定取出的元素名\nopen指定前缀\nclose指定后缀\nseperator指定分隔符\n数组数组类型可写为iterator或list\n传数组时, collection名字必须为array\n12345678&lt;select id=\"findInIDs\" parameterType=\"list\" resultType=\"pojo.User\"&gt;    select * from user    &lt;where&gt;        &lt;foreach collection=\"array\" open=\"id in (\" close=\")\" separator=\",\" item=\"id\"&gt;            #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\nListList类型可写成list\n传List时, collection名字必须为list\n12345678&lt;select id=\"findInIDs\" parameterType=\"list\" resultType=\"pojo.User\"&gt;    select * from user    &lt;where&gt;        &lt;foreach collection=\"list\" open=\"id in (\" close=\")\" separator=\",\" item=\"id\"&gt;            #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n编写测试12345678@Testpublic void testUserFindInIDs()&#123;    List&lt;Integer&gt; ids = List.of(41, 42, 43);    List&lt;User&gt; users = userMapper.findInIDs(ids);    for (User user : users) &#123;        System.out.println(user);    &#125;&#125;\n\nSQL片段可用于提取常用的一些SQL片段\n123456&lt;sql id=\"selectAllAttr\"&gt;    select * from user&lt;/sql&gt;&lt;select id=\"findAll\" resultType=\"pojo.User\"&gt;    &lt;include refid=\"selectAllAttr\"/&gt;&lt;/select&gt;","thumbnail":"post/Java/MyBatis/3-MyBatis动态SQL/cover.jpg","plink":"https://beginc.github.io/post/Java/MyBatis/3-MyBatis动态SQL/"},{"title":"2-MyBatis动态代理开发","date":"2019-08-23T15:52:46.000Z","date_formatted":{"ll":"Aug 23, 2019","L":"08/23/2019","MM-DD":"08-23"},"updated":"2020-01-23T12:43:13.219Z","content":"动态代理开发简介使用动态代理开发，我们只需要负责定义查询相关的接口规范(Mapper)以及编写相应SQL语句，无需对接口进行实现，MyBatis借助动态代理技术为我们生成增强对象，实现相应的查询方法。\nMyBatis动态代理开发规范mapper方法名与SqlMap文件中对应statement的id一致\nmapper返回值类型与SqlMap文件中对应statement的返回类型一致\nmapper参数类型与SqlMap文件中对应statement的参数类型一致\nSqlMap中namespace必须为Mapper接口的全称\n建立UserMapper新建包mapper, 建立UserMapper接口\n123456789101112public interface UserMapper &#123;    List&lt;User&gt; findAll();    User find(Integer id);    void save(User user);    void update(User user);    void delete(Integer id);&#125;\n\n修改User.xml中的namespace123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"mapper.UserMapper\"&gt;    &lt;select id=\"findAll\" resultType=\"pojo.User\"&gt;        select * from user    &lt;/select&gt;    &lt;select id=\"find\" resultType=\"pojo.User\"&gt;        select * from user where id = #&#123;id&#125;    &lt;/select&gt;    &lt;delete id=\"delete\"&gt;        delete from user where id = #&#123;id&#125;    &lt;/delete&gt;    &lt;update id=\"update\"&gt;        update user set        username = #&#123;username&#125;, address = #&#123;address&#125;, sex = #&#123;sex&#125;, birthday = #&#123;birthday&#125;        where id = #&#123;id&#125;    &lt;/update&gt;    &lt;insert id=\"save\"&gt;        insert into user        (username, address, sex, birthday) values        (#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;)        &lt;selectKey keyProperty=\"id\" keyColumn=\"id\" resultType=\"Integer\"&gt;            select LAST_INSERT_ID()        &lt;/selectKey&gt;    &lt;/insert&gt;&lt;/mapper&gt;\n\n编写测试通过SqlSession获取Mapper\n调用Mapper的方法\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Test01 &#123;    private static final Logger logger = LoggerFactory.getLogger(Test01.class);    private static SqlSessionFactory factory;    private SqlSession session;    private UserMapper userMapper;    @BeforeClass    public static void setUpClass() throws IOException &#123;        factory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(\"SqlMapConfig.xml\"));    &#125;    @Before    public void setUp() throws IOException &#123;        session = factory.openSession();        userMapper = session.getMapper(UserMapper.class);    &#125;    @After    public void tearDown() &#123;        session.commit();        session.close();    &#125;    @Test    public void testUserFindAll() &#123;        List&lt;User&gt; users = userMapper.findAll();        for (User user : users) &#123;            System.out.println(user);        &#125;    &#125;    @Test    public void testUserSave() &#123;        User user = new User();        user.setAddress(\"耒阳\");        user.setUsername(\"罗浩文\");        user.setBirthday(new Date());        user.setSex(\"男\");        userMapper.save(user);        System.out.println(user);    &#125;    @Test    public void testUserDelete() &#123;        userMapper.delete(57);    &#125;    @Test    public void testUserFind() &#123;        User user = userMapper.find(41);        System.out.println(user);    &#125;&#125;\n\n\n","thumbnail":"post/Java/MyBatis/2-MyBatis动态代理开发/cover.jpg","plink":"https://beginc.github.io/post/Java/MyBatis/2-MyBatis动态代理开发/"},{"title":"1-MyBatis入门","date":"2019-08-23T13:49:25.000Z","date_formatted":{"ll":"Aug 23, 2019","L":"08/23/2019","MM-DD":"08-23"},"updated":"2020-01-23T12:30:54.684Z","content":"创建Maven项目编译设置12345678910111213141516171819202122&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-01&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\t&lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;source&gt;11&lt;/source&gt;                    &lt;target&gt;11&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n引入依赖MySQL驱动\nJUnit\nMyBatis\nLogback\n12345678910111213141516171819202122232425262728&lt;dependencies&gt;\t&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;\t&lt;dependency&gt;\t\t&lt;groupId&gt;org.mybatis&lt;/groupId&gt;\t\t&lt;artifactId&gt;mybatis&lt;/artifactId&gt;\t\t&lt;version&gt;3.5.1&lt;/version&gt;\t&lt;/dependency&gt;\t&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;\t&lt;dependency&gt;\t\t&lt;groupId&gt;junit&lt;/groupId&gt;\t\t&lt;artifactId&gt;junit&lt;/artifactId&gt;\t\t&lt;version&gt;4.12&lt;/version&gt;\t\t&lt;scope&gt;test&lt;/scope&gt;\t&lt;/dependency&gt;\t&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;\t&lt;dependency&gt;\t\t&lt;groupId&gt;mysql&lt;/groupId&gt;\t\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\t\t&lt;version&gt;8.0.15&lt;/version&gt;\t&lt;/dependency&gt;\t&lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;\t&lt;dependency&gt;\t\t&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\t\t&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;\t\t&lt;version&gt;1.2.3&lt;/version&gt;\t\t&lt;scope&gt;test&lt;/scope&gt;\t&lt;/dependency&gt;&lt;/dependencies&gt;\n\n配置SqlMapConfig.xml在src/main/resource下建立SqlMapConfig.xml配置文件, 配置数据源和事务管理器。\n123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"        \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;environments default=\"mysql\"&gt;        &lt;environment id=\"mysql\"&gt;            &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt;            &lt;dataSource type=\"POOLED\"&gt;                &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimezone=UTC\"/&gt;                &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;                &lt;property name=\"username\" value=\"root\"/&gt;                &lt;property name=\"password\" value=\"LQ18851195070\"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;&lt;/configuration&gt;\n\n建立pojo对象必须提供一个无参数的构造方法\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class User &#123;    private Integer id;    private String username;    private Date birthday;    private String sex;    private String address;    public User(Integer id, String username, Date birthday, String sex, String address) &#123;        this.id = id;        this.username = username;        this.birthday = birthday;        this.sex = sex;        this.address = address;    &#125;    public User() &#123;    &#125;    @Override    public String toString() &#123;        return \"User&#123;\" +                \"id=\" + id +                \", username='\" + username + '\\'' +                \", birthday=\" + birthday +                \", sex='\" + sex + '\\'' +                \", address='\" + address + '\\'' +                '&#125;';    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public Date getBirthday() &#123;        return birthday;    &#125;    public void setBirthday(Date birthday) &#123;        this.birthday = birthday;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;&#125;\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Account &#123;    private Integer id;    private Integer uid;    private Double money;    public Account(Integer id, Integer uid, Double money) &#123;        this.id = id;        this.uid = uid;        this.money = money;    &#125;    public Account() &#123;    &#125;    @Override    public String toString() &#123;        return \"Account&#123;\" +                \"id=\" + id +                \", uid=\" + uid +                \", money=\" + money +                '&#125;';    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public Integer getUid() &#123;        return uid;    &#125;    public void setUid(Integer uid) &#123;        this.uid = uid;    &#125;    public Double getMoney() &#123;        return money;    &#125;    public void setMoney(Double money) &#123;        this.money = money;    &#125;&#125;\n\n为pojo对象建立SqlMap配置文件在src/main/resource下建立一个SqlMap文件夹, 建立User.xml(对于Account类下面操作相同)\n1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"User\"&gt;&lt;/mapper&gt;\n\n在SqlMapConfig.xml中引用该SqlMap文件\n12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;environments default=\"mysql\"&gt;        &lt;environment id=\"mysql\"&gt;            &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt;            &lt;dataSource type=\"POOLED\"&gt;                &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimezone=UTC\"/&gt;                &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;                &lt;property name=\"username\" value=\"root\"/&gt;                &lt;property name=\"password\" value=\"LQ18851195070\"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=\"SqlMap/User.xml\"/&gt;        &lt;mapper resource=\"SqlMap/Account.xml\"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n\n实现User基本需求List&lt;User&gt; findAll()\nUser find(Integer id)\nvoid update(User user)\nvoid save(User user)\nvoid delete(Integer id)\n查询单个User123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"User\"&gt;\t&lt;select id=\"find\" resultType=\"pojo.User\"&gt;        select * from user where id = #&#123;id&#125;    &lt;/select&gt;&lt;/mapper&gt;\n\n\n添加User123456789&lt;insert id=\"save\"&gt;\tinsert into user\t(username, address, sex, birthday) values\t(#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;)\t&lt;selectKey keyProperty=\"id\" keyColumn=\"id\" resultType=\"Integer\"&gt;\t\tselect LAST_INSERT_ID()\t&lt;/selectKey&gt;&lt;/insert&gt;\n\n\n更新User12345&lt;update id=\"update\"&gt;\tupdate user set\tusername = #&#123;username&#125;, address = #&#123;address&#125;, sex = #&#123;sex&#125;, birthday = #&#123;birthday&#125;\twhere id = #&#123;id&#125;&lt;/update&gt;\n\n\n删除User123&lt;delete id=\"delete\"&gt;\tdelete from user where id = #&#123;id&#125;&lt;/delete&gt;\n\n编写测试默认需要手动提交事务session.commit()\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Test01 &#123;    private static final Logger logger = LoggerFactory.getLogger(Test01.class);    private static SqlSessionFactory factory;    private SqlSession session;    @BeforeClass    public static void setUpClass() throws IOException &#123;        factory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream(\"SqlMapConfig.xml\"));    &#125;    @Before    public void setUp() throws IOException &#123;        session = factory.openSession();    &#125;    @After    public void tearDown() &#123;        session.commit();        session.close();    &#125;    @Test    public void testUserFindAll() &#123;        List&lt;User&gt; users = session.selectList(\"User.findAll\");        for (User user : users) &#123;            System.out.println(user);        &#125;    &#125;    @Test    public void testUserSave() &#123;        User user = new User();        user.setAddress(\"耒阳\");        user.setUsername(\"罗浩文\");        user.setBirthday(new Date());        user.setSex(\"男\");        session.insert(\"User.save\", user);        System.out.println(user);    &#125;    @Test    public void testUserDelete() &#123;        session.delete(\"User.delete\", 55);    &#125;    @Test    public void testUserFind() &#123;        User user = session.selectOne(\"User.find\", 41);        System.out.println(user);    &#125;&#125;\n","thumbnail":"post/Java/MyBatis/1-MyBatis入门/cover.jpg","plink":"https://beginc.github.io/post/Java/MyBatis/1-MyBatis入门/"}]