{"title":"Java集合之HashMap","date":"2020-03-04T03:19:11.000Z","date_formatted":{"ll":"Mar 4, 2020","L":"03/04/2020","MM-DD":"03-04"},"thumbnail":"post/Java/Java语言/Java集合/Java集合之HashMap/cover.jpg","link":"post/Java/Java语言/Java集合/Java集合之HashMap","categories":["Java","Java语言","Java集合"],"updated":"2020-03-16T15:30:48.408Z","content":"<h1 id=\"继承体系\">继承体系<a href=\"#继承体系\" title=\"继承体系\"></a></h1><p>Map接口的实现类。</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap/image-20200304120157271.png\" class=\"\">\n\n<h1 id=\"hashmap之jdk18\">HashMap之JDK1.8<a href=\"#hashmap之jdk18\" title=\"HashMap之JDK1.8\"></a></h1><h2 id=\"底层实现\">底层实现<a href=\"#底层实现\" title=\"底层实现\"></a></h2><p>哈希表</p>\n<ul><li>冲突解决方法---&gt;拉链法<ul><li>链表</li>\n<li>红黑树</li>\n</ul></li>\n</ul><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap/image-20200304121001566.png\" class=\"\">\n\n<h2 id=\"hashmap重点问题\">HashMap重点问题<a href=\"#hashmap重点问题\" title=\"HashMap重点问题\"></a></h2><ul><li><p>哈希算法</p>\n</li>\n<li><p>哈希表的尺寸问题</p>\n<ul><li>扩容<ul><li>何时扩容</li>\n<li>扩多少</li>\n</ul></li>\n<li>Rehash</li>\n</ul></li>\n<li><p>拉链查找的效率问题</p>\n<ul><li>链表与红黑树的转化时机</li>\n</ul></li>\n</ul><h2 id=\"哈希算法\">哈希算法<a href=\"#哈希算法\" title=\"哈希算法\"></a></h2><p><strong>哈希算法的优劣</strong></p>\n<p>评判一下哈希算法的优劣主要就是看是否能将key均匀的映射到桶上，减少哈希冲突。</p>\n<p><strong>三次运算</strong></p>\n<ol><li>key.hashCode()</li>\n</ol><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key.hashCode()</span><br></pre></td></tr></table></figure>\n\n<ol><li><p>扰动</p>\n<ul><li><p>将hashCode的低16位和高16位进行按位异或</p>\n</li>\n<li><p>1次异或运算</p>\n</li>\n<li><p>让hash分布的更均匀</p>\n</li>\n</ul></li>\n</ol><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span><br></pre></td></tr></table></figure>\n\n<ol><li>与bucketSize进行模运算<ul><li>此处位运算与hash % bucketSize等价，但是效率更高</li>\n</ul></li>\n</ol><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index = hash &amp; (bucketSize - <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"哈希表的初始化\">哈希表的初始化<a href=\"#哈希表的初始化\" title=\"哈希表的初始化\"></a></h2><p>JDK1.8中哈希表在第一次put操作时才进行延迟初始化，分配桶数组空间。</p>\n<h2 id=\"哈希表的尺寸问题\">哈希表的尺寸问题<a href=\"#哈希表的尺寸问题\" title=\"哈希表的尺寸问题\"></a></h2><h3 id=\"何时扩容\">何时扩容<a href=\"#何时扩容\" title=\"何时扩容\"></a></h3><p>当前元素数量大于阈值时进行扩容。</p>\n<p><strong>阈值</strong></p>\n<ul><li>loadFactory为重要参数<ul><li>哈希表的效率由loadFactory决定<ul><li>过高则查找效率太低</li>\n<li>过低则空间利用率太低</li>\n</ul></li>\n</ul></li>\n<li>默认loadFactory为0.75</li>\n</ul><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threshold = capacity * loadFactor</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"扩多少\">扩多少<a href=\"#扩多少\" title=\"扩多少\"></a></h3><p>每次扩容到原来尺寸的一倍</p>\n<ul><li>16---&gt;32</li>\n<li>32---&gt;64</li>\n<li>...</li>\n</ul><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newCap = oldCap &lt;&lt; <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rehash\">Rehash<a href=\"#rehash\" title=\"Rehash\"></a></h3><p>扩容之后会对元素重新进行hash，让元素均匀分布到新的哈希表上。</p>\n<p><strong>优化点</strong></p>\n<p>由于每次扩容为原来的两倍，元素重新进行哈希后只可能落在两个桶中的一个</p>\n<ul><li>当<code>hash &amp; oldCap == 0</code>：落在原来的桶</li>\n<li>当<code>hash &amp; oldCap == 1</code>：落在原来的桶的下标再加上oldCap处</li>\n</ul><p>利用此点可避免rehash时重新计算每一个key的hash。</p>\n<p><strong>链表插入方法</strong></p>\n<ul><li>尾插法（<strong>避免并发扩容时发生循环死链</strong>）</li>\n</ul><h2 id=\"拉链查找的效率问题\">拉链查找的效率问题<a href=\"#拉链查找的效率问题\" title=\"拉链查找的效率问题\"></a></h2><p>当哈希冲突过多时，使用原始拉链法则会造成同一个桶的链很长，查找效率过低，因此JDK1.8中引入了红黑树进行优化</p>\n<ul><li>当链过长时会将其转化为红黑树</li>\n<li>当链过短时会将其退化为链表</li>\n</ul><h3 id=\"转化时机\">转化时机<a href=\"#转化时机\" title=\"转化时机\"></a></h3><p><strong>链表转红黑树</strong></p>\n<ol><li>桶数组长度大于等于MIN_TREEIFY_CAPACITY（64）</li>\n<li>该链长度大于TREEIFY_THRESHOLD（8）</li>\n</ol><p><strong>红黑树转链表</strong></p>\n<ol><li>链表长度小于UNTREEIFY_THRESHOLD</li>\n</ol><h1 id=\"hashmap之17\">HashMap之1.7<a href=\"#hashmap之17\" title=\"HashMap之1.7\"></a></h1><h2 id=\"底层实现-1\">底层实现<a href=\"#底层实现-1\" title=\"底层实现\"></a></h2><p>哈希表</p>\n<ul><li>冲突解决方法---&gt;拉链法<ul><li>链表</li>\n</ul></li>\n</ul><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap/image-20200304140116866.png\" class=\"\">\n\n<h2 id=\"哈希算法-1\">哈希算法<a href=\"#哈希算法-1\" title=\"哈希算法\"></a></h2><p><strong>三次运算</strong></p>\n<ol><li>key.hashCode()</li>\n</ol><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key.hashCode()</span><br></pre></td></tr></table></figure>\n\n<ol><li><p>扰动</p>\n<ul><li><p>5次异或运算</p>\n</li>\n<li><p>让hash分布的更均匀</p>\n</li>\n</ul></li>\n</ol><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h ^&#x3D; k.hashCode();</span><br><span class=\"line\">h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class=\"line\">h &#x3D; h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br></pre></td></tr></table></figure>\n\n<ol><li>与bucketSize进行模运算</li>\n</ol><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index = hash &amp; (bucketSize - <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"哈希表的初始化-1\">哈希表的初始化<a href=\"#哈希表的初始化-1\" title=\"哈希表的初始化\"></a></h2><p>JDK1.7中哈希表在构造方法处就进行初始化，分配桶数组空间。</p>\n<h2 id=\"哈希表的尺寸问题-1\">哈希表的尺寸问题<a href=\"#哈希表的尺寸问题-1\" title=\"哈希表的尺寸问题\"></a></h2><h3 id=\"何时扩容-1\">何时扩容<a href=\"#何时扩容-1\" title=\"何时扩容\"></a></h3><p>同JDK1.8。</p>\n<h3 id=\"扩多少-1\">扩多少<a href=\"#扩多少-1\" title=\"扩多少\"></a></h3><p>同JDK1.8。</p>\n<h3 id=\"rehash-1\">Rehash<a href=\"#rehash-1\" title=\"Rehash\"></a></h3><p>扩容之后会对元素重新进行hash，让元素均匀分布到新的哈希表上。</p>\n<ul><li><p>哈希无优化，直接重新计算</p>\n</li>\n<li><p>链表插入方法为尾插法（<strong>并发扩容时可能发生循环死链</strong>）</p>\n</li>\n</ul><h2 id=\"并发死链\">并发死链<a href=\"#并发死链\" title=\"并发死链\"></a></h2><p>TODO</p>\n<h1 id=\"hashmap17与18比较\">HashMap1.7与1.8比较<a href=\"#hashmap17与18比较\" title=\"HashMap1.7与1.8比较\"></a></h1><div class=\"cz\"><div class=\"db\"><table><thead><tr>\n<th>功能</th><th>1.7</th><th>1.8</th></tr>\n</thead><tbody><tr>\n<td>拉链结构</td><td>链表</td><td>链表 + 红黑树</td></tr>\n<tr>\n<td>扩容时链表插入方式</td><td>头插法</td><td>尾插法</td></tr>\n<tr>\n<td>哈希表初始化时机</td><td>构造器初始化</td><td>第一次put时延迟初始化</td></tr>\n<tr>\n<td>哈希算法</td><td>五次异或</td><td>一次异或</td></tr>\n<tr>\n<td>Rehash</td><td>重新计算hash</td><td>不用重新计算哈希</td></tr>\n</tbody></table></div></div>","prev":{"title":"Java集合之Map","link":"post/Java/Java语言/Java集合/Java集合之Map"},"next":{"title":"JVM之类加载","link":"post/Java/JVM/JVM之类加载"},"plink":"https://beginc.github.io/post/Java/Java语言/Java集合/Java集合之HashMap/","toc":[{"id":"继承体系","title":"继承体系","index":"1"},{"id":"hashmap之jdk18","title":"HashMap之JDK1.8","index":"2","children":[{"id":"底层实现","title":"底层实现","index":"2.1"},{"id":"hashmap重点问题","title":"HashMap重点问题","index":"2.2"},{"id":"哈希算法","title":"哈希算法","index":"2.3"},{"id":"哈希表的初始化","title":"哈希表的初始化","index":"2.4"},{"id":"哈希表的尺寸问题","title":"哈希表的尺寸问题","index":"2.5","children":[{"id":"何时扩容","title":"何时扩容","index":"2.5.1"},{"id":"扩多少","title":"扩多少","index":"2.5.2"},{"id":"rehash","title":"Rehash","index":"2.5.3"}]},{"id":"拉链查找的效率问题","title":"拉链查找的效率问题","index":"2.6","children":[{"id":"转化时机","title":"转化时机","index":"2.6.1"}]}]},{"id":"hashmap之17","title":"HashMap之1.7","index":"3","children":[{"id":"底层实现-1","title":"底层实现","index":"3.1"},{"id":"哈希算法-1","title":"哈希算法","index":"3.2"},{"id":"哈希表的初始化-1","title":"哈希表的初始化","index":"3.3"},{"id":"哈希表的尺寸问题-1","title":"哈希表的尺寸问题","index":"3.4","children":[{"id":"何时扩容-1","title":"何时扩容","index":"3.4.1"},{"id":"扩多少-1","title":"扩多少","index":"3.4.2"},{"id":"rehash-1","title":"Rehash","index":"3.4.3"}]},{"id":"并发死链","title":"并发死链","index":"3.5"}]},{"id":"hashmap17与18比较","title":"HashMap1.7与1.8比较","index":"4"}]}