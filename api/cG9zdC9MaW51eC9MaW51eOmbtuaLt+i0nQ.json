{"title":"Linux零拷贝","date":"2020-02-27T12:48:47.000Z","date_formatted":{"ll":"Feb 27, 2020","L":"02/27/2020","MM-DD":"02-27"},"thumbnail":"post/Linux/Linux零拷贝/cover.jpg","link":"post/Linux/Linux零拷贝","categories":["Linux"],"updated":"2020-02-29T16:20:49.597Z","content":"<h1 id=\"传统io\">传统I/O<a href=\"#传统io\" title=\"传统I/O\"></a></h1><p>传统的read和write系统调用涉及到了</p>\n<ul><li>4次用户态内核态上下文切换</li>\n<li>2次CPU拷贝</li>\n<li>2次DMA拷贝</li>\n</ul><p>效率较为低下。</p>\n<img src=\"/post/Linux/Linux%E9%9B%B6%E6%8B%B7%E8%B4%9D/v2-18e66cbb4e06d1f13e4335898c7b8e8c_720w.jpg\" class=\"\">\n\n<h1 id=\"零拷贝\">零拷贝<a href=\"#零拷贝\" title=\"零拷贝\"></a></h1><p>零拷贝技术核心目的就是要减少内存拷贝，减少内核态用户态上下文切换。</p>\n<h2 id=\"用户态直接io\">用户态直接I/O<a href=\"#用户态直接io\" title=\"用户态直接I/O\"></a></h2><p>让进程直接在用户态下进行I/O操作。</p>\n<p><strong>优点</strong></p>\n<ul><li>无上下文切换</li>\n<li>无CPU拷贝</li>\n</ul><p><strong>缺点</strong></p>\n<ul><li>失去了OS的缓冲区管理功能，需要用户自己维护缓存区</li>\n<li>CPU和硬件设备速度差异大，造成了过多了CPU时间浪费</li>\n</ul><img src=\"/post/Linux/Linux%E9%9B%B6%E6%8B%B7%E8%B4%9D/v2-4cb0f465ebeb7ff0f5e31e8d3f790c80_720w.jpg\" class=\"\">\n\n<h2 id=\"mmap--write\">Mmap + Write<a href=\"#mmap--write\" title=\"Mmap + Write\"></a></h2><p>内存映射文件，将一个进程的地址空间中的一段虚拟地址映射到磁盘文件地址。该模式下用户与内核共享一块缓存空间，减少了一次CPU拷贝</p>\n<ul><li>4次上下文切换</li>\n<li>1次CPU拷贝</li>\n<li>2次DMA拷贝</li>\n</ul><p><strong>缺点</strong></p>\n<p>该磁盘文件可能被另一个进程截获，write调用会被终止。</p>\n<img src=\"/post/Linux/Linux%E9%9B%B6%E6%8B%B7%E8%B4%9D/v2-28463616753963ac9f189ce23a485e2d_720w.jpg\" class=\"\">\n\n<h2 id=\"sendfile\">Sendfile<a href=\"#sendfile\" title=\"Sendfile\"></a></h2><p>用于直接在两个通道之中进行数据传输，数据不经过用户空间。</p>\n<ul><li>2次上下文切换</li>\n<li>1次CPU拷贝</li>\n<li>2次DMA拷贝</li>\n</ul><p><strong>缺点</strong></p>\n<ul><li>数据不经过用户空间，用户无法对数据进行更改，只适用于纯粹的数据传输。</li>\n<li>只能从文件拷贝到套接字。</li>\n</ul><img src=\"/post/Linux/Linux%E9%9B%B6%E6%8B%B7%E8%B4%9D/v2-48132735369375701f3d8ac1d6029c2a_720w.jpg\" class=\"\">\n\n<h2 id=\"sendfile--dma-gather-copy\">Sendfile + DMA Gather Copy<a href=\"#sendfile--dma-gather-copy\" title=\"Sendfile + DMA Gather Copy\"></a></h2><p>sendfile模式下，还是存在一次不必要的CPU拷贝，sendfile加上DMA Gather Copy之后</p>\n<ul><li>读完数据将缓冲区文件描述符和数据长度拷贝到Socket缓冲区。</li>\n<li>DMA Gather Copy直接根据描述信息到内核缓冲区拿数据。</li>\n</ul><p>该模式下涉及到了</p>\n<ul><li>2次上下文切换</li>\n<li>0次CPU拷贝</li>\n<li>2次DMA拷贝</li>\n</ul><p><strong>缺点</strong></p>\n<ul><li>需要硬件支持。</li>\n<li>只能从文件拷贝到套接字。</li>\n</ul><img src=\"/post/Linux/Linux%E9%9B%B6%E6%8B%B7%E8%B4%9D/v2-15edf2971101883e2a90253225a3b0d3_720w.jpg\" class=\"\">\n\n<h2 id=\"splice\">Splice<a href=\"#splice\" title=\"Splice\"></a></h2><p>sendfile需要硬件支持，还只支持从文件到套接字的拷贝，而splice模式下</p>\n<ul><li>不需要硬件支持</li>\n<li>支持两个文件描述符之间的拷贝</li>\n</ul><p>通过在内核缓冲区和Socket缓冲区之间建立了管道，避免了CPU拷贝</p>\n<ul><li>2次上下文切换</li>\n<li>0次CPU拷贝</li>\n<li>2次DMA拷贝</li>\n</ul><img src=\"/post/Linux/Linux%E9%9B%B6%E6%8B%B7%E8%B4%9D/v2-37cf7a8b129183c24c7b524d3fee1a29_720w.jpg\" class=\"\">\n\n\n<h1 id=\"参考\">参考<a href=\"#参考\" title=\"参考\"></a></h1><ol><li><a href=\"https://zhuanlan.zhihu.com/p/83398714\" target=\"_blank\">深入剖析Linux IO原理和几种零拷贝机制的实现</a></li>\n</ol>","prev":{"title":"I/O模型","link":"post/Linux/IO模型"},"next":{"title":"RocketMQ之高性能消息存储","link":"post/中间件/RocketMQ/RocketMQ之高性能消息存储"},"plink":"https://beginc.github.io/post/Linux/Linux零拷贝/","toc":[{"id":"传统io","title":"传统I&#x2F;O","index":"1"},{"id":"零拷贝","title":"零拷贝","index":"2","children":[{"id":"用户态直接io","title":"用户态直接I&#x2F;O","index":"2.1"},{"id":"mmap--write","title":"Mmap + Write","index":"2.2"},{"id":"sendfile","title":"Sendfile","index":"2.3"},{"id":"sendfile--dma-gather-copy","title":"Sendfile + DMA Gather Copy","index":"2.4"},{"id":"splice","title":"Splice","index":"2.5"}]},{"id":"参考","title":"参考","index":"3"}]}