{"title":"Java并发之自旋锁","date":"2020-03-15T16:34:38.000Z","date_formatted":{"ll":"Mar 16, 2020","L":"03/16/2020","MM-DD":"03-16"},"link":"post/Java/Java语言/Java并发/Java并发之自旋锁","categories":["Java","Java并发","Java语言"],"updated":"2020-03-16T15:30:48.408Z","content":"<h1 id=\"自旋锁\">自旋锁<a href=\"#自旋锁\" title=\"自旋锁\"></a></h1><p>自旋锁即在获取锁失败时，不会马上阻塞，而是会持续重复尝试，直到获取锁成功。</p>\n<p><strong>优点</strong></p>\n<ul><li>避免阻塞休眠和唤醒所带来的CPU上下文切换的开销</li>\n</ul><p><strong>缺点</strong></p>\n<ul><li>如果某个线程长时间持有锁不释放，则会导致其他线程一直空轮询而带来无用的CPU消耗</li>\n</ul><h1 id=\"自旋锁实现\">自旋锁实现<a href=\"#自旋锁实现\" title=\"自旋锁实现\"></a></h1><p>以下都是基于CAS来实现自旋锁。</p>\n<h2 id=\"简单cas自旋锁\">简单CAS自旋锁<a href=\"#简单cas自旋锁\" title=\"简单CAS自旋锁\"></a></h2><p>使用owner来指示当前锁的拥有者</p>\n<p><strong>加锁</strong></p>\n<ul><li>若未被加锁：将owner设置为当前线程</li>\n<li>若已被加锁：自旋对owner进行CAS</li>\n</ul><p><strong>解锁</strong></p>\n<p>将owner设置为null</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpinLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicReference&lt;Thread&gt; owner = <span class=\"keyword\">new</span> AtomicReference&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread currentThread = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(currentThread == owner.get())</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">        <span class=\"comment\">// 自旋获取锁</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!owner.compareAndSet(<span class=\"keyword\">null</span>, currentThread)) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread currentThread = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentThread != owner.get())</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\"></span><br><span class=\"line\">        owner.compareAndSet(currentThread, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>缺点</strong></p>\n<ul><li>不可重入</li>\n<li>不公平，不能让等待时间最长的线程先获取锁</li>\n</ul><h2 id=\"可重入简单cas自旋锁\">可重入简单CAS自旋锁<a href=\"#可重入简单cas自旋锁\" title=\"可重入简单CAS自旋锁\"></a></h2><p>增加count来记录重入数量。</p>\n<ul><li>重入时count++</li>\n<li>释放锁时count--<ul><li>count为0释放锁</li>\n<li>count不为0不释放</li>\n</ul></li>\n</ul><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReentrantSpinLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicReference&lt;Thread&gt; owner = <span class=\"keyword\">new</span> AtomicReference&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread currentThread = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentThread == owner.get()) &#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 自旋获取锁</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!owner.compareAndSet(<span class=\"keyword\">null</span>, currentThread)) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread currentThread = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentThread != owner.get())</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            count--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(count == <span class=\"number\">0</span>)</span><br><span class=\"line\">                owner.compareAndSet(currentThread, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ticketlock\">TicketLock<a href=\"#ticketlock\" title=\"TicketLock\"></a></h2><p>TicketLock用来解决自旋锁的公平性问题。</p>\n<h3 id=\"原理\">原理<a href=\"#原理\" title=\"原理\"></a></h3><p><strong>场景解析</strong></p>\n<p>想象我们在银行柜台排队，柜台会给每个人发一张票，上面记录着一个号码，然后柜台自己会维护一个 当前服务客户的号码，每次结束服务后，就会叫下一个号，只有在叫到自己的号码时，才可以去柜台办理业务。</p>\n<p><strong>ServiceNumber</strong></p>\n<p>当前服务编号，记录当前获取到锁的线程的编号。</p>\n<p><strong>TicketNumber</strong></p>\n<p>排队线程的编号，只有当ServiceNumber等于自己的TicketNumber时才获取到锁。</p>\n<h3 id=\"实现\">实现<a href=\"#实现\" title=\"实现\"></a></h3><p>使用ThreadLocal存储每个线程自己的TicketNumber。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TicketLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Integer&gt; LOCAL = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger serviceNumber = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger ticketNumber = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread currentThread = Thread.currentThread();</span><br><span class=\"line\">        Integer threadTicketNumber = ticketNumber.getAndIncrement();</span><br><span class=\"line\">        LOCAL.set(threadTicketNumber);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (threadTicketNumber != serviceNumber.get()) &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Integer threadTicketNumber = LOCAL.get();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (threadTicketNumber != serviceNumber.get())</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\"></span><br><span class=\"line\">        serviceNumber.compareAndSet(threadTicketNumber, threadTicketNumber + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 防止ThreadLocal内存泄露</span></span><br><span class=\"line\">        LOCAL.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点</strong></p>\n<ul><li>公平</li>\n</ul><p><strong>缺点</strong></p>\n<ul><li>不可重入</li>\n<li>每个线程都频繁读取和修改ServiceNumber变量，该变量需要在不同的CPU缓存之间进行缓存同步，导致系统总线繁忙，降低系统的性能</li>\n</ul><h2 id=\"clhlock\">CLHLock<a href=\"#clhlock\" title=\"CLHLock\"></a></h2><p>CLHLock维护一个隐式链表，申请锁的线程只需不断自旋轮询其前驱节点的状态，当发现前驱节点解锁时，即可获取锁。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CLHLock</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;CLHNode&gt; LOCAL = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicReference&lt;CLHNode&gt; tail = <span class=\"keyword\">new</span> AtomicReference&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread currentThread = Thread.currentThread();</span><br><span class=\"line\">        CLHNode node = <span class=\"keyword\">new</span> CLHNode();</span><br><span class=\"line\">        LOCAL.set(node);</span><br><span class=\"line\"></span><br><span class=\"line\">        CLHNode pre = tail.getAndSet(node);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 存在前驱节点，等待其解锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pre != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (pre.isLocked) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread currentThread = Thread.currentThread();</span><br><span class=\"line\">        CLHNode node = LOCAL.get();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tail.compareAndSet(node, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// CAS设置尾节点失败，说明尾节点被其他线程替换掉了，即有线程正在等待获取锁</span></span><br><span class=\"line\">            node.isLocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 防止ThreadLocal内存泄露</span></span><br><span class=\"line\">        LOCAL.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CLHNode</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> isLocked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点</strong></p>\n<ul><li>公平</li>\n<li>只需轮询前驱节点的状态，避免大量CPU缓存同步（SMP架构下）</li>\n</ul><p><strong>缺点</strong></p>\n<ul><li>不可重入</li>\n<li>在NUMA（每个CPU有自己的本地内存，处理器访问它自己的本地存储器的速度比非本地存储器快一些）结构下，若前驱节点较远，则轮询前驱节点的状态效率较低</li>\n</ul><h2 id=\"mcslock\">MCSLock<a href=\"#mcslock\" title=\"MCSLock\"></a></h2><p>MCSLock维护一个显式链表，申请锁的线程只需不断自旋轮询自己节点的状态，当发现前驱节点解锁时，由前驱节点来更改后继节点的状态，通知其获取锁。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MCSLock</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicReference&lt;MCSNode&gt; tail = <span class=\"keyword\">new</span> AtomicReference&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;MCSNode&gt; LOCAL = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Thread currentThread = Thread.currentThread();</span><br><span class=\"line\">        MCSNode node = <span class=\"keyword\">new</span> MCSNode();</span><br><span class=\"line\">        LOCAL.set(node);</span><br><span class=\"line\"></span><br><span class=\"line\">        MCSNode pre = tail.getAndSet(node);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// pre不为null说明有线程已经获取到锁了</span></span><br><span class=\"line\">            <span class=\"comment\">// 设置pre的后继节点为自己</span></span><br><span class=\"line\">            pre.next = node;</span><br><span class=\"line\">            <span class=\"comment\">// 自旋，等待前驱节点解锁，并将当前节点的isLocked设置为false</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(node.isLocked)&#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Thread currentThread = Thread.currentThread();</span><br><span class=\"line\">        MCSNode node = LOCAL.get();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!tail.compareAndSet(node, <span class=\"keyword\">null</span>))&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 尾结点不是自己说明有线程在等待获取锁</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 等待其他线程将其节点绑定到当前线程节点的后继</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(node.next == <span class=\"keyword\">null</span>)&#123;&#125;</span><br><span class=\"line\">            <span class=\"comment\">// 通知其获取锁</span></span><br><span class=\"line\">            node.next.isLocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 防止ThreadLocal内存泄露</span></span><br><span class=\"line\">        LOCAL.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MCSNode</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> isLocked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> MCSNode next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点</strong></p>\n<ul><li>公平</li>\n<li>只需轮询线程自己的节点的状态，访问本地内存</li>\n</ul><p><strong>缺点</strong></p>\n<ul><li>不可重入</li>\n</ul><h1 id=\"参考\">参考<a href=\"#参考\" title=\"参考\"></a></h1><ol><li><a href=\"https://zhuanlan.zhihu.com/p/40729293\" target=\"_blank\">面试必备之深入理解自旋锁</a></li>\n</ol>","prev":{"title":"Java并发之ThreadLocal","link":"post/Java/Java语言/Java并发/Java并发之ThreadLocal"},"next":{"title":"Java并发之顺序控制模式","link":"post/Java/Java语言/Java并发/Java并发之顺序控制模式"},"plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之自旋锁/","toc":[{"id":"自旋锁","title":"自旋锁","index":"1"},{"id":"自旋锁实现","title":"自旋锁实现","index":"2","children":[{"id":"简单cas自旋锁","title":"简单CAS自旋锁","index":"2.1"},{"id":"可重入简单cas自旋锁","title":"可重入简单CAS自旋锁","index":"2.2"},{"id":"ticketlock","title":"TicketLock","index":"2.3","children":[{"id":"原理","title":"原理","index":"2.3.1"},{"id":"实现","title":"实现","index":"2.3.2"}]},{"id":"clhlock","title":"CLHLock","index":"2.4"},{"id":"mcslock","title":"MCSLock","index":"2.5"}]},{"id":"参考","title":"参考","index":"3"}]}