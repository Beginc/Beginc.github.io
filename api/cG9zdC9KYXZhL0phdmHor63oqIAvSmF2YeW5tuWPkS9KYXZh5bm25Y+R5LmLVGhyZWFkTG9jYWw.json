{"title":"Java并发之ThreadLocal","date":"2020-03-15T16:35:30.000Z","date_formatted":{"ll":"Mar 16, 2020","L":"03/16/2020","MM-DD":"03-16"},"link":"post/Java/Java语言/Java并发/Java并发之ThreadLocal","categories":["Java","Java并发","Java语言"],"updated":"2020-03-16T15:31:48.078Z","content":"<h1 id=\"threadlocal简介\">ThreadLocal简介<a href=\"#threadlocal简介\" title=\"ThreadLocal简介\"></a></h1><p>ThreadLocal用于为每个线程创建线程私有的存储空间，其他线程无法访问。</p>\n<h1 id=\"threadlocal使用\">ThreadLocal使用<a href=\"#threadlocal使用\" title=\"ThreadLocal使用\"></a></h1><h2 id=\"创建\">创建<a href=\"#创建\" title=\"创建\"></a></h2><p><strong>不带默认值</strong></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocal&lt;Integer&gt; local = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p><strong>带默认值</strong></p>\n<p>重写initialValue方法，返回一个默认值。</p>\n<ul><li>当ThreadLocal对象没有赋值时就进行get，若设置了initialValue，则会返回initialValue</li>\n</ul><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocal&lt;Integer&gt; local = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"赋值\">赋值<a href=\"#赋值\" title=\"赋值\"></a></h2><p>一个ThreadLocal只能存储一个值。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocal&lt;Integer&gt; local = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\">local.set(<span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"获取\">获取<a href=\"#获取\" title=\"获取\"></a></h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocal&lt;Integer&gt; local = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\">local.set(<span class=\"number\">123</span>);</span><br><span class=\"line\">local.get();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除\">删除<a href=\"#删除\" title=\"删除\"></a></h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocal&lt;Integer&gt; local = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\">local.set(<span class=\"number\">123</span>);</span><br><span class=\"line\">local.remove();</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"threadlocal原理\">ThreadLocal原理<a href=\"#threadlocal原理\" title=\"ThreadLocal原理\"></a></h1><p>ThreadLocal实际上存储在一个ThreadLocalMap的结构中，而这个结构存放在Thread对象中，保证每个线程私有。</p>\n<ul><li>ThreadLocal对象为Key</li>\n<li>存储的值为Value</li>\n</ul><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal/image-20200315205225992.png\" class=\"\">\n\n<h2 id=\"threadlocal源码\">ThreadLocal源码<a href=\"#threadlocal源码\" title=\"ThreadLocal源码\"></a></h2><h3 id=\"get\">Get<a href=\"#get\" title=\"Get\"></a></h3><p>其实就是从ThreadLocalMap中获取以当前ThreadLocal对象为Key的Entry，返回其值。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程对象</span></span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">// 获取线程的ThreadLocalMap</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"comment\">// 获取线程的ThreadLocalMap已经创建了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取Entry</span></span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>获取ThreadLocalMap</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"set\">Set<a href=\"#set\" title=\"Set\"></a></h3><p>以当前ThreadLocal对象为Key，将value放入ThreadLocalMap对应的Entry中。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程对象</span></span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">// 获取线程的ThreadLocalMap</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"comment\">// 创建过了ThreadLocalMap直接放值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"comment\">// 没创建过，创建一个</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建ThreadLocalMap放在线程对象的threadLocals成员里。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">    t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"remove\">Remove<a href=\"#remove\" title=\"Remove\"></a></h3><p>从ThreadLocalMap中删除以当前ThreadLocal对象为Key的Entry。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取线程的ThreadLocalMap</span></span><br><span class=\"line\">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"threadlocalmap介绍\">ThreadLocalMap介绍<a href=\"#threadlocalmap介绍\" title=\"ThreadLocalMap介绍\"></a></h2><p>ThreadLocalMap和HashMap一样也是一个哈希表，但是与HashMap有着很多不同。</p>\n<h3 id=\"哈希算法\">哈希算法<a href=\"#哈希算法\" title=\"哈希算法\"></a></h3><p>ThreadLocalMap使用的哈希算法比较特别，它实现了完美散列，即可以无冲突的填满整个哈希表。</p>\n<ul><li>HASH_INCREMENT为16405315279（有符号整数的黄金分割）</li>\n<li>i为第几个Entry</li>\n<li>capacity为哈希表容量</li>\n</ul><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index = (i + <span class=\"number\">1</span>) * HASH_INCREMENT &amp; (capacity - <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>实验</strong></p>\n<p>测试容量为32时该哈希算法的哈希分布情况。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> capacity = <span class=\"number\">32</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; capacity; i++) &#123;</span><br><span class=\"line\">    System.out.print((i + <span class=\"number\">1</span>) * HASH_INCREMENT &amp; (capacity - <span class=\"number\">1</span>));</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可看到，它实现了无冲突填满整个哈希表。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25 0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"扩容策略\">扩容策略<a href=\"#扩容策略\" title=\"扩容策略\"></a></h3><p>和HashMap相同，扩容为原来的一倍，哈希表的大小总是2的n次方。</p>\n<p><strong>扩容时机</strong></p>\n<ul><li>loadFactor为 2 / 3</li>\n</ul><h3 id=\"冲突解决\">冲突解决<a href=\"#冲突解决\" title=\"冲突解决\"></a></h3><p>与HashMap不同的是，ThreadLocalMap使用开放定址法中的线性探测法来解决哈希冲突，即进行哈希后发现产生了冲突，则线性顺序向后查找，找到空闲的位置放下。</p>\n<h2 id=\"threadlocalmap源码解析\">ThreadLocalMap源码解析<a href=\"#threadlocalmap源码解析\" title=\"ThreadLocalMap源码解析\"></a></h2><h3 id=\"entry\">Entry<a href=\"#entry\" title=\"Entry\"></a></h3><p>继承自WeakReference，并且在构造函数里把ThreadLocal对象包装进了WeakReference。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">    Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"threadlocalmap内存泄露\">ThreadLocalMap内存泄露<a href=\"#threadlocalmap内存泄露\" title=\"ThreadLocalMap内存泄露\"></a></h3><p>在Entry中，作为Key的ThreadLocal对象被包装进了WeakReference，引用关系如下图。</p>\n<ul><li>实线箭头为强引用</li>\n<li>虚线箭头为弱引用</li>\n</ul><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal/image-20200315212823520.png\" class=\"\">\n\n<p>假如我们使用完ThreadLocal后不再对其进行引用了，而线程依旧活跃，此时引用关系如下。</p>\n<ul><li>此时Entry中的Key没有强引用进行引用，只有虚引用对其进行引用</li>\n<li>在GC时即使内存充足也会把Key给回收</li>\n<li><strong>Key回收后，Value由于还有Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; Value的引用链，而且活跃线程对象为GC Root，这会导致Value占用的内存得不到释放</strong></li>\n</ul><img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal/image-20200315213012243.png\" class=\"\">\n\n<p><strong>解决方法</strong></p>\n<p>使用完ThreadLocal对象后使用remove方法将其移除，断开引用链。</p>\n<h3 id=\"threadlocalmap脏entry\">ThreadLocalMap脏Entry<a href=\"#threadlocalmap脏entry\" title=\"ThreadLocalMap脏Entry\"></a></h3><p>由于虚引用的关系，在ThreadLocalMap中可能会产生有Entry但是Key为null的脏Entry，一直占用着哈希表的位置，因此我们需要使用某种方法将脏Entry给清除。</p>\n<h3 id=\"set-1\">Set<a href=\"#set-1\" title=\"Set\"></a></h3><p><strong>ThreadLocal.threadLocalHashCode产生</strong></p>\n<p>在实例化ThreadLocal对象时调用nextHashCode方法产生</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal/image-20200315213822924.png\" class=\"\">\n\n<p>ThreadLocal类有一个静态的原子整数，每产生一个ThreadLocal对象，其值就增加HASH_INCREMENT</p>\n<img src=\"/post/Java/Java%E8%AF%AD%E8%A8%80/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E4%B9%8BThreadLocal/image-20200315214051471.png\" class=\"\">\n\n<p><strong>设置</strong></p>\n<p>进行线性探测</p>\n<ol><li>找到自己对应Key的Entry就放进去</li>\n<li>找到一个空位，跳出循环，新建一个Entry放进去</li>\n<li>找到一个脏Entry，替换该脏Entry，并进行一些脏Entry清理工作</li>\n</ol><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// We don't use a fast path as with get() because it is at</span></span><br><span class=\"line\">    <span class=\"comment\">// least as common to use set() to create new entries as</span></span><br><span class=\"line\">    <span class=\"comment\">// it is to replace existing ones, in which case, a fast</span></span><br><span class=\"line\">    <span class=\"comment\">// path would fail more often than not.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"comment\">// 进行散列</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 进行线性探测</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 找到自己对应Key的Entry就放进去</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 找到一个空位，跳出循环，新建一个Entry放进去</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 找到一个脏Entry，替换该脏Entry，并进行一些脏Entry清理工作</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 1.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 3.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            replaceStaleEntry(key, value, i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 2.</span></span><br><span class=\"line\">    tab[i] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sz = ++size;</span><br><span class=\"line\">    <span class=\"comment\">// 先清理脏Entry，若清理不出空间来并且超过了扩容阈值，则进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class=\"line\">        rehash();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"get-1\">Get<a href=\"#get-1\" title=\"Get\"></a></h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 散列</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    Entry e = table[i];</span><br><span class=\"line\">    <span class=\"comment\">// 获取到了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == key)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    <span class=\"comment\">// 没获取到，进行线性探测查找</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> getEntryAfterMiss(key, i, e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>线性探测查找</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntryAfterMiss</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, <span class=\"keyword\">int</span> i, Entry e)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"comment\">// 找到了就返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">        <span class=\"comment\">// 遇见了脏Entry，进行清理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            expungeStaleEntry(i);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"comment\">// 循环向后查找</span></span><br><span class=\"line\">            i = nextIndex(i, len);</span><br><span class=\"line\">        e = tab[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考\">参考<a href=\"#参考\" title=\"参考\"></a></h1><ol><li><a href=\"https://www.jianshu.com/p/30ee77732843\" target=\"_blank\">并发容器之ThreadLocal</a></li>\n<li><a href=\"https://www.jianshu.com/p/dde92ec37bd1\" target=\"_blank\">一篇文章，从源码深入详解ThreadLocal内存泄漏问题</a></li>\n</ol>","prev":{"title":"Java集合之Vector","link":"post/Java/Java语言/Java集合/Java集合之Vector"},"next":{"title":"Java并发之自旋锁","link":"post/Java/Java语言/Java并发/Java并发之自旋锁"},"plink":"https://beginc.github.io/post/Java/Java语言/Java并发/Java并发之ThreadLocal/","toc":[{"id":"threadlocal简介","title":"ThreadLocal简介","index":"1"},{"id":"threadlocal使用","title":"ThreadLocal使用","index":"2","children":[{"id":"创建","title":"创建","index":"2.1"},{"id":"赋值","title":"赋值","index":"2.2"},{"id":"获取","title":"获取","index":"2.3"},{"id":"删除","title":"删除","index":"2.4"}]},{"id":"threadlocal原理","title":"ThreadLocal原理","index":"3","children":[{"id":"threadlocal源码","title":"ThreadLocal源码","index":"3.1","children":[{"id":"get","title":"Get","index":"3.1.1"},{"id":"set","title":"Set","index":"3.1.2"},{"id":"remove","title":"Remove","index":"3.1.3"}]},{"id":"threadlocalmap介绍","title":"ThreadLocalMap介绍","index":"3.2","children":[{"id":"哈希算法","title":"哈希算法","index":"3.2.1"},{"id":"扩容策略","title":"扩容策略","index":"3.2.2"},{"id":"冲突解决","title":"冲突解决","index":"3.2.3"}]},{"id":"threadlocalmap源码解析","title":"ThreadLocalMap源码解析","index":"3.3","children":[{"id":"entry","title":"Entry","index":"3.3.1"},{"id":"threadlocalmap内存泄露","title":"ThreadLocalMap内存泄露","index":"3.3.2"},{"id":"threadlocalmap脏entry","title":"ThreadLocalMap脏Entry","index":"3.3.3"},{"id":"set-1","title":"Set","index":"3.3.4"},{"id":"get-1","title":"Get","index":"3.3.5"}]}]},{"id":"参考","title":"参考","index":"4"}]}