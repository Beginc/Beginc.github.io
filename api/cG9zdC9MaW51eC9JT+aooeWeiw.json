{"title":"I/O模型","date":"2020-02-27T13:22:16.000Z","date_formatted":{"ll":"Feb 27, 2020","L":"02/27/2020","MM-DD":"02-27"},"thumbnail":"post/Linux/IO模型/cover.jpg","link":"post/Linux/IO模型","categories":["Linux"],"updated":"2020-02-29T16:20:45.527Z","content":"<h1 id=\"概念区分\">概念区分<a href=\"#概念区分\" title=\"概念区分\"></a></h1><h2 id=\"阻塞与非阻塞\">阻塞与非阻塞<a href=\"#阻塞与非阻塞\" title=\"阻塞与非阻塞\"></a></h2><p>阻塞与非阻塞是对请求的发起者而言的</p>\n<ul><li>阻塞：请求未返回之前，发起者一直等待其返回，不做其他任何事情</li>\n<li>非阻塞：请求发起后不等待其返回，就去做其他事情</li>\n</ul><p><strong>举例</strong></p>\n<ul><li>阻塞即买炒饭时老板没做好，你就一直等着，啥也不干</li>\n<li>阻塞即买炒饭时告诉老板来一碗炒饭，之后你就开始玩手机，干其他事</li>\n</ul><h2 id=\"同步与异步\">同步与异步<a href=\"#同步与异步\" title=\"同步与异步\"></a></h2><p>同步与异步是对请求的响应者而言的</p>\n<ul><li>同步：请求未处理完之前不返回响应</li>\n<li>异步：请求接收到之后马上返回响应，之后再进行处理</li>\n</ul><p><strong>举例</strong></p>\n<ul><li>同步即炒饭老板听到别人说来一碗炒饭后，没炒完饭不给他回应</li>\n<li>异步即炒饭老板听到别人说来一碗炒饭后，直接告诉他收到了马上炒，然后开始炒饭</li>\n</ul><h1 id=\"io模型\">I/O模型<a href=\"#io模型\" title=\"I/O模型\"></a></h1><h2 id=\"阻塞io\">阻塞I/O<a href=\"#阻塞io\" title=\"阻塞I/O\"></a></h2><img src=\"/post/Linux/IO%E6%A8%A1%E5%9E%8B/2717496-d6ae0b9e0e239803.webp\" class=\"\">\n\n<h2 id=\"非阻塞io\">非阻塞I/O<a href=\"#非阻塞io\" title=\"非阻塞I/O\"></a></h2><p>需要CPU轮询来检查数据是否准备好</p>\n<img src=\"/post/Linux/IO%E6%A8%A1%E5%9E%8B/2717496-e027a460cb85cb20.webp\" class=\"\">\n\n<h2 id=\"信号驱动io\">信号驱动I/O<a href=\"#信号驱动io\" title=\"信号驱动I/O\"></a></h2><ul><li>调用sigaction时立刻返回，建立信号处理程序</li>\n<li>数据准备好后通知信号处理程序</li>\n<li>执行recvfrom复制数据</li>\n</ul><p>免去了CPU轮询的过程</p>\n<img src=\"/post/Linux/IO%E6%A8%A1%E5%9E%8B/2717496-775e3b5afed414fa.webp\" class=\"\">\n\n<h2 id=\"异步io\">异步I/O<a href=\"#异步io\" title=\"异步I/O\"></a></h2><p>异步I/O与信号驱动I/O最大区别在于，信号驱动是内核通知我们何时开始一个I/O操作，而异步I/O是由内核通知我们I/O操作何时完成，两者有本质区别。</p>\n<img src=\"/post/Linux/IO%E6%A8%A1%E5%9E%8B/2717496-7a531bfa0c353081.webp\" class=\"\">\n\n<h2 id=\"io多路复用\">I/O多路复用<a href=\"#io多路复用\" title=\"I/O多路复用\"></a></h2><p>I/O多路复用（Multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。</p>\n<h3 id=\"select\">Select<a href=\"#select\" title=\"Select\"></a></h3><ol><li>调用select时传入要监视的fd_set（socket描述符数组）</li>\n</ol><ul><li>把进程添加到所有socket的等待队列中，进程阻塞</li>\n</ul><img src=\"/post/Linux/IO%E6%A8%A1%E5%9E%8B/v2-0cccb4976f8f2c2f8107f2b3a5bc46b3_720w.jpg\" class=\"\">\n\n<ol><li>数据到来时通过中断程序将进程从所有socket等待队列中移除，唤醒进程</li>\n</ol><img src=\"/post/Linux/IO%E6%A8%A1%E5%9E%8B/v2-85dba5430f3c439e4647ea4d97ba54fc_720w.jpg\" class=\"\">\n\n<img src=\"/post/Linux/IO%E6%A8%A1%E5%9E%8B/v2-a86b203b8d955466fff34211d965d9eb_720w.jpg\" class=\"\">\n\n<ol><li>进程被唤醒时，并不知道是哪个socket有数据，需要对其进行遍历，判断之后做出处理</li>\n</ol><p><strong>缺点</strong></p>\n<ul><li>每次调用select都需要将进程加入到所有监视socket的等待队列</li>\n<li>每次唤醒都需要从每个队列中移除</li>\n<li>每次调用select，都需要把fd_set集合从用户态拷贝到内核态（因此限制fd_set最大为1024）</li>\n</ul><h3 id=\"poll\">Poll<a href=\"#poll\" title=\"Poll\"></a></h3><p>poll的机制与select类似，与select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。</p>\n<h3 id=\"epoll\">Epoll<a href=\"#epoll\" title=\"Epoll\"></a></h3><p><strong>功能分离</strong></p>\n<p>和select不同，epoll通过引入eventpoll对象将维护等待队列和阻塞进程功能分离。避免每次都把进程遍历加入socket等待队列/移出等待队列。</p>\n<ul><li>当某个进程调用epoll_create方法时，内核会创建一个eventpoll对象</li>\n<li>创建epoll对象后，可以用epoll_ctl添加或删除所要监听的socket，内核会将eventpoll添加到socket的等待队列中</li>\n<li>进程执行epoll_wait语句后，内核会将进程放入eventpoll的等待队列中，阻塞进程</li>\n</ul><img src=\"/post/Linux/IO%E6%A8%A1%E5%9E%8B/v2-b49bb08a6a1b7159073b71c4d6591185_720w.jpg\" class=\"\">\n\n<img src=\"/post/Linux/IO%E6%A8%A1%E5%9E%8B/v2-90632d0dc3ded7f91379b848ab53974c_720w.jpg\" class=\"\">\n\n<p><strong>维护就绪列表</strong></p>\n<p>不同于select，epoll还会维护就绪的socket的列表，避免程序对socket进行遍历。进程被唤醒后直接通过就绪列表就可知道就绪的socket。</p>\n<p><strong>触发方式</strong></p>\n<ul><li>水平触发：只要监听的文件描述符中有数据，就会触发epoll_wait返回</li>\n<li>边缘触发：只有监听的文件描述符的读/写事件发生，才会触发epoll_wait返回</li>\n</ul><h1 id=\"参考\">参考<a href=\"#参考\" title=\"参考\"></a></h1><ol><li><a href=\"https://zhuanlan.zhihu.com/p/63179839\" target=\"_blank\">如果这篇文章说不清epoll的本质，那就过来掐死我吧！</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/66148226\" target=\"_blank\">迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO讲的这么清楚的好文章</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/107995399\" target=\"_blank\">linux多路IO--epoll(一)--水平触发和边沿触发</a></li>\n<li><a href=\"https://blog.csdn.net/uestcprince/article/details/90734564\" target=\"_blank\">信号驱动IO与异步IO</a></li>\n</ol>","prev":{"title":"Java之NIO","link":"post/Java/Java语言/Java之NIO"},"next":{"title":"Linux零拷贝","link":"post/Linux/Linux零拷贝"},"plink":"https://beginc.github.io/post/Linux/IO模型/","toc":[{"id":"概念区分","title":"概念区分","index":"1","children":[{"id":"阻塞与非阻塞","title":"阻塞与非阻塞","index":"1.1"},{"id":"同步与异步","title":"同步与异步","index":"1.2"}]},{"id":"io模型","title":"I&#x2F;O模型","index":"2","children":[{"id":"阻塞io","title":"阻塞I&#x2F;O","index":"2.1"},{"id":"非阻塞io","title":"非阻塞I&#x2F;O","index":"2.2"},{"id":"信号驱动io","title":"信号驱动I&#x2F;O","index":"2.3"},{"id":"异步io","title":"异步I&#x2F;O","index":"2.4"},{"id":"io多路复用","title":"I&#x2F;O多路复用","index":"2.5","children":[{"id":"select","title":"Select","index":"2.5.1"},{"id":"poll","title":"Poll","index":"2.5.2"},{"id":"epoll","title":"Epoll","index":"2.5.3"}]}]},{"id":"参考","title":"参考","index":"3"}]}